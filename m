Return-Path: <linux-kernel-owner+willy=40w.ods.org@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S263024AbTHVFIw (ORCPT <rfc822;willy@w.ods.org>);
	Fri, 22 Aug 2003 01:08:52 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S263022AbTHVFIw
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Fri, 22 Aug 2003 01:08:52 -0400
Received: from m004189.ppp.asahi-net.or.jp ([219.121.4.189]:13558 "EHLO
	mitou.y-sato.ddo.jp") by vger.kernel.org with ESMTP id S263026AbTHVFGl
	(ORCPT <rfc822;linux-kernel@vger.kernel.org>);
	Fri, 22 Aug 2003 01:06:41 -0400
Date: Fri, 22 Aug 2003 14:06:01 +0900
Message-ID: <m2vfsq8eo6.wl%ysato@users.sourceforge.jp>
From: Yoshinori Sato <ysato@users.sourceforge.jp>
To: Linus Torvalds <torvalds@osdl.org>
Cc: linux kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: [PATCH] h8300 support fix (2/2)
User-Agent: Wanderlust/2.11.3 (Wonderwall) SEMI/1.14.5 (Awara-Onsen) LIMIT/1.14.7 (Fujiidera) APEL/10.6 Emacs/21.3 (i386-pc-linux-gnu) MULE/5.0 (SAKAKI)
MIME-Version: 1.0 (generated by SEMI 1.14.5 - "Awara-Onsen")
Content-Type: text/plain; charset=US-ASCII
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

o inline assembler funcs cleanup
o machine depend header cleanup
o interrupt management fix

-- 
Yoshinori Sato
<ysato@users.sourceforge.jp>

diff -Nru linux-2.6.0-test3/include/asm-h8300/aki3068net/machine-depend.h linux-2.6.0-test3-h8300/include/asm-h8300/aki3068net/machine-depend.h
--- linux-2.6.0-test3/include/asm-h8300/aki3068net/machine-depend.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/aki3068net/machine-depend.h	2003-08-22 00:55:15.000000000 +0900
@@ -0,0 +1,35 @@
+/* AE-3068 board depend header */
+
+/* TIMER rate define */
+#ifdef H8300_TIMER_DEFINE
+#include <linux/config.h>
+#define H8300_TIMER_COUNT_DATA 20000*10/8192
+#define H8300_TIMER_FREQ 20000*1000/8192
+#endif
+
+/* AE-3068 RTL8019AS Config */
+#ifdef H8300_NE_DEFINE
+
+#define NE2000_ADDR		0x200000
+#define NE2000_IRQ              5
+#define NE2000_IRQ_VECTOR	(12 + NE2000_IRQ)
+#define	NE2000_BYTE		volatile unsigned short
+
+#define IER                     0xfee015
+#define ISR			0xfee016
+#define IRQ_MASK		(1 << NE2000_IRQ)
+
+#define WCRL                    0xfee023
+#define MAR0A                   0xffff20
+#define ETCR0A                  0xffff24
+#define DTCR0A                  0xffff27
+#define MAR0B                   0xffff28
+#define DTCR0B                  0xffff2f
+
+#define H8300_INIT_NE()                  \
+do {                                     \
+	wordlength = 1;                  \
+        outb_p(0x48, ioaddr + EN0_DCFG); \
+} while(0)
+
+#endif
diff -Nru linux-2.6.0-test3/include/asm-h8300/atomic.h linux-2.6.0-test3-h8300/include/asm-h8300/atomic.h
--- linux-2.6.0-test3/include/asm-h8300/atomic.h	2003-08-09 20:30:32.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/atomic.h	2003-08-22 00:55:15.000000000 +0900
@@ -71,56 +71,27 @@
 	return ret == 0;
 }
 
-#if defined(__H8300H__)
 static __inline__ void atomic_clear_mask(unsigned long mask, unsigned long *v)
 {
-	__asm__ __volatile__("stc ccr,r2l\n\t"
+	__asm__ __volatile__("stc ccr,r1l\n\t"
 	                     "orc #0x80,ccr\n\t"
 	                     "mov.l %0,er0\n\t"
-	                     "mov.l %1,er1\n\t"
-	                     "and.l er1,er0\n\t"
+	                     "and.l %1,er0\n\t"
 	                     "mov.l er0,%0\n\t"
-	                     "ldc r2l,ccr" 
-                             : "=m" (*v) : "ir" (~(mask)) :"er0","er1","er2");
+	                     "ldc r1l,ccr" 
+                             : "=m" (*v) : "g" (~(mask)) :"er0","er1");
 }
 
 static __inline__ void atomic_set_mask(unsigned long mask, unsigned long *v)
 {
-	__asm__ __volatile__("stc ccr,r2l\n\t"
+	__asm__ __volatile__("stc ccr,r1l\n\t"
 	                     "orc #0x80,ccr\n\t"
 	                     "mov.l %0,er0\n\t"
-	                     "mov.l %1,er1\n\t"
-	                     "or.l er1,er0\n\t"
+	                     "or.l %1,er0\n\t"
 	                     "mov.l er0,%0\n\t"
-	                     "ldc r2l,ccr" 
-                             : "=m" (*v) : "ir" (mask) :"er0","er1","er2");
+	                     "ldc r1l,ccr" 
+                             : "=m" (*v) : "g" (mask) :"er0","er1");
 }
-#endif
-#if defined(__H8300S__)
-static __inline__ void atomic_clear_mask(unsigned long mask, unsigned long *v)
-{
-	__asm__ __volatile__("stc exr,r2l\n\t"
-	                     "orc #0x07,exr\n\t"
-	                     "mov.l %0,er0\n\t"
-	                     "mov.l %1,er1\n\t"
-	                     "and.l er1,er0\n\t"
-	                     "mov.l er0,%0\n\t"
-	                     "ldc r2l,exr" 
-                             : "=m" (*v) : "ir" (~(mask)) :"er0","er1","er2");
-}
-
-static __inline__ void atomic_set_mask(unsigned long mask, unsigned long *v)
-{
-	__asm__ __volatile__("stc exr,r2l\n\t"
-	                     "orc #0x07,exr\n\t"
-	                     "mov.l %0,er0\n\t"
-	                     "mov.l %1,er1\n\t"
-	                     "or.l er1,er0\n\t"
-	                     "mov.l er0,%0\n\t"
-	                     "ldc r2l,exr" 
-                             : "=m" (*v) : "ir" (mask) :"er0","er1","er2");
-}
-#endif
 
 /* Atomic operations are already serializing */
 #define smp_mb__before_atomic_dec()    barrier()
diff -Nru linux-2.6.0-test3/include/asm-h8300/bitops.h linux-2.6.0-test3-h8300/include/asm-h8300/bitops.h
--- linux-2.6.0-test3/include/asm-h8300/bitops.h	2003-08-09 20:30:32.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/bitops.h	2003-08-22 00:55:15.000000000 +0900
@@ -39,16 +39,18 @@
 
 static __inline__ void set_bit(int nr, volatile unsigned long* addr)
 {
-	unsigned char *a = (unsigned char *) addr;
-	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
+	volatile unsigned char *b_addr;
+	b_addr = &(((volatile unsigned char *) addr)
+	          [((nr >> 3) & ~3) + 3 - ((nr >> 3) & 3)]);
 	__asm__("mov.l %1,er0\n\t"
-		"mov.l %0,er1\n\t"
-		"bset r0l,@er1"
-		:"=m"(a):"g"(nr & 7):"er0","er1","memory");
+		"bset r0l,%0"
+		:"+m"(*b_addr)
+		:"g"(nr & 7),"m"(*b_addr)
+		:"er0");
 }
-/* Bigendian is complexed... */
 
-#define __set_bit(nr, addr) set_bit(nr, addr)
+/* Bigendian is complexed... */
+#define __set_bit(nr, addr) set_bit((nr), (addr))
 
 /*
  * clear_bit() doesn't provide any barrier for the compiler.
@@ -58,261 +60,158 @@
 
 static __inline__ void clear_bit(int nr, volatile unsigned long* addr)
 {
-	unsigned char *a = (unsigned char *) addr;
-	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
+	volatile unsigned char *b_addr;
+	b_addr = &(((volatile unsigned char *) addr)
+	          [((nr >> 3) & ~3) + 3 - ((nr >> 3) & 3)]);
 	__asm__("mov.l %1,er0\n\t"
-		"mov.l %0,er1\n\t"
-		"bclr r0l,@er1"
-		:"=m"(a):"g"(nr & 7):"er0","er1","memory");
+		"bclr r0l,%0"
+		:"+m"(*b_addr)
+		:"g"(nr & 7),"m"(*b_addr)
+		:"er0");
 }
 
-#define __clear_bit(nr, addr) clear_bit(nr, addr)
+#define __clear_bit(nr, addr) clear_bit((nr), (addr))
 
 static __inline__ void change_bit(int nr, volatile unsigned long* addr)
 {
-	unsigned char *a = (unsigned char *) addr;
-	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
+	volatile unsigned char *b_addr;
+	b_addr = &(((volatile unsigned char *) addr)
+	          [((nr >> 3) & ~3) + 3 - ((nr >> 3) & 3)]);
 	__asm__("mov.l %1,er0\n\t"
-		"mov.l %0,er1\n\t"
-		"bnot r0l,@er1"
-		:"=m"(a):"g"(nr & 7):"er0","er1","memory");
+		"bnot r0l,%0"
+		:"+m"(*b_addr)
+		:"g"(nr & 7),"m"(*b_addr)
+		:"er0");
 }
 
-#define __change_bit(nr, addr) change_bit(nr, addr)
+#define __change_bit(nr, addr) change_bit((nr), (addr))
 
-#if defined(__H8300H__)
-static __inline__ int test_and_set_bit(int nr, volatile unsigned long* addr)
+static __inline__ int test_bit(int nr, const unsigned long* addr)
 {
-	int retval;
-	unsigned char *a;
-	a = (unsigned char *) addr;
-
-	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %2,er0\n\t"
-		"stc ccr,r0h\n\t"
-		"orc #0x80,ccr\n\t"
-		"mov.b %1,r1l\n\t"
-		"btst r0l,r1l\n\t"
-		"bset r0l,r1l\n\t"
-		"stc ccr,r0l\n\t"
-		"mov.b r1l,%1\n\t"
-		"ldc r0h,ccr\n\t"
-		"sub.l %0,%0\n\t"
-		"bild #2,r0l\n\t"
-		"rotxl.l %0"
-		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","er1","memory");
-	return retval;
+	return ((1UL << (nr & 7)) & 
+               (((const volatile unsigned char *) addr)
+               [((nr >> 3) & ~3) + 3 - ((nr >> 3) & 3)])) != 0;
 }
-#endif
-#if defined(__H8300S__)
+
+#define __test_bit(nr, addr) test_bit(nr, addr)
+
 static __inline__ int test_and_set_bit(int nr, volatile unsigned long* addr)
 {
-	int retval;
-	unsigned char *a;
-	a = (unsigned char *) addr;
+	register int retval __asm__("er0");
+	volatile unsigned char *a;
+	a = (volatile unsigned char *)addr;
 
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %2,er0\n\t"
-		"stc exr,r0h\n\t"
-		"orc #0x07,exr\n\t"
-		"mov.b %1,r1l\n\t"
-		"btst r0l,r1l\n\t"
-		"bset r0l,r1l\n\t"
-		"stc ccr,r0l\n\t"
-		"mov.b r1l,%1\n\t"
-		"ldc r0h,exr\n\t"
+	__asm__("mov.l %2,er3\n\t"
 		"sub.l %0,%0\n\t"
-		"bild #2,r0l\n\t"
-		"rotxl.l %0"
-		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","er1","memory");
+		"stc ccr,r3h\n\t"
+		"orc #0x80,ccr\n\t"
+		"btst r3l,%1\n\t"
+		"bset r3l,%1\n\t"
+		"beq 1f\n\t"
+		"inc.l #1,%0\n\t"
+		"1:"
+		"ldc r3h,ccr"
+		: "=r"(retval),"+m"(*a) :"g"(nr & 7):"er3","memory");
 	return retval;
 }
-#endif
 
 static __inline__ int __test_and_set_bit(int nr, volatile unsigned long* addr)
 {
-	int retval;
-	unsigned char *a = (unsigned char *) addr;
+	register int retval __asm__("er0");
+	volatile unsigned char *a;
+	a = (volatile unsigned char *)addr;
 
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %2,er0\n\t"
-		"mov.b %1,r0h\n\t"
-		"btst r0l,r0h\n\t"
-		"bset r0l,r0h\n\t"
-		"stc ccr,r0l\n\t"
-		"mov.b r0h,%1\n\t"
+	__asm__("mov.l %2,er3\n\t"
 		"sub.l %0,%0\n\t"
-		"bild #2,r0l\n\t"
-		"rotxl.l %0"
-		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","memory");
+		"btst r3l,%1\n\t"
+		"bset r3l,%1\n\t"
+		"beq 1f\n\t"
+		"inc.l #1,%0\n\t"
+		"1:"
+		: "=r"(retval),"+m"(*a) :"g"(nr & 7):"er3","memory");
 	return retval;
 }
 
-#if defined(__H8300H__)
 static __inline__ int test_and_clear_bit(int nr, volatile unsigned long* addr)
 {
-	int retval;
-	unsigned char *a = (unsigned char *) addr;
+	register int retval __asm__("er0");
+	volatile unsigned char *a;
+	a = (volatile unsigned char *)addr;
 
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %2,er0\n\t"
-		"stc ccr,r0h\n\t"
-		"orc #0x80,ccr\n\t"
-		"mov.b %1,r1l\n\t"
-		"btst r0l,r1l\n\t"
-		"bclr r0l,r1l\n\t"
-		"stc ccr,r0l\n\t"
-		"mov.b r1l,%1\n\t"
-		"ldc r0h,ccr\n\t"
+	__asm__("mov.l %2,er3\n\t"
 		"sub.l %0,%0\n\t"
-		"bild #2,r0l\n\t"
-		"rotxl.l %0"
-		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","er1","memory");
-	return retval;
-}
-#endif
-#if defined(__H8300S__)
-static __inline__ int test_and_clear_bit(int nr, volatile unsigned long* addr)
-{
-	int retval;
-	unsigned char *a = (unsigned char *) addr;
-
-	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %2,er0\n\t"
-		"stc exr,r0h\n\t"
-		"orc #0x07,exr\n\t"
-		"mov.b %1,r1l\n\t"
-		"btst r0l,r1l\n\t"
-		"bclr r0l,r1l\n\t"
-		"stc ccr,r0l\n\t"
-		"mov.b r1l,%1\n\t"
-		"ldc r0h,exr\n\t"
-		"sub.l %0,%0\n\t"
-		"bild #2,r0l\n\t"
-		"rotxl.l %0"
-		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","er1","memory");
+		"stc ccr,r3h\n\t"
+		"orc #0x80,ccr\n\t"
+		"btst r3l,%1\n\t"
+		"bclr r3l,%1\n\t"
+		"beq 1f\n\t"
+		"inc.l #1,%0\n\t"
+		"1:"
+		"ldc r3h,ccr"
+		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er3","memory");
 	return retval;
 }
-#endif
 
 static __inline__ int __test_and_clear_bit(int nr, volatile unsigned long* addr)
 {
-	int retval;
-	unsigned char *a = (unsigned char *) addr;
+	register int retval __asm__("er0");
+	volatile unsigned char *a;
+	a = (volatile unsigned char *)addr;
 
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %2,er0\n\t"
-		"mov.b %1,r0h\n\t"
-		"btst r0l,r0h\n\t"
-		"bclr r0l,r0h\n\t"
-		"stc ccr,r0l\n\t"
-		"mov.b r0h,%1\n\t"
+	__asm__("mov.l %2,er3\n\t"
 		"sub.l %0,%0\n\t"
-		"bild #2,r0l\n\t"
-		"rotxl.l %0"
-		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","memory");
+		"btst r3l,%1\n\t"
+		"bclr r3l,%1\n\t"
+		"beq 1f\n\t"
+		"inc.l #1,%0\n\t"
+		"1:"
+		: "=r"(retval),"+m"(*a) :"g"(nr & 7):"er3","memory");
 	return retval;
 }
 
-#if defined(__H8300H__)
 static __inline__ int test_and_change_bit(int nr, volatile unsigned long* addr)
 {
-	int retval;
-	unsigned char *a = (unsigned char *) addr;
+	register int retval __asm__("er0");
+	volatile unsigned char *a;
+	a = (volatile unsigned char *)addr;
 
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %2,er0\n\t"
-		"stc ccr,r0h\n\t"
-		"orc #0x80,ccr\n\t"
-		"mov.b %1,r1l\n\t"
-		"btst r0l,r1l\n\t"
-		"bnot r0l,r1l\n\t"
-		"stc ccr,r0l\n\t"
-		"mov.b r1l,%1\n\t"
-		"ldc r0h,ccr\n\t"
+	__asm__("mov.l %2,er3\n\t"
 		"sub.l %0,%0\n\t"
-		"bild #2,r0l\n\t"
-		"rotxl.l %0"
-		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","er1","memory");
-	return retval;
-}
-#endif
-#if defined(__H8300S__)
-static __inline__ int test_and_change_bit(int nr, volatile unsigned long* addr)
-{
-	int retval;
-	unsigned char *a = (unsigned char *) addr;
-
-	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %2,er0\n\t"
-		"stc exr,r0h\n\t"
-		"orc #0x07,exr\n\t"
-		"mov.b %1,r1l\n\t"
-		"btst r0l,r1l\n\t"
-		"bnot r0l,r1l\n\t"
-		"stc ccr,r0l\n\t"
-		"mov.b r1l,%1\n\t"
-		"ldc r0h,exr\n\t"
-		"sub.l %0,%0\n\t"
-		"bild #2,r0l\n\t"
-		"rotxl.l %0"
-		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","er1","memory");
+		"stc ccr,r3h\n\t"
+		"orc #0x80,ccr\n\t"
+		"btst r3l,%1\n\t"
+		"bnot r3l,%1\n\t"
+		"beq 1f\n\t"
+		"inc.l #1,%0\n\t"
+		"1:"
+		"ldc r3h,ccr"
+		: "=r"(retval),"+m"(*a) :"g"(nr & 7):"er3","memory");
 	return retval;
 }
-#endif
 
 static __inline__ int __test_and_change_bit(int nr, volatile unsigned long* addr)
 {
-	int retval;
-	unsigned char *a = (unsigned char *) addr;
+	register int retval __asm__("er0");
+	volatile unsigned char *a;
+	a = (volatile unsigned char *)addr;
 
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %2,er0\n\t"
-		"mov.b %1,r0h\n\t"
-		"btst r0l,r0h\n\t"
-		"bnot r0l,r0h\n\t"
-		"stc ccr,r0l\n\t"
-		"mov.b r0h,%1\n\t"
+	__asm__("mov.l %2,er3\n\t"
 		"sub.l %0,%0\n\t"
-		"bild #2,r0l\n\t"
-		"rotxl.l %0"
-		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","memory");
-	return retval;
-}
-
-/*
- * This routine doesn't need to be atomic.
- */
-static __inline__ int __constant_test_bit(int nr, const volatile unsigned long* addr)
-{
-	return ((1UL << (nr & 31)) & (((const volatile unsigned int *) addr)[nr >> 5])) != 0;
-}
-
-static __inline__ int __test_bit(int nr, const unsigned long* addr)
-{
-	int retval;
-	unsigned char *a = (unsigned char *) addr;
-
-	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %1,er0\n\t"
-		"btst r0l,@%2\n\t"
+		"btst r3l,%1\n\t"
+		"bnot r3l,%1\n\t"
 		"beq 1f\n\t"
-		"sub.l %0,%0\n\t"
-		"inc.l #1,%0\n"
-		"bra 2f\n"
-		"1:\n\t"
-		"sub.l %0,%0\n"
-		"2:"
-		: "=r"(retval) :"g"(nr & 7),"r"(a):"er0");
+		"inc.l #1,%0\n\t"
+		"1:"
+		: "=r"(retval),"+m"(*a) :"g"(nr & 7):"er3","memory");
 	return retval;
 }
 
-#define test_bit(nr,addr) \
-(__builtin_constant_p(nr) ? \
- __constant_test_bit((nr),(addr)) : \
- __test_bit((nr),(addr)))
-
-
 #define find_first_zero_bit(addr, size) \
         find_next_zero_bit((addr), (size), 0)
 
diff -Nru linux-2.6.0-test3/include/asm-h8300/edosk2674/machine-depend.h linux-2.6.0-test3-h8300/include/asm-h8300/edosk2674/machine-depend.h
--- linux-2.6.0-test3/include/asm-h8300/edosk2674/machine-depend.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/edosk2674/machine-depend.h	2003-08-22 00:55:15.000000000 +0900
@@ -0,0 +1,70 @@
+/* EDOSK2674 board depend header */
+
+/* TIMER rate define */
+#ifdef H8300_TIMER_DEFINE
+#define H8300_TIMER_COUNT_DATA 33000*10/8192
+#define H8300_TIMER_FREQ 33000*1000/8192
+#endif
+
+/* EDOSK-2674R SMSC Network Controler Target Depend impliments */
+#ifdef H8300_SMSC_DEFINE
+
+#define SMSC_BASE 0xf80000
+#define SMSC_IRQ 16
+
+/* sorry quick hack */
+#if defined(outw)
+# undef outw
+#endif
+#define outw(d,a) edosk2674_smsc_outw(d,(volatile unsigned short *)(a))
+#if defined(inw)
+# undef inw
+#endif
+#define inw(a) edosk2674_smsc_inw((volatile unsigned short *)(a))
+#if defined(outsw)
+# undef outsw
+#endif
+#define outsw(a,p,l) edosk2674_smsc_outsw((volatile unsigned short *)(a),p,l)
+#if defined(insw)
+# undef insw
+#endif
+#define insw(a,p,l) edosk2674_smsc_insw((volatile unsigned short *)(a),p,l)
+
+static inline void edosk2674_smsc_outw(
+	unsigned short d,
+	volatile unsigned short *a
+	)
+{
+	*a = (d >> 8) | (d << 8);
+}
+
+static inline unsigned short edosk2674_smsc_inw(
+	volatile unsigned short *a
+	)
+{
+	unsigned short d;
+	d = *a;
+	return (d >> 8) | (d << 8);
+}
+
+static inline void edosk2674_smsc_outsw(
+	volatile unsigned short *a,
+	unsigned short *p,
+	unsigned long l
+	)
+{
+	for (; l != 0; --l, p++)
+		*a = *p;
+}
+
+static inline void edosk2674_smsc_insw(
+	volatile unsigned short *a,
+	unsigned short *p,
+	unsigned long l
+	)
+{
+	for (; l != 0; --l, p++)
+		*p = *a;
+}
+
+#endif
diff -Nru linux-2.6.0-test3/include/asm-h8300/generic/machine-depend.h linux-2.6.0-test3-h8300/include/asm-h8300/generic/machine-depend.h
--- linux-2.6.0-test3/include/asm-h8300/generic/machine-depend.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/generic/machine-depend.h	2003-08-22 00:55:15.000000000 +0900
@@ -0,0 +1,17 @@
+/* machine depend header */
+
+/* TIMER rate define */
+#ifdef H8300_TIMER_DEFINE
+#include <linux/config.h>
+#if defined(CONFIG_H83007) || defined(CONFIG_H83068) || defined(CONFIG_H8S2678)
+#define H8300_TIMER_COUNT_DATA CONFIG_CPU_CLOCK*10/8192
+#define H8300_TIMER_FREQ CONFIG_CPU_CLOCK*1000/8192
+#endif
+
+#if defined(CONFIG_H8_3002) || defined(CONFIG_H83048)
+#define H8300_TIMER_COUNT_DATA  CONFIG_CPU_CLOCK*10/8
+#define H8300_TIMER_FREQ CONFIG_CPU_CLOCK*1000/8
+#endif
+
+#endif
+
diff -Nru linux-2.6.0-test3/include/asm-h8300/h8300_ne.h linux-2.6.0-test3-h8300/include/asm-h8300/h8300_ne.h
--- linux-2.6.0-test3/include/asm-h8300/h8300_ne.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/h8300_ne.h	2003-08-22 00:55:15.000000000 +0900
@@ -11,9 +11,9 @@
 #define	h8300ne_h
 /****************************************************************************/
 
-/* Such a description is OK ? */
-#define DEPEND_HEADER(target) <asm/target/ne.h> 
-#include DEPEND_HEADER(TARGET)
+#define H8300_NE_DEFINE
+#include <asm/machine-depend.h>
+#undef  H8300_NE_DEFINE
 
 /****************************************************************************/
 #endif	/* h8300ne_h */
diff -Nru linux-2.6.0-test3/include/asm-h8300/h8max/ide.h linux-2.6.0-test3-h8300/include/asm-h8300/h8max/ide.h
--- linux-2.6.0-test3/include/asm-h8300/h8max/ide.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/h8max/ide.h	1970-01-01 09:00:00.000000000 +0900
@@ -1,60 +0,0 @@
-/* H8MAX IDE I/F Config */
-
-#define H8300_IDE_BASE 0x200000
-#define H8300_IDE_CTRL 0x60000c
-#define H8300_IDE_IRQ  5
-#define H8300_IDE_REG_OFFSET 2
-
-#undef outb
-#undef inb
-#undef outb_p
-#undef inb_p
-#undef outsw
-#undef insw
-
-#define outb(d,a) h8max_outb(d,(unsigned short *)a)
-#define inb(a) h8max_inb((unsigned char *)a)
-#define outb_p(d,a) h8max_outb(d,(unsigned short *)a)
-#define inb_p(a) h8max_inb((unsigned char *)a)
-#define outsw(addr,buf,len) h8max_outsw(addr,buf,len);
-#define insw(addr,buf,len) h8max_insw(addr,buf,len);
-
-static inline void h8max_outb(unsigned short d,unsigned short *a)
-{
-	*a = d;
-}
-
-static inline unsigned char h8max_inb(unsigned char *a)
-{
-	return *(a+1);
-}
-
-static inline void h8max_outsw(void *addr, void *buf, int len)
-{
-	unsigned volatile short *ap = (unsigned volatile short *)addr;
-	unsigned short *bp = (unsigned short *)buf;
-	unsigned short d;
-	while(len--) {
-		d = *bp++;
-		*ap = (d >> 8) | (d << 8);
-	}
-}
-
-static inline void h8max_insw(void *addr, void *buf, int len)
-{
-	unsigned volatile short *ap = (unsigned volatile short *)addr;
-	unsigned short *bp = (unsigned short *)buf;
-	unsigned short d;
-	while(len--) {
-		d = *ap;
-		*bp++ = (d >> 8) | (d << 8);
-	}
-}
-
-static inline void target_ide_fix_driveid(struct hd_driveid *id)
-{
-	int c;
-	unsigned short *p = (unsigned short *)id;
-	for (c = 0; c < SECTOR_WORDS; c++, p++)
-		*p = (*p >> 8) | (*p << 8);
-}
diff -Nru linux-2.6.0-test3/include/asm-h8300/h8max/machine-depend.h linux-2.6.0-test3-h8300/include/asm-h8300/h8max/machine-depend.h
--- linux-2.6.0-test3/include/asm-h8300/h8max/machine-depend.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/h8max/machine-depend.h	2003-08-22 00:55:15.000000000 +0900
@@ -0,0 +1,167 @@
+/* H8MAX board depend header */
+
+/* TIMER rate define */
+#ifdef H8300_TIMER_DEFINE
+#define H8300_TIMER_COUNT_DATA 25000*10/8192
+#define H8300_TIMER_FREQ 25000*1000/8192
+#endif
+
+/* H8MAX RTL8019AS Config */
+#ifdef H8300_NE_DEFINE
+
+#define NE2000_ADDR		0x800600
+#define NE2000_IRQ              4
+#define NE2000_IRQ_VECTOR	(12 + NE2000_IRQ)
+#define	NE2000_BYTE		volatile unsigned short
+
+#define IER                     0xfee015
+#define ISR			0xfee016
+#define IRQ_MASK		(1 << NE2000_IRQ)
+/* sorry quick hack */
+#if defined(outb)
+# undef outb
+#endif
+#define outb(d,a)               h8max_outb((d),(a) - NE2000_ADDR)
+#if defined(inb)
+# undef inb
+#endif
+#define inb(a)                  h8max_inb((a) - NE2000_ADDR)
+#if defined(outb_p)
+# undef outb_p
+#endif
+#define outb_p(d,a)             h8max_outb((d),(a) - NE2000_ADDR)
+#if defined(inb_p)
+# undef inb_p
+#endif
+#define inb_p(a)                h8max_inb((a) - NE2000_ADDR)
+#if defined(outsw)
+# undef outsw
+#endif
+#define outsw(a,p,l)            h8max_outsw((a) - NE2000_ADDR,(unsigned short *)p,l)
+#if defined(insw)
+# undef insw
+#endif
+#define insw(a,p,l)             h8max_insw((a) - NE2000_ADDR,(unsigned short *)p,l)
+#if defined(outsb)
+# undef outsb
+#endif
+#define outsb(a,p,l)            h8max_outsb((a) - NE2000_ADDR,(unsigned char *)p,l)
+#if defined(insb)
+# undef insb
+#endif
+#define insb(a,p,l)             h8max_insb((a) - NE2000_ADDR,(unsigned char *)p,l)
+
+#define H8300_INIT_NE()                  \
+do {                                     \
+	wordlength = 2;                  \
+	h8max_outb(0x49, ioaddr + EN0_DCFG); \
+	SA_prom[14] = SA_prom[15] = 0x57;\
+} while(0)
+
+static inline void h8max_outb(unsigned char d,unsigned char a)
+{
+	*(unsigned short *)(NE2000_ADDR + (a << 1)) = d;
+}
+
+static inline unsigned char h8max_inb(unsigned char a)
+{
+	return *(unsigned char *)(NE2000_ADDR + (a << 1) +1);
+}
+
+static inline void h8max_outsw(unsigned char a,unsigned short *p,unsigned long l)
+{
+	unsigned short d;
+	for (; l != 0; --l, p++) {
+		d = (((*p) >> 8) & 0xff) | ((*p) << 8);
+		*(unsigned short *)(NE2000_ADDR + (a << 1)) = d;
+	}
+}
+
+static inline void h8max_insw(unsigned char a,unsigned short *p,unsigned long l)
+{
+	unsigned short d;
+	for (; l != 0; --l, p++) {
+		d = *(unsigned short *)(NE2000_ADDR + (a << 1));
+		*p = (d << 8)|((d >> 8) & 0xff);
+	}
+}
+
+static inline void h8max_outsb(unsigned char a,unsigned char *p,unsigned long l)
+{
+	for (; l != 0; --l, p++) {
+		*(unsigned short *)(NE2000_ADDR + (a << 1)) = *p;
+	}
+}
+
+static inline void h8max_insb(unsigned char a,unsigned char *p,unsigned long l)
+{
+	for (; l != 0; --l, p++) {
+		*p = *((unsigned char *)(NE2000_ADDR + (a << 1))+1);
+	}
+}
+
+#endif
+
+/* H8MAX IDE I/F Config */
+#ifdef H8300_IDE_DEFINE
+
+#define H8300_IDE_BASE 0x200000
+#define H8300_IDE_CTRL 0x60000c
+#define H8300_IDE_IRQ  5
+#define H8300_IDE_REG_OFFSET 2
+
+#undef outb
+#undef inb
+#undef outb_p
+#undef inb_p
+#undef outsw
+#undef insw
+
+#define outb(d,a) h8max_outb(d,(unsigned short *)a)
+#define inb(a) h8max_inb((unsigned char *)a)
+#define outb_p(d,a) h8max_outb(d,(unsigned short *)a)
+#define inb_p(a) h8max_inb((unsigned char *)a)
+#define outsw(addr,buf,len) h8max_outsw(addr,buf,len);
+#define insw(addr,buf,len) h8max_insw(addr,buf,len);
+
+static inline void h8max_outb(unsigned short d,unsigned short *a)
+{
+	*a = d;
+}
+
+static inline unsigned char h8max_inb(unsigned char *a)
+{
+	return *(a+1);
+}
+
+static inline void h8max_outsw(void *addr, void *buf, int len)
+{
+	unsigned volatile short *ap = (unsigned volatile short *)addr;
+	unsigned short *bp = (unsigned short *)buf;
+	unsigned short d;
+	while(len--) {
+		d = *bp++;
+		*ap = (d >> 8) | (d << 8);
+	}
+}
+
+static inline void h8max_insw(void *addr, void *buf, int len)
+{
+	unsigned volatile short *ap = (unsigned volatile short *)addr;
+	unsigned short *bp = (unsigned short *)buf;
+	unsigned short d;
+	while(len--) {
+		d = *ap;
+		*bp++ = (d >> 8) | (d << 8);
+	}
+}
+
+static inline void target_ide_fix_driveid(struct hd_driveid *id)
+{
+	int c;
+	unsigned short *p = (unsigned short *)id;
+	for (c = 0; c < SECTOR_WORDS; c++, p++)
+		*p = (*p >> 8) | (*p << 8);
+}
+
+#endif
diff -Nru linux-2.6.0-test3/include/asm-h8300/hardirq.h linux-2.6.0-test3-h8300/include/asm-h8300/hardirq.h
--- linux-2.6.0-test3/include/asm-h8300/hardirq.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/hardirq.h	2003-08-22 00:55:15.000000000 +0900
@@ -75,12 +75,6 @@
 #define irq_enter()		(preempt_count() += HARDIRQ_OFFSET)
 
 #ifdef CONFIG_PREEMPT
-# define IRQ_EXIT_OFFSET (HARDIRQ_OFFSET-1)
-#else
-# define IRQ_EXIT_OFFSET HARDIRQ_OFFSET
-#endif
-
-#ifdef CONFIG_PREEMPT
 # define in_atomic()	(preempt_count() != kernel_locked())
 # define IRQ_EXIT_OFFSET (HARDIRQ_OFFSET-1)
 #else
diff -Nru linux-2.6.0-test3/include/asm-h8300/ide.h linux-2.6.0-test3-h8300/include/asm-h8300/ide.h
--- linux-2.6.0-test3/include/asm-h8300/ide.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/ide.h	2003-08-22 00:55:15.000000000 +0900
@@ -70,9 +70,10 @@
  *	Our list of ports/irq's for different boards.
  */
 
-/* Such a description is OK ? */
-#define DEPEND_HEADER(target) <asm/target/ide.h> 
-#include DEPEND_HEADER(TARGET)
+/* machine depend header include */
+#define H8300_IDE_DEFINE
+#include <asm/machine-depend.h>
+#undef  H8300_IDE_DEFINE
 
 /****************************************************************************/
 
diff -Nru linux-2.6.0-test3/include/asm-h8300/io.h linux-2.6.0-test3-h8300/include/asm-h8300/io.h
--- linux-2.6.0-test3/include/asm-h8300/io.h	2003-08-09 20:30:32.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/io.h	2003-08-22 00:55:15.000000000 +0900
@@ -51,21 +51,12 @@
 #define writew(b,addr) (void)((*(volatile unsigned short *) (addr & 0x00ffffff)) = (b))
 #define writel(b,addr) (void)((*(volatile unsigned int *) (addr & 0x00ffffff)) = (b))
 
-/*
- * The following are some defines we need for MTD with our
- * COBRA5272 board.
- * Because I don't know if they break something I have
- * #ifdef'd them.
- * (020325 - hede)
- */
-#ifdef CONFIG_senTec
 #define __raw_readb readb
 #define __raw_readw readw
 #define __raw_readl readl
 #define __raw_writeb writeb
 #define __raw_writew writew
 #define __raw_writel writel
-#endif /* CONFIG_senTec */
 
 static inline void io_outsb(unsigned int addr, void *buf, int len)
 {
diff -Nru linux-2.6.0-test3/include/asm-h8300/machine-depend.h linux-2.6.0-test3-h8300/include/asm-h8300/machine-depend.h
--- linux-2.6.0-test3/include/asm-h8300/machine-depend.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/machine-depend.h	2003-08-22 00:55:15.000000000 +0900
@@ -0,0 +1,70 @@
+/* EDOSK2674 board depend header */
+
+/* TIMER rate define */
+#ifdef H8300_TIMER_DEFINE
+#define H8300_TIMER_COUNT_DATA 33000*10/8192
+#define H8300_TIMER_FREQ 33000*1000/8192
+#endif
+
+/* EDOSK-2674R SMSC Network Controler Target Depend impliments */
+#ifdef H8300_SMSC_DEFINE
+
+#define SMSC_BASE 0xf80000
+#define SMSC_IRQ 16
+
+/* sorry quick hack */
+#if defined(outw)
+# undef outw
+#endif
+#define outw(d,a) edosk2674_smsc_outw(d,(volatile unsigned short *)(a))
+#if defined(inw)
+# undef inw
+#endif
+#define inw(a) edosk2674_smsc_inw((volatile unsigned short *)(a))
+#if defined(outsw)
+# undef outsw
+#endif
+#define outsw(a,p,l) edosk2674_smsc_outsw((volatile unsigned short *)(a),p,l)
+#if defined(insw)
+# undef insw
+#endif
+#define insw(a,p,l) edosk2674_smsc_insw((volatile unsigned short *)(a),p,l)
+
+static inline void edosk2674_smsc_outw(
+	unsigned short d,
+	volatile unsigned short *a
+	)
+{
+	*a = (d >> 8) | (d << 8);
+}
+
+static inline unsigned short edosk2674_smsc_inw(
+	volatile unsigned short *a
+	)
+{
+	unsigned short d;
+	d = *a;
+	return (d >> 8) | (d << 8);
+}
+
+static inline void edosk2674_smsc_outsw(
+	volatile unsigned short *a,
+	unsigned short *p,
+	unsigned long l
+	)
+{
+	for (; l != 0; --l, p++)
+		*a = *p;
+}
+
+static inline void edosk2674_smsc_insw(
+	volatile unsigned short *a,
+	unsigned short *p,
+	unsigned long l
+	)
+{
+	for (; l != 0; --l, p++)
+		*p = *a;
+}
+
+#endif
diff -Nru linux-2.6.0-test3/include/asm-h8300/processor.h linux-2.6.0-test3-h8300/include/asm-h8300/processor.h
--- linux-2.6.0-test3/include/asm-h8300/processor.h	2003-08-09 20:30:32.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/processor.h	2003-08-22 00:55:15.000000000 +0900
@@ -70,12 +70,12 @@
  * pass the data segment into user programs if it exists,
  * it can't hurt anything as far as I can tell
  */
-#if defined(__H8300S__)
+#if defined(__H8300H__)
 #define start_thread(_regs, _pc, _usp)			        \
 do {							        \
 	set_fs(USER_DS);           /* reads from user space */  \
   	(_regs)->pc = (_pc);				        \
-	(_regs)->ccr &= ~0x10;	   /* clear kernel flag */      \
+	(_regs)->ccr &= 0x00;	   /* clear kernel flag */      \
 } while(0)
 #endif
 #if defined(__H8300S__)
@@ -83,7 +83,7 @@
 do {							        \
 	set_fs(USER_DS);           /* reads from user space */  \
 	(_regs)->pc = (_pc);				        \
-	(_regs)->ccr &= ~0x10;	   /* clear kernel flag */      \
+	(_regs)->ccr = 0x00;	   /* clear kernel flag */      \
 	(_regs)->exr = 0x78;       /* enable all interrupts */  \
 	/* 14 = space for retaddr(4), vector(4), er0(4) and ext(2) on stack */ \
 	wrusp(((unsigned long)(_usp)) - 14);                    \
diff -Nru linux-2.6.0-test3/include/asm-h8300/regs267x.h linux-2.6.0-test3-h8300/include/asm-h8300/regs267x.h
--- linux-2.6.0-test3/include/asm-h8300/regs267x.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/regs267x.h	2003-08-22 00:55:15.000000000 +0900
@@ -0,0 +1,336 @@
+/* internal Peripherals Register address define */
+/* CPU: H8/306x                                 */
+
+#if !defined(__REGS_H8S267x__)
+#define __REGS_H8S267x__ 
+
+#if defined(__KERNEL__)
+
+#define DASTCR 0xFEE01A
+#define DADR0  0xFFFFA4
+#define DADR1  0xFFFFA5
+#define DACR01 0xFFFFA6
+#define DADR2  0xFFFFA8
+#define DADR3  0xFFFFA9
+#define DACR23 0xFFFFAA
+
+#define ADDRA  0xFFFF90
+#define ADDRAH 0xFFFF90
+#define ADDRAL 0xFFFF91
+#define ADDRB  0xFFFF92
+#define ADDRBH 0xFFFF92
+#define ADDRBL 0xFFFF93
+#define ADDRC  0xFFFF94
+#define ADDRCH 0xFFFF94
+#define ADDRCL 0xFFFF95
+#define ADDRD  0xFFFF96
+#define ADDRDH 0xFFFF96
+#define ADDRDL 0xFFFF97
+#define ADDRE  0xFFFF98
+#define ADDREH 0xFFFF98
+#define ADDREL 0xFFFF99
+#define ADDRF  0xFFFF9A
+#define ADDRFH 0xFFFF9A
+#define ADDRFL 0xFFFF9B
+#define ADDRG  0xFFFF9C
+#define ADDRGH 0xFFFF9C
+#define ADDRGL 0xFFFF9D
+#define ADDRH  0xFFFF9E
+#define ADDRHH 0xFFFF9E
+#define ADDRHL 0xFFFF9F
+
+#define ADCSR  0xFFFFA0
+#define ADCR   0xFFFFA1
+
+#define ABWCR  0xFFFEC0
+#define ASTCR  0xFFFEC1
+#define WTCRAH 0xFFFEC2
+#define WTCRAL 0xFFFEC3
+#define WTCRBH 0xFFFEC4
+#define WTCRBL 0xFFFEC5
+#define RDNCR  0xFFFEC6
+#define CSACRH 0xFFFEC8
+#define CSACRL 0xFFFEC9
+#define BROMCRH 0xFFFECA
+#define BROMCRL 0xFFFECB
+#define BCR    0xFFFECC
+#define DRAMCR 0xFFFED0
+#define DRACCR 0xFFFED2
+#define REFCR  0xFFFED4
+#define RTCNT  0xFFFED6
+#define RTCOR  0xFFFED7
+
+#define MAR0AH  0xFFFEE0
+#define MAR0AL  0xFFFEE2
+#define IOAR0A  0xFFFEE4
+#define ETCR0A  0xFFFEE6
+#define MAR0BH  0xFFFEE8
+#define MAR0BL  0xFFFEEA
+#define IOAR0B  0xFFFEEC
+#define ETCR0B  0xFFFEEE
+#define MAR1AH  0xFFFEF0
+#define MAR1AL  0xFFFEF2
+#define IOAR1A  0xFFFEF4
+#define ETCR1A  0xFFFEF6
+#define MAR1BH  0xFFFEF8
+#define MAR1BL  0xFFFEFA
+#define IOAR1B  0xFFFEFC
+#define ETCR1B  0xFFFEFE
+#define DMAWER  0xFFFF20
+#define DMATCR  0xFFFF21
+#define DMACR0A 0xFFFF22
+#define DMACR0B 0xFFFF23
+#define DMACR1A 0xFFFF24
+#define DMACR1B 0xFFFF25
+#define DMABCRH 0xFFFF26
+#define DMABCRL 0xFFFF27
+
+#define EDSAR0  0xFFFDC0
+#define EDDAR0  0xFFFDC4
+#define EDTCR0  0xFFFDC8
+#define EDMDR0  0xFFFDCC
+#define EDMDR0H 0xFFFDCC
+#define EDMDR0L 0xFFFDCD
+#define EDACR0  0xFFFDCE
+#define EDSAR1  0xFFFDD0
+#define EDDAR1  0xFFFDD4
+#define EDTCR1  0xFFFDD8
+#define EDMDR1  0xFFFDDC
+#define EDMDR1H 0xFFFDDC
+#define EDMDR1L 0xFFFDDD
+#define EDACR1  0xFFFDDE
+#define EDSAR2  0xFFFDE0
+#define EDDAR2  0xFFFDE4
+#define EDTCR2  0xFFFDE8
+#define EDMDR2  0xFFFDEC
+#define EDMDR2H 0xFFFDEC
+#define EDMDR2L 0xFFFDED
+#define EDACR2  0xFFFDEE
+#define EDSAR3  0xFFFDF0
+#define EDDAR3  0xFFFDF4
+#define EDTCR3  0xFFFDF8
+#define EDMDR3  0xFFFDFC
+#define EDMDR3H 0xFFFDFC
+#define EDMDR3L 0xFFFDFD
+#define EDACR3  0xFFFDFE
+
+#define IPRA  0xFFFE00
+#define IPRB  0xFFFE02
+#define IPRC  0xFFFE04
+#define IPRD  0xFFFE06
+#define IPRE  0xFFFE08
+#define IPRF  0xFFFE0A
+#define IPRG  0xFFFE0C
+#define IPRH  0xFFFE0E
+#define IPRI  0xFFFE10
+#define IPRJ  0xFFFE12
+#define IPRK  0xFFFE14
+#define ITSR  0xFFFE16
+#define SSIER 0xFFFE18
+#define ISCRH 0xFFFE1A
+#define ISCRL 0xFFFE1C
+
+#define INTCR 0xFFFF31
+#define IER   0xFFFF32
+#define IERH  0xFFFF32
+#define IERL  0xFFFF33
+#define ISR   0xFFFF34
+#define ISRH  0xFFFF34
+#define ISRL  0xFFFF35
+
+#define P1DDR 0xFFFE20
+#define P2DDR 0xFFFE21
+#define P3DDR 0xFFFE22
+#define P4DDR 0xFFFE23
+#define P5DDR 0xFFFE24
+#define P6DDR 0xFFFE25
+#define P7DDR 0xFFFE26
+#define P8DDR 0xFFFE27
+#define P9DDR 0xFFFE28
+#define PADDR 0xFFFE29
+#define PBDDR 0xFFFE2A
+#define PCDDR 0xFFFE2B
+#define PDDDR 0xFFFE2C
+#define PEDDR 0xFFFE2D
+#define PFDDR 0xFFFE2E
+#define PGDDR 0xFFFE2F
+#define PHDDR 0xFFFF74
+
+#define PFCR0 0xFFFE32
+#define PFCR1 0xFFFE33
+#define PFCR2 0xFFFE34
+
+#define PAPCR 0xFFFE36
+#define PBPCR 0xFFFE37
+#define PCPCR 0xFFFE38
+#define PDPCR 0xFFFE39
+#define PEPCR 0xFFFE3A
+
+#define P3ODR 0xFFFE3C
+#define PAODR 0xFFFE3D
+
+#define P1DR  0xFFFF60
+#define P2DR  0xFFFF61
+#define P3DR  0xFFFF62
+#define P4DR  0xFFFF63
+#define P5DR  0xFFFF64
+#define P6DR  0xFFFF65
+#define P7DR  0xFFFF66
+#define P8DR  0xFFFF67
+#define P9DR  0xFFFF68
+#define PADR  0xFFFF69
+#define PBDR  0xFFFF6A
+#define PCDR  0xFFFF6B
+#define PDDR  0xFFFF6C
+#define PEDR  0xFFFF6D
+#define PFDR  0xFFFF6E
+#define PGDR  0xFFFF6F
+#define PHDR  0xFFFF72
+
+#define PORT1 0xFFFF50
+#define PORT2 0xFFFF51
+#define PORT3 0xFFFF52
+#define PORT4 0xFFFF53
+#define PORT5 0xFFFF54
+#define PORT6 0xFFFF55
+#define PORT7 0xFFFF56
+#define PORT8 0xFFFF57
+#define PORT9 0xFFFF58
+#define PORTA 0xFFFF59
+#define PORTB 0xFFFF5A
+#define PORTC 0xFFFF5B
+#define PORTD 0xFFFF5C
+#define PORTE 0xFFFF5D
+#define PORTF 0xFFFF5E
+#define PORTG 0xFFFF5F
+#define PORTH 0xFFFF70
+
+#define PCR   0xFFFF46
+#define PMR   0xFFFF47
+#define NDERH 0xFFFF48
+#define NDERL 0xFFFF49
+#define PODRH 0xFFFF4A
+#define PODRL 0xFFFF4B
+#define NDRH1 0xFFFF4C
+#define NDRL1 0xFFFF4D
+#define NDRH2 0xFFFF4E
+#define NDRL2 0xFFFF4F
+
+#define SMR0  0xFFFF78
+#define BRR0  0xFFFF79
+#define SCR0  0xFFFF7A
+#define TDR0  0xFFFF7B
+#define SSR0  0xFFFF7C
+#define RDR0  0xFFFF7D
+#define SCMR0 0xFFFF7E
+#define SMR1  0xFFFF80
+#define BRR1  0xFFFF81
+#define SCR1  0xFFFF82
+#define TDR1  0xFFFF83
+#define SSR1  0xFFFF84
+#define RDR1  0xFFFF85
+#define SCMR1 0xFFFF86
+#define SMR2  0xFFFF88
+#define BRR2  0xFFFF89
+#define SCR2  0xFFFF8A
+#define TDR2  0xFFFF8B
+#define SSR2  0xFFFF8C
+#define RDR2  0xFFFF8D
+#define SCMR2 0xFFFF8E
+
+#define IRCR0 0xFFFE1E
+#define SEMR  0xFFFDA8
+
+#define MDCR    0xFFFF3E
+#define SYSCR   0xFFFF3D
+#define MSTPCRH 0xFFFF40
+#define MSTPCRL 0xFFFF41
+#define FLMCR1  0xFFFFC8
+#define FLMCR2  0xFFFFC9
+#define EBR1    0xFFFFCA
+#define EBR2    0xFFFFCB
+#define CTGARC_RAMCR   0xFFFECE
+#define SBYCR   0xFFFF3A
+#define SCKCR   0xFFFF3B
+#define PLLCR   0xFFFF45
+
+#define TSTR   0xFFFFC0
+#define TSNC   0XFFFFC1
+
+#define TCR0   0xFFFFD0
+#define TMDR0  0xFFFFD1
+#define TIORH0 0xFFFFD2
+#define TIORL0 0xFFFFD3
+#define TIER0  0xFFFFD4
+#define TSR0   0xFFFFD5
+#define TCNT0  0xFFFFD6
+#define GRA0   0xFFFFD8
+#define GRB0   0xFFFFDA
+#define GRC0   0xFFFFDC
+#define GRD0   0xFFFFDE
+#define TCR1   0xFFFFE0
+#define TMDR1  0xFFFFE1
+#define TIORH1 0xFFFFE2
+#define TIORL1 0xFFFFE3
+#define TIER1  0xFFFFE4
+#define TSR1   0xFFFFE5
+#define TCNT1  0xFFFFE6
+#define GRA1   0xFFFFE8
+#define GRB1   0xFFFFEA
+#define TCR2   0xFFFFF0
+#define TMDR2  0xFFFFF1
+#define TIORH2 0xFFFFF2
+#define TIORL2 0xFFFFF3
+#define TIER2  0xFFFFF4
+#define TSR2   0xFFFFF5
+#define TCNT2  0xFFFFF6
+#define GRA2   0xFFFFF8
+#define GRB2   0xFFFFFA
+#define TCR3   0xFFFE80
+#define TMDR3  0xFFFE81
+#define TIORH3 0xFFFE82
+#define TIORL3 0xFFFE83
+#define TIER3  0xFFFE84
+#define TSR3   0xFFFE85
+#define TCNT3  0xFFFE86
+#define GRA3   0xFFFE88
+#define GRB3   0xFFFE8A
+#define GRC3   0xFFFE8C
+#define GRD3   0xFFFE8E
+#define TCR4   0xFFFE90
+#define TMDR4  0xFFFE91
+#define TIORH4 0xFFFE92
+#define TIORL4 0xFFFE93
+#define TIER4  0xFFFE94
+#define TSR4   0xFFFE95
+#define TCNT4  0xFFFE96
+#define GRA4   0xFFFE98
+#define GRB4   0xFFFE9A
+#define TCR5   0xFFFEA0
+#define TMDR5  0xFFFEA1
+#define TIORH5 0xFFFEA2
+#define TIORL5 0xFFFEA3
+#define TIER5  0xFFFEA4
+#define TSR5   0xFFFEA5
+#define TCNT5  0xFFFEA6
+#define GRA5   0xFFFEA8
+#define GRB5   0xFFFEAA
+
+#define _8TCR0   0xFFFFB0
+#define _8TCR1   0xFFFFB1
+#define _8TCSR0  0xFFFFB2
+#define _8TCSR1  0xFFFFB3
+#define _8TCORA0 0xFFFFB4
+#define _8TCORA1 0xFFFFB5
+#define _8TCORB0 0xFFFFB6
+#define _8TCORB1 0xFFFFB7
+#define _8TCNT0  0xFFFFB8
+#define _8TCNT1  0xFFFFB9
+
+#define TCSR    0xFFFFBC
+#define TCNT    0xFFFFBD
+#define RSTCSRW 0xFFFFBE
+#define RSTCSRR 0xFFFFBF
+
+#endif /* __KERNEL__ */
+#endif /* __REGS_H8S267x__ */
diff -Nru linux-2.6.0-test3/include/asm-h8300/semaphore.h linux-2.6.0-test3-h8300/include/asm-h8300/semaphore.h
--- linux-2.6.0-test3/include/asm-h8300/semaphore.h	2003-08-09 20:30:32.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/semaphore.h	2003-08-22 00:55:15.000000000 +0900
@@ -83,7 +83,6 @@
  * "down_failed" is a special asm handler that calls the C
  * routine that actually waits. See arch/m68k/lib/semaphore.S
  */
-#if defined(__H8300H__)
 static inline void down(struct semaphore * sem)
 {
 	register atomic_t *count asm("er0");
@@ -96,9 +95,9 @@
 	__asm__ __volatile__(
 		"stc ccr,r3l\n\t"
 		"orc #0x80,ccr\n\t"
-		"mov.l @%1, er1\n\t"
+		"mov.l %0, er1\n\t"
 		"dec.l #1,er1\n\t"
-		"mov.l er1,@%1\n\t"
+		"mov.l er1,%0\n\t"
 		"bpl 1f\n\t"
 		"ldc r3l,ccr\n\t"
 		"jsr @___down\n\t"
@@ -106,38 +105,11 @@
 		"1:\n\t"
 		"ldc r3l,ccr\n"
 		"2:"
-		: "=m"(sem->count)
-		: "g" (count)
-		: "cc", "er1", "er2", "er3", "er4", "memory");
+		: "+m"(*count)
+		: 
+		: "cc",  "er1", "er2", "er3");
 }
-#endif
-#if defined(__H8300S__)
-static inline void down(struct semaphore * sem)
-{
-	register atomic_t *count asm("er0");
-
-#if WAITQUEUE_DEBUG
-	CHECK_MAGIC(sem->__magic);
-#endif
-
-	count = &(sem->count);
-	__asm__ __volatile__(
-		"stc exr,r3l\n\t"
-		"orc #0x07,exr\n\t"
-		"mov.l @%1, er1\n\t"
-		"dec.l #1,er1\n\t"
-		"mov.l er1,@%1\n\t"
-		"ldc r3l,exr\n\t"
-		"bpl 1f\n\t"
-		"jsr @___down\n"
-		"1:"
-		: "=m"(sem->count)
-		: "r" (count)
-		: "cc", "er1", "er2", "er3", "memory");
-}
-#endif
 
-#if defined(__H8300H__)
 static inline int down_interruptible(struct semaphore * sem)
 {
 	register atomic_t *count asm("er0");
@@ -148,56 +120,25 @@
 
 	count = &(sem->count);
 	__asm__ __volatile__(
-		"stc ccr,r3l\n\t"
+		"stc ccr,r1l\n\t"
 		"orc #0x80,ccr\n\t"
-		"mov.l @%2, er2\n\t"
+		"mov.l %1, er2\n\t"
 		"dec.l #1,er2\n\t"
-		"mov.l er2,@%2\n\t"
+		"mov.l er2,%1\n\t"
 		"bpl 1f\n\t"
-		"ldc r3l,ccr\n\t"
+		"ldc r1l,ccr\n\t"
 		"jsr @___down_interruptible\n\t"
 		"bra 2f\n"
 		"1:\n\t"
-		"ldc r3l,ccr\n\t"
-		"sub.l %0,%0\n"
-		"2:"
-		: "=r" (count),"=m"(sem->count)
-		: "r" (count)
-		: "cc", "er1", "er2", "er3", "memory");
-	return (int)count;
-}
-#endif
-#if defined(__H8300S__)
-static inline int down_interruptible(struct semaphore * sem)
-{
-	register atomic_t *count asm("er0");
-
-#if WAITQUEUE_DEBUG
-	CHECK_MAGIC(sem->__magic);
-#endif
-
-	count = &(sem->count);
-	__asm__ __volatile__(
-		"stc exr,r3l\n\t"
-		"orc #0x07,exr\n\t"
-		"mov.l @%2, er2\n\t"
-		"dec.l #1,er2\n\t"
-		"mov.l er2,@%2\n\t"
-		"ldc r3l,exr\n\t"
-		"bmi 1f\n\t"
+		"ldc r1l,ccr\n\t"
 		"sub.l %0,%0\n\t"
-		"bra 2f\n"
-		"1:\n\t"
-		"jsr @___down_interruptible\n"
-		"2:"
-		: "=r" (count),"=m"(sem->count)
-		: "r" (count)
-		: "cc", "er1", "er2", "er3", "memory");
+		"2:\n\t"
+		: "=r" (count),"+m" (*count)
+		:
+		: "cc", "er1", "er2", "er3");
 	return (int)count;
 }
-#endif
 
-#if defined(__H8300H__)
 static inline int down_trylock(struct semaphore * sem)
 {
 	register atomic_t *count asm("er0");
@@ -210,60 +151,26 @@
 	__asm__ __volatile__(
 		"stc ccr,r3l\n\t"
 		"orc #0x80,ccr\n\t"
-		"mov.l @%2,er2\n\t"
+		"mov.l %0,er2\n\t"
 		"dec.l #1,er2\n\t"
-		"mov.l er2,@%2\n\t"
+		"mov.l er2,%0\n\t"
 		"bpl 1f\n\t"
 		"ldc r3l,ccr\n\t"
-		"jmp @3f\n"
-		"1:\n\t"
-		"ldc r3l,ccr\n\t"
-		"sub.l %0,%0\n"
+		"jmp @3f\n\t"
 		LOCK_SECTION_START(".align 2\n\t")
 		"3:\n\t"
 		"jsr @___down_trylock\n\t"
 		"jmp @2f\n\t"
 		LOCK_SECTION_END
-		"2:"
-		: "=r" (count),"=m"(sem->count)
-		: "r" (count)
-		: "cc", "er2", "er3", "memory");
-	return (int)count;
-}
-#endif
-#if defined(__H8300S__)
-static inline int down_trylock(struct semaphore * sem)
-{
-	register atomic_t *count asm("er0");
-
-#if WAITQUEUE_DEBUG
-	CHECK_MAGIC(sem->__magic);
-#endif
-
-	count = &(sem->count);
-	__asm__ __volatile__(
-		"stc exr,r3l\n\t"
-		"orc #0x07,exr\n\t"
-		"mov.l @%2,er2\n\t"
-		"dec.l #1,er2\n\t"
-		"mov.l er2,@%2\n\t"
-		"ldc r3l,exr\n\t"
-		"bpl 1f\n\t"
-		"jmp @3f\n"
 		"1:\n\t"
-		"sub.l %0,%0\n\t"
-		LOCK_SECTION_START(".align 2\n\t")
-		"3:\n\t"
-		"jsr @___down_trylock\n\t"
-		"jmp @2f\n\t"
-		LOCK_SECTION_END
-		"2:\n\t"
-		: "=r" (count),"=m"(sem->count)
-		: "r" (count)
-		: "cc", "er1", "er2", "er3", "memory");
+		"ldc r3l,ccr\n\t"
+		"sub.l %1,%1\n"
+		"2:"
+		: "+m" (*count),"=r"(count)
+		: 
+		: "cc", "er1","er2", "er3");
 	return (int)count;
 }
-#endif
 
 /*
  * Note! This is subtle. We jump to wake people up only if
@@ -271,7 +178,6 @@
  * The default case (no contention) will result in NO
  * jumps for both down() and up().
  */
-#if defined(__H8300H__)
 static inline void up(struct semaphore * sem)
 {
 	register atomic_t *count asm("er0");
@@ -284,47 +190,19 @@
 	__asm__ __volatile__(
 		"stc ccr,r3l\n\t"
 		"orc #0x80,ccr\n\t"
-		"mov.l @%1,er1\n\t"
+		"mov.l %0,er1\n\t"
 		"inc.l #1,er1\n\t"
-		"mov.l er1,@%1\n\t"
+		"mov.l er1,%0\n\t"
 		"ldc r3l,ccr\n\t"
 		"sub.l er2,er2\n\t"
 		"cmp.l er2,er1\n\t"
 		"bgt 1f\n\t"
 		"jsr @___up\n"
 		"1:"
-		: "=m"(sem->count)
-		: "r" (count)
-		: "cc", "er1", "er2", "er3", "memory");
+		: "+m"(*count)
+		: 
+		: "cc", "er1", "er2", "er3");
 }
-#endif
-#if defined(__H8300S__)
-static inline void up(struct semaphore * sem)
-{
-	register atomic_t *count asm("er0");
-
-#if WAITQUEUE_DEBUG
-	CHECK_MAGIC(sem->__magic);
-#endif
-
-	count = &(sem->count);
-	__asm__ __volatile__(
-		"stc exr,r3l\n\t"
-		"orc #0x07,exr\n\t"
-		"mov.l @%1,er1\n\t"
-		"inc.l #1,er1\n\t"
-		"mov.l er1,@%1\n\t"
-		"ldc r3l,exr\n\t"
-		"sub.l er2,er2\n\t"
-		"cmp.l er2,er1\n\t"
-		"bgt 1f\n\t"
-		"jsr @___up\n"
-		"1:"
-		: "=m"(sem->count)
-		: "r" (count)
-		: "cc", "er1", "er2", "er3", "memory");
-}
-#endif
 
 #endif /* __ASSEMBLY__ */
 
diff -Nru linux-2.6.0-test3/include/asm-h8300/system.h linux-2.6.0-test3-h8300/include/asm-h8300/system.h
--- linux-2.6.0-test3/include/asm-h8300/system.h	2003-08-09 20:30:32.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/system.h	2003-08-22 00:55:15.000000000 +0900
@@ -35,6 +35,7 @@
  *
  * H8/300 Porting 2002/09/04 Yoshinori Sato
  */
+
 asmlinkage void resume(void);
 #define switch_to(prev,next,last) {                         \
   void *_last;						    \
@@ -52,7 +53,6 @@
   (last) = _last; 					    \
 }
 
-#if defined(__H8300H__)
 #define __sti() asm volatile ("andc #0x7f,ccr")
 #define __cli() asm volatile ("orc  #0x80,ccr")
 
@@ -69,25 +69,6 @@
 	((flags & 0x80) == 0x80);	\
 })
 
-#endif
-#if defined(__H8300S__)
-#define __sti() asm volatile ("andc #0xf8,exr")
-#define __cli() asm volatile ("orc  #0x07,exr")
-
-#define __save_flags(x) \
-       asm volatile ("stc exr,r0l\n\tmov.l er0,%0":"=r" (x) : : "er0")
-
-#define __restore_flags(x) \
-       asm volatile ("mov.l %0,er0\n\tldc r0l,exr": :"r" (x) : "er0")
-#endif
-
-#define	irqs_disabled()			\
-({					\
-	unsigned long flags;		\
-	__save_flags(flags);	        \
-	((flags & 0x07) == 0x07);	\
-})
-
 #define iret() __asm__ __volatile__ ("rte": : :"memory", "sp", "cc")
 
 /* For spinlocks etc */
diff -Nru linux-2.6.0-test3/include/asm-h8300/timex.h linux-2.6.0-test3-h8300/include/asm-h8300/timex.h
--- linux-2.6.0-test3/include/asm-h8300/timex.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test3-h8300/include/asm-h8300/timex.h	2003-08-22 00:55:15.000000000 +0900
@@ -6,9 +6,9 @@
 #ifndef _ASM_H8300_TIMEX_H
 #define _ASM_H8300_TIMEX_H
 
-/* Such a description is OK ? */
-#define TIMEX_DEPEND_HEADER(target) <asm/target/timer_rate.h> 
-#include TIMEX_DEPEND_HEADER(TARGET)
+#define H8300_TIMER_DEFINE
+#include <asm/machine-depend.h>
+#undef  H8300_TIMER_DEFINE
 
 #define CLOCK_TICK_RATE H8300_TIMER_FREQ
 #define CLOCK_TICK_FACTOR	20	/* Factor of both 1000000 and CLOCK_TICK_RATE */
