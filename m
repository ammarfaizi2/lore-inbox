Return-Path: <linux-kernel-owner@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id <S286519AbRLUBj2>; Thu, 20 Dec 2001 20:39:28 -0500
Received: (majordomo@vger.kernel.org) by vger.kernel.org
	id <S286518AbRLUBjI>; Thu, 20 Dec 2001 20:39:08 -0500
Received: from fgwmail6.fujitsu.co.jp ([192.51.44.36]:22163 "EHLO
	fgwmail6.fujitsu.co.jp") by vger.kernel.org with ESMTP
	id <S286513AbRLUBjH>; Thu, 20 Dec 2001 20:39:07 -0500
Date: Fri, 21 Dec 2001 10:38:54 +0900
Message-ID: <4rmlxsgh.wl@nisaaru.dvs.cs.fujitsu.co.jp>
From: Tachino Nobuhiro <tachino@open.nm.fujitsu.co.jp>
To: torvalds@transmeta.com
Cc: torrey.hoffman@myrio.com, linux-kernel@vger.kernel.org, viro@math.psu.edu,
        marcelo@conectiva.com.br, tachino@open.nm.fujitsu.co.jp
Subject: Re: ramdisk corruption problems - was: RE: pivot_root and initrd 	kern el panic woes
Newsgroups: linux.dev.kernel
In-Reply-To: <200112201946.fBKJkNw01262@penguin.transmeta.com>
In-Reply-To: <D52B19A7284D32459CF20D579C4B0C0211CB0F@mail0.myrio.com>
	<200112201946.fBKJkNw01262@penguin.transmeta.com>
User-Agent: Wanderlust/2.7.6 (Too Funky) EMIKO/1.14.1 (Choanoflagellata) LIMIT/1.14.7 (Fujiidera) APEL/10.3 Emacs/21.1 (i586-kondara-linux-gnu) MULE/5.0 (SAKAKI)
MIME-Version: 1.0 (generated by EMIKO 1.14.1 - "Choanoflagellata")
Content-Type: text/plain; charset=US-ASCII
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org


At Thu, 20 Dec 2001 11:46:23 -0800,
Linus Torvalds wrote:
> 
> The problem is that having buffers doesn't necessarily always mean that
> they are valid, nor that _all_ of them are valid.

  If following sequence occurs, ramdisk_readpage() may clear the valid buffer
data. I'm not sure whether this really occurs, but if it does,
I think lock_buffer()/unlock_buffer() may be required.


	CPU1					CPU2
---------------------------------------------------------------------------
	call ext2_alloc_branch()		call ramdisk_readpage()

	bh = getblk();
	lock_buffer(bh);

	write data to bh.
						ramdisk_readpage()
						if (!buffer_uptodate(bh))
							do memset()

	mark_buffer_uptodate()
	unlock_buffer(bh);
