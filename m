Return-Path: <linux-kernel-owner+willy=40w.ods.org-S268420AbUIGSkh@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S268420AbUIGSkh (ORCPT <rfc822;willy@w.ods.org>);
	Tue, 7 Sep 2004 14:40:37 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S268407AbUIGSjM
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Tue, 7 Sep 2004 14:39:12 -0400
Received: from mx1.redhat.com ([66.187.233.31]:39555 "EHLO mx1.redhat.com")
	by vger.kernel.org with ESMTP id S268392AbUIGSaT (ORCPT
	<rfc822;linux-kernel@vger.kernel.org>);
	Tue, 7 Sep 2004 14:30:19 -0400
From: David Howells <dhowells@redhat.com>
In-Reply-To: <413DED11.5030700@myrealbox.com>
References: <413DED11.5030700@myrealbox.com>  <20040907033255.78128ebd.akpm@osdl.org> <20040907031856.58f33b99.akpm@osdl.org> <20040904032913.441631e6.akpm@osdl.org> <20040904022656.31447b51.akpm@osdl.org> <20040903224513.0154c1d3.akpm@osdl.org> <24752.1094234169@redhat.com> <12766.1094289316@redhat.com> <14279.1094293508@redhat.com> <13781.1094551789@redhat.com> <14622.1094552807@redhat.com> <22970.1094563283@redhat.com>
To: Andy Lutomirski <luto@myrealbox.com>
Cc: linux-kernel@vger.kernel.org
Subject: Re: Where's the key management patchset at?
User-Agent: EMH/1.14.1 SEMI/1.14.5 (Awara-Onsen) FLIM/1.14.5 (Demachiyanagi) APEL/10.6 Emacs/21.3 (i386-redhat-linux-gnu) MULE/5.0 (SAKAKI)
MIME-Version: 1.0 (generated by SEMI 1.14.5 - "Awara-Onsen")
Content-Type: text/plain; charset=US-ASCII
Date: Tue, 07 Sep 2004 19:30:10 +0100
Message-ID: <13082.1094581810@redhat.com>
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org


> First, I can't find the patch.
> http://people.redhat.com/~dhowells/keys/keys-268rc4mm1.diff seems to be
> a diff between two diff between two different versions of the key stuff.

My patches are currently residing in Andrew Morton's kernel, so if you grab
his 2.6.9-rc1-mm4 patch you'll find them there. Look in:

ftp://ftp.kernel.org/pub/linux/kernel/people/akpm/patches/2.6/2.6.9-rc1/2.6.9-rc1-mm4/

The patch includes documentation in Documentation/keys.txt.

> Second, is there a way for a process/user to have "use but not read"
> access so it could pass the key to a different _userspace_ process
> (probably a daemon running as root) that wants to read it?  This would
> be nice for all kinds of things (like ssh agents and such).

That depends on what you mean by "use but not read" access.

Keys now have five permissions (View, Link, Write, Read, Search) and these can
be applied to user, group or other.

An in-kernel service just requires Search (Use) permission to be able to use a
key. It calls request_key() to come up with a key from the process's keyrings
or from userspace.

"Using" a key from userspace is tricky. We want to stop random processes from
reading your keys if they don't have Read permission, but it might be
necessary to _read_ the key to make use of it:-/

Although userspace could find a key given that that's governed by Search
permission it can't necessarily read it. I've added in a "bypass" so that if a
key is Searchable from one of a userspace process's process keyrings then it's
allowed to read it, even if it doesn't have Read permission. This allows keys
to be added through to SUID programs - you create your keyrings and your key
with Search permission and the SUID programs can then access them in
userspace.

I haven't yet created a method for one process to hand a key to another, short
of linking the key directly into one of the target process's keyrings.

I'll probably have to do it by passing a new type of SCM message over AF_UNIX
sockets - one that attaches a key and can drop it into the process's thread
keyring.

I may also need to follow up on Kyle Moffett's suggestion and make a
distinction between a key and its handle:

	  HANDLE                        KEY

	+---------+
	| Serial# |
	| UID/GID |--------+
	|  Perm   |        |
	+---------+        |
			   |	     +----------+
	+---------+	   |	     | Owner   	|
	| Serial# |	   +-------->| Type  	|
	| UID/GID |----------------->| Desc 	|
	|  Perm   |	   +-------->| Payload	|
	+---------+	   |   	     | 	      	|
			   |	     +----------+
	+---------+	   |
	| Serial# |	   |
	| UID/GID |--------+
	|  Perm   |
	+---------+

Handles would then be clonable and individually revokable, giving the
opportunity to create handles for specific purposes, possibly even
"personalised" for specific processes rather than UID/GID. I'd then add a
"Clone" permission to the permissions mask.

The "number of keys" quota value would then count handles instead.

I've tried to implement this once before... it adds quite a bit of complexity
to the code, and makes locking interesting in places.

David
