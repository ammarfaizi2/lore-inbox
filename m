Return-Path: <linux-kernel-owner+willy=40w.ods.org-S964820AbWCTPWb@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S964820AbWCTPWb (ORCPT <rfc822;willy@w.ods.org>);
	Mon, 20 Mar 2006 10:22:31 -0500
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S964845AbWCTPW0
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Mon, 20 Mar 2006 10:22:26 -0500
Received: from pentafluge.infradead.org ([213.146.154.40]:51682 "EHLO
	pentafluge.infradead.org") by vger.kernel.org with ESMTP
	id S965270AbWCTPWO (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
	Mon, 20 Mar 2006 10:22:14 -0500
From: mchehab@infradead.org
To: linux-kernel@vger.kernel.org
Cc: linux-dvb-maintainer@linuxtv.org, Adrian Bunk <bunk@stusta.de>,
       Mauro Carvalho Chehab <mchehab@infradead.org>
Subject: [PATCH 072/141] V4L/DVB (3318e): DVB: remove the at76c651/tda80xx
	frontends
Date: Mon, 20 Mar 2006 12:08:49 -0300
Message-id: <20060320150849.PS036907000072@infradead.org>
In-Reply-To: <20060320150819.PS760228000000@infradead.org>
References: <20060320150819.PS760228000000@infradead.org>
Mime-Version: 1.0
X-Mailer: Evolution 2.4.2.1-3mdk 
Content-Transfer-Encoding: 7bit
X-Bad-Reply: References and In-Reply-To but no 'Re:' in Subject.
X-SRS-Rewrite: SMTP reverse-path rewritten from <mchehab@infradead.org> by pentafluge.infradead.org
	See http://www.infradead.org/rpr.html
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

From: Adrian Bunk <bunk@stusta.de>
Date: 1139302155 -0200

The at76c651 and tda80xx frontends are currently completely unused, IOW
their only effect is making the kernel larger for people accitentially
enabling them.

The current in-kernel drivers differ from the drivers at cvs.tuxbox.org,
and re-adding them when parts of the dbox2 project get merged should be
trivial.


Signed-off-by: Adrian Bunk <bunk@stusta.de>
Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>
---

diff --git a/drivers/media/dvb/frontends/Kconfig b/drivers/media/dvb/frontends/Kconfig
diff --git a/drivers/media/dvb/frontends/Kconfig b/drivers/media/dvb/frontends/Kconfig
index f09e3da..76b6a2a 100644
--- a/drivers/media/dvb/frontends/Kconfig
+++ b/drivers/media/dvb/frontends/Kconfig
@@ -28,12 +28,6 @@ config DVB_TDA8083
 	help
 	  A DVB-S tuner module. Say Y when you want to support this frontend.
 
-config DVB_TDA80XX
-	tristate "Philips TDA8044 or TDA8083 based"
-	depends on DVB_CORE
-	help
-	  A DVB-S tuner module. Say Y when you want to support this frontend.
-
 config DVB_MT312
 	tristate "Zarlink MT312 based"
 	depends on DVB_CORE
@@ -139,12 +133,6 @@ config DVB_DIB3000MC
 comment "DVB-C (cable) frontends"
 	depends on DVB_CORE
 
-config DVB_ATMEL_AT76C651
-	tristate "Atmel AT76C651 based"
-	depends on DVB_CORE
-	help
-	  A DVB-C tuner module. Say Y when you want to support this frontend.
-
 config DVB_VES1820
 	tristate "VLSI VES1820 based"
 	depends on DVB_CORE
diff --git a/drivers/media/dvb/frontends/Makefile b/drivers/media/dvb/frontends/Makefile
diff --git a/drivers/media/dvb/frontends/Makefile b/drivers/media/dvb/frontends/Makefile
index 8f30146..1af769c 100644
--- a/drivers/media/dvb/frontends/Makefile
+++ b/drivers/media/dvb/frontends/Makefile
@@ -8,7 +8,6 @@ obj-$(CONFIG_DVB_CORE) += dvb-pll.o
 obj-$(CONFIG_DVB_STV0299) += stv0299.o
 obj-$(CONFIG_DVB_SP8870) += sp8870.o
 obj-$(CONFIG_DVB_CX22700) += cx22700.o
-obj-$(CONFIG_DVB_ATMEL_AT76C651) += at76c651.o
 obj-$(CONFIG_DVB_CX24110) += cx24110.o
 obj-$(CONFIG_DVB_TDA8083) += tda8083.o
 obj-$(CONFIG_DVB_L64781) += l64781.o
@@ -22,7 +21,6 @@ obj-$(CONFIG_DVB_SP887X) += sp887x.o
 obj-$(CONFIG_DVB_NXT6000) += nxt6000.o
 obj-$(CONFIG_DVB_MT352) += mt352.o
 obj-$(CONFIG_DVB_CX22702) += cx22702.o
-obj-$(CONFIG_DVB_TDA80XX) += tda80xx.o
 obj-$(CONFIG_DVB_TDA10021) += tda10021.o
 obj-$(CONFIG_DVB_STV0297) += stv0297.o
 obj-$(CONFIG_DVB_NXT200X) += nxt200x.o
diff --git a/drivers/media/dvb/frontends/at76c651.c b/drivers/media/dvb/frontends/at76c651.c
diff --git a/drivers/media/dvb/frontends/at76c651.c b/drivers/media/dvb/frontends/at76c651.c
deleted file mode 100644
index 8e0f4b3..0000000
--- a/drivers/media/dvb/frontends/at76c651.c
+++ /dev/null
@@ -1,450 +0,0 @@
-/*
- * at76c651.c
- *
- * Atmel DVB-C Frontend Driver (at76c651/tua6010xs)
- *
- * Copyright (C) 2001 fnbrd <fnbrd@gmx.de>
- *             & 2002-2004 Andreas Oberritter <obi@linuxtv.org>
- *             & 2003 Wolfram Joost <dbox2@frokaschwei.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- * AT76C651
- * http://www.nalanda.nitc.ac.in/industry/datasheets/atmel/acrobat/doc1293.pdf
- * http://www.atmel.com/atmel/acrobat/doc1320.pdf
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/bitops.h>
-#include "dvb_frontend.h"
-#include "at76c651.h"
-
-
-struct at76c651_state {
-
-	struct i2c_adapter* i2c;
-
-	struct dvb_frontend_ops ops;
-
-	const struct at76c651_config* config;
-
-	struct dvb_frontend frontend;
-
-	/* revision of the chip */
-	u8 revision;
-
-	/* last QAM value set */
-	u8 qam;
-};
-
-static int debug;
-#define dprintk(args...) \
-	do { \
-		if (debug) printk(KERN_DEBUG "at76c651: " args); \
-	} while (0)
-
-
-#if ! defined(__powerpc__)
-static __inline__ int __ilog2(unsigned long x)
-{
-	int i;
-
-	if (x == 0)
-		return -1;
-
-	for (i = 0; x != 0; i++)
-		x >>= 1;
-
-	return i - 1;
-}
-#endif
-
-static int at76c651_writereg(struct at76c651_state* state, u8 reg, u8 data)
-{
-	int ret;
-	u8 buf[] = { reg, data };
-	struct i2c_msg msg =
-		{ .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };
-
-	ret = i2c_transfer(state->i2c, &msg, 1);
-
-	if (ret != 1)
-		dprintk("%s: writereg error "
-			"(reg == 0x%02x, val == 0x%02x, ret == %i)\n",
-			__FUNCTION__, reg, data, ret);
-
-	msleep(10);
-
-	return (ret != 1) ? -EREMOTEIO : 0;
-}
-
-static u8 at76c651_readreg(struct at76c651_state* state, u8 reg)
-{
-	int ret;
-	u8 val;
-	struct i2c_msg msg[] = {
-		{ .addr = state->config->demod_address, .flags = 0, .buf = &reg, .len = 1 },
-		{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = &val, .len = 1 }
-	};
-
-	ret = i2c_transfer(state->i2c, msg, 2);
-
-	if (ret != 2)
-		dprintk("%s: readreg error (ret == %i)\n", __FUNCTION__, ret);
-
-	return val;
-}
-
-static int at76c651_reset(struct at76c651_state* state)
-{
-	return at76c651_writereg(state, 0x07, 0x01);
-}
-
-static void at76c651_disable_interrupts(struct at76c651_state* state)
-{
-	at76c651_writereg(state, 0x0b, 0x00);
-}
-
-static int at76c651_set_auto_config(struct at76c651_state *state)
-{
-	/*
-	 * Autoconfig
-	 */
-
-	at76c651_writereg(state, 0x06, 0x01);
-
-	/*
-	 * Performance optimizations, should be done after autoconfig
-	 */
-
-	at76c651_writereg(state, 0x10, 0x06);
-	at76c651_writereg(state, 0x11, ((state->qam == 5) || (state->qam == 7)) ? 0x12 : 0x10);
-	at76c651_writereg(state, 0x15, 0x28);
-	at76c651_writereg(state, 0x20, 0x09);
-	at76c651_writereg(state, 0x24, ((state->qam == 5) || (state->qam == 7)) ? 0xC0 : 0x90);
-	at76c651_writereg(state, 0x30, 0x90);
-	if (state->qam == 5)
-		at76c651_writereg(state, 0x35, 0x2A);
-
-	/*
-	 * Initialize A/D-converter
-	 */
-
-	if (state->revision == 0x11) {
-		at76c651_writereg(state, 0x2E, 0x38);
-		at76c651_writereg(state, 0x2F, 0x13);
-	}
-
-	at76c651_disable_interrupts(state);
-
-	/*
-	 * Restart operation
-	 */
-
-	at76c651_reset(state);
-
-	return 0;
-}
-
-static void at76c651_set_bbfreq(struct at76c651_state* state)
-{
-	at76c651_writereg(state, 0x04, 0x3f);
-	at76c651_writereg(state, 0x05, 0xee);
-}
-
-static int at76c651_set_symbol_rate(struct at76c651_state* state, u32 symbol_rate)
-{
-	u8 exponent;
-	u32 mantissa;
-
-	if (symbol_rate > 9360000)
-		return -EINVAL;
-
-	/*
-	 * FREF = 57800 kHz
-	 * exponent = 10 + floor (log2(symbol_rate / FREF))
-	 * mantissa = (symbol_rate / FREF) * (1 << (30 - exponent))
-	 */
-
-	exponent = __ilog2((symbol_rate << 4) / 903125);
-	mantissa = ((symbol_rate / 3125) * (1 << (24 - exponent))) / 289;
-
-	at76c651_writereg(state, 0x00, mantissa >> 13);
-	at76c651_writereg(state, 0x01, mantissa >> 5);
-	at76c651_writereg(state, 0x02, (mantissa << 3) | exponent);
-
-	return 0;
-}
-
-static int at76c651_set_qam(struct at76c651_state *state, fe_modulation_t qam)
-{
-	switch (qam) {
-	case QPSK:
-		state->qam = 0x02;
-		break;
-	case QAM_16:
-		state->qam = 0x04;
-		break;
-	case QAM_32:
-		state->qam = 0x05;
-		break;
-	case QAM_64:
-		state->qam = 0x06;
-		break;
-	case QAM_128:
-		state->qam = 0x07;
-		break;
-	case QAM_256:
-		state->qam = 0x08;
-		break;
-#if 0
-	case QAM_512:
-		state->qam = 0x09;
-		break;
-	case QAM_1024:
-		state->qam = 0x0A;
-		break;
-#endif
-	default:
-		return -EINVAL;
-
-	}
-
-	return at76c651_writereg(state, 0x03, state->qam);
-}
-
-static int at76c651_set_inversion(struct at76c651_state* state, fe_spectral_inversion_t inversion)
-{
-	u8 feciqinv = at76c651_readreg(state, 0x60);
-
-	switch (inversion) {
-	case INVERSION_OFF:
-		feciqinv |= 0x02;
-		feciqinv &= 0xFE;
-		break;
-
-	case INVERSION_ON:
-		feciqinv |= 0x03;
-		break;
-
-	case INVERSION_AUTO:
-		feciqinv &= 0xFC;
-		break;
-
-	default:
-		return -EINVAL;
-	}
-
-	return at76c651_writereg(state, 0x60, feciqinv);
-}
-
-static int at76c651_set_parameters(struct dvb_frontend* fe,
-				   struct dvb_frontend_parameters *p)
-{
-	int ret;
-	struct at76c651_state* state = fe->demodulator_priv;
-
-	at76c651_writereg(state, 0x0c, 0xc3);
-	state->config->pll_set(fe, p);
-	at76c651_writereg(state, 0x0c, 0xc2);
-
-	if ((ret = at76c651_set_symbol_rate(state, p->u.qam.symbol_rate)))
-		return ret;
-
-	if ((ret = at76c651_set_inversion(state, p->inversion)))
-		return ret;
-
-	return at76c651_set_auto_config(state);
-}
-
-static int at76c651_set_defaults(struct dvb_frontend* fe)
-{
-	struct at76c651_state* state = fe->demodulator_priv;
-
-	at76c651_set_symbol_rate(state, 6900000);
-	at76c651_set_qam(state, QAM_64);
-	at76c651_set_bbfreq(state);
-	at76c651_set_auto_config(state);
-
-	if (state->config->pll_init) {
-		at76c651_writereg(state, 0x0c, 0xc3);
-		state->config->pll_init(fe);
-		at76c651_writereg(state, 0x0c, 0xc2);
-	}
-
-	return 0;
-}
-
-static int at76c651_read_status(struct dvb_frontend* fe, fe_status_t* status)
-{
-	struct at76c651_state* state = fe->demodulator_priv;
-	u8 sync;
-
-	/*
-	 * Bits: FEC, CAR, EQU, TIM, AGC2, AGC1, ADC, PLL (PLL=0)
-	 */
-	sync = at76c651_readreg(state, 0x80);
-	*status = 0;
-
-	if (sync & (0x04 | 0x10))	/* AGC1 || TIM */
-		*status |= FE_HAS_SIGNAL;
-	if (sync & 0x10)		/* TIM */
-		*status |= FE_HAS_CARRIER;
-	if (sync & 0x80)		/* FEC */
-		*status |= FE_HAS_VITERBI;
-	if (sync & 0x40)		/* CAR */
-		*status |= FE_HAS_SYNC;
-	if ((sync & 0xF0) == 0xF0)	/* TIM && EQU && CAR && FEC */
-		*status |= FE_HAS_LOCK;
-
-	return 0;
-}
-
-static int at76c651_read_ber(struct dvb_frontend* fe, u32* ber)
-{
-	struct at76c651_state* state = fe->demodulator_priv;
-
-	*ber = (at76c651_readreg(state, 0x81) & 0x0F) << 16;
-	*ber |= at76c651_readreg(state, 0x82) << 8;
-	*ber |= at76c651_readreg(state, 0x83);
-	*ber *= 10;
-
-	return 0;
-}
-
-static int at76c651_read_signal_strength(struct dvb_frontend* fe, u16* strength)
-{
-	struct at76c651_state* state = fe->demodulator_priv;
-
-	u8 gain = ~at76c651_readreg(state, 0x91);
-	*strength = (gain << 8) | gain;
-
-	return 0;
-}
-
-static int at76c651_read_snr(struct dvb_frontend* fe, u16* snr)
-{
-	struct at76c651_state* state = fe->demodulator_priv;
-
-	*snr = 0xFFFF -
-	    ((at76c651_readreg(state, 0x8F) << 8) |
-	     at76c651_readreg(state, 0x90));
-
-	return 0;
-}
-
-static int at76c651_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)
-{
-	struct at76c651_state* state = fe->demodulator_priv;
-
-	*ucblocks = at76c651_readreg(state, 0x82);
-
-	return 0;
-}
-
-static int at76c651_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *fesettings)
-{
-	fesettings->min_delay_ms = 50;
-	fesettings->step_size = 0;
-	fesettings->max_drift = 0;
-	return 0;
-}
-
-static void at76c651_release(struct dvb_frontend* fe)
-{
-	struct at76c651_state* state = fe->demodulator_priv;
-	kfree(state);
-}
-
-static struct dvb_frontend_ops at76c651_ops;
-
-struct dvb_frontend* at76c651_attach(const struct at76c651_config* config,
-				     struct i2c_adapter* i2c)
-{
-	struct at76c651_state* state = NULL;
-
-	/* allocate memory for the internal state */
-	state = kmalloc(sizeof(struct at76c651_state), GFP_KERNEL);
-	if (state == NULL) goto error;
-
-	/* setup the state */
-	state->config = config;
-	state->qam = 0;
-
-	/* check if the demod is there */
-	if (at76c651_readreg(state, 0x0e) != 0x65) goto error;
-
-	/* finalise state setup */
-	state->i2c = i2c;
-	state->revision = at76c651_readreg(state, 0x0f) & 0xfe;
-	memcpy(&state->ops, &at76c651_ops, sizeof(struct dvb_frontend_ops));
-
-	/* create dvb_frontend */
-	state->frontend.ops = &state->ops;
-	state->frontend.demodulator_priv = state;
-	return &state->frontend;
-
-error:
-	kfree(state);
-	return NULL;
-}
-
-static struct dvb_frontend_ops at76c651_ops = {
-
-	.info = {
-		.name = "Atmel AT76C651B DVB-C",
-		.type = FE_QAM,
-		.frequency_min = 48250000,
-		.frequency_max = 863250000,
-		.frequency_stepsize = 62500,
-		/*.frequency_tolerance = */	/* FIXME: 12% of SR */
-		.symbol_rate_min = 0,		/* FIXME */
-		.symbol_rate_max = 9360000,	/* FIXME */
-		.symbol_rate_tolerance = 4000,
-		.caps = FE_CAN_INVERSION_AUTO |
-		    FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
-		    FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
-		    FE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |
-		    FE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 | FE_CAN_QAM_128 |
-		    FE_CAN_MUTE_TS | FE_CAN_QAM_256 | FE_CAN_RECOVER
-	},
-
-	.release = at76c651_release,
-
-	.init = at76c651_set_defaults,
-
-	.set_frontend = at76c651_set_parameters,
-	.get_tune_settings = at76c651_get_tune_settings,
-
-	.read_status = at76c651_read_status,
-	.read_ber = at76c651_read_ber,
-	.read_signal_strength = at76c651_read_signal_strength,
-	.read_snr = at76c651_read_snr,
-	.read_ucblocks = at76c651_read_ucblocks,
-};
-
-module_param(debug, int, 0644);
-MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
-
-MODULE_DESCRIPTION("Atmel AT76C651 DVB-C Demodulator Driver");
-MODULE_AUTHOR("Andreas Oberritter <obi@linuxtv.org>");
-MODULE_LICENSE("GPL");
-
-EXPORT_SYMBOL(at76c651_attach);
diff --git a/drivers/media/dvb/frontends/at76c651.h b/drivers/media/dvb/frontends/at76c651.h
diff --git a/drivers/media/dvb/frontends/at76c651.h b/drivers/media/dvb/frontends/at76c651.h
deleted file mode 100644
index 34054df..0000000
--- a/drivers/media/dvb/frontends/at76c651.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * at76c651.c
- *
- * Atmel DVB-C Frontend Driver (at76c651)
- *
- * Copyright (C) 2001 fnbrd <fnbrd@gmx.de>
- *             & 2002-2004 Andreas Oberritter <obi@linuxtv.org>
- *             & 2003 Wolfram Joost <dbox2@frokaschwei.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- * AT76C651
- * http://www.nalanda.nitc.ac.in/industry/datasheets/atmel/acrobat/doc1293.pdf
- * http://www.atmel.com/atmel/acrobat/doc1320.pdf
- */
-
-#ifndef AT76C651_H
-#define AT76C651_H
-
-#include <linux/dvb/frontend.h>
-
-struct at76c651_config
-{
-	/* the demodulator's i2c address */
-	u8 demod_address;
-
-	/* PLL maintenance */
-	int (*pll_init)(struct dvb_frontend* fe);
-	int (*pll_set)(struct dvb_frontend* fe, struct dvb_frontend_parameters* params);
-};
-
-extern struct dvb_frontend* at76c651_attach(const struct at76c651_config* config,
-					    struct i2c_adapter* i2c);
-
-#endif // AT76C651_H
diff --git a/drivers/media/dvb/frontends/tda80xx.c b/drivers/media/dvb/frontends/tda80xx.c
diff --git a/drivers/media/dvb/frontends/tda80xx.c b/drivers/media/dvb/frontends/tda80xx.c
deleted file mode 100644
index d1cabb6..0000000
--- a/drivers/media/dvb/frontends/tda80xx.c
+++ /dev/null
@@ -1,734 +0,0 @@
-/*
- * tda80xx.c
- *
- * Philips TDA8044 / TDA8083 QPSK demodulator driver
- *
- * Copyright (C) 2001 Felix Domke <tmbinc@elitedvb.net>
- * Copyright (C) 2002-2004 Andreas Oberritter <obi@linuxtv.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include <linux/config.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/spinlock.h>
-#include <linux/threads.h>
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <asm/irq.h>
-#include <asm/div64.h>
-
-#include "dvb_frontend.h"
-#include "tda80xx.h"
-
-enum {
-	ID_TDA8044 = 0x04,
-	ID_TDA8083 = 0x05,
-};
-
-
-struct tda80xx_state {
-
-	struct i2c_adapter* i2c;
-
-	struct dvb_frontend_ops ops;
-
-	/* configuration settings */
-	const struct tda80xx_config* config;
-
-	struct dvb_frontend frontend;
-
-	u32 clk;
-	int afc_loop;
-	struct work_struct worklet;
-	fe_code_rate_t code_rate;
-	fe_spectral_inversion_t spectral_inversion;
-	fe_status_t status;
-	u8 id;
-};
-
-static int debug = 1;
-#define dprintk	if (debug) printk
-
-static u8 tda8044_inittab_pre[] = {
-	0x02, 0x00, 0x6f, 0xb5, 0x86, 0x22, 0x00, 0xea,
-	0x30, 0x42, 0x98, 0x68, 0x70, 0x42, 0x99, 0x58,
-	0x95, 0x10, 0xf5, 0xe7, 0x93, 0x0b, 0x15, 0x68,
-	0x9a, 0x90, 0x61, 0x80, 0x00, 0xe0, 0x40, 0x00,
-	0x0f, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00
-};
-
-static u8 tda8044_inittab_post[] = {
-	0x04, 0x00, 0x6f, 0xb5, 0x86, 0x22, 0x00, 0xea,
-	0x30, 0x42, 0x98, 0x68, 0x70, 0x42, 0x99, 0x50,
-	0x95, 0x10, 0xf5, 0xe7, 0x93, 0x0b, 0x15, 0x68,
-	0x9a, 0x90, 0x61, 0x80, 0x00, 0xe0, 0x40, 0x6c,
-	0x0f, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00
-};
-
-static u8 tda8083_inittab[] = {
-	0x04, 0x00, 0x4a, 0x79, 0x04, 0x00, 0xff, 0xea,
-	0x48, 0x42, 0x79, 0x60, 0x70, 0x52, 0x9a, 0x10,
-	0x0e, 0x10, 0xf2, 0xa7, 0x93, 0x0b, 0x05, 0xc8,
-	0x9d, 0x00, 0x42, 0x80, 0x00, 0x60, 0x40, 0x00,
-	0x00, 0x75, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00
-};
-
-static __inline__ u32 tda80xx_div(u32 a, u32 b)
-{
-	return (a + (b / 2)) / b;
-}
-
-static __inline__ u32 tda80xx_gcd(u32 a, u32 b)
-{
-	u32 r;
-
-	while ((r = a % b)) {
-		a = b;
-		b = r;
-	}
-
-	return b;
-}
-
-static int tda80xx_read(struct tda80xx_state* state, u8 reg, u8 *buf, u8 len)
-{
-	int ret;
-	struct i2c_msg msg[] = { { .addr = state->config->demod_address, .flags = 0, .buf = &reg, .len = 1 },
-			  { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = buf, .len = len } };
-
-	ret = i2c_transfer(state->i2c, msg, 2);
-
-	if (ret != 2)
-		dprintk("%s: readreg error (reg %02x, ret == %i)\n",
-				__FUNCTION__, reg, ret);
-
-	mdelay(10);
-
-	return (ret == 2) ? 0 : -EREMOTEIO;
-}
-
-static int tda80xx_write(struct tda80xx_state* state, u8 reg, const u8 *buf, u8 len)
-{
-	int ret;
-	u8 wbuf[len + 1];
-	struct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = wbuf, .len = len + 1 };
-
-	wbuf[0] = reg;
-	memcpy(&wbuf[1], buf, len);
-
-	ret = i2c_transfer(state->i2c, &msg, 1);
-
-	if (ret != 1)
-		dprintk("%s: i2c xfer error (ret == %i)\n", __FUNCTION__, ret);
-
-	mdelay(10);
-
-	return (ret == 1) ? 0 : -EREMOTEIO;
-}
-
-static __inline__ u8 tda80xx_readreg(struct tda80xx_state* state, u8 reg)
-{
-	u8 val;
-
-	tda80xx_read(state, reg, &val, 1);
-
-	return val;
-}
-
-static __inline__ int tda80xx_writereg(struct tda80xx_state* state, u8 reg, u8 data)
-{
-	return tda80xx_write(state, reg, &data, 1);
-}
-
-static int tda80xx_set_parameters(struct tda80xx_state* state,
-				  fe_spectral_inversion_t inversion,
-				  u32 symbol_rate,
-				  fe_code_rate_t fec_inner)
-{
-	u8 buf[15];
-	u64 ratio;
-	u32 clk;
-	u32 k;
-	u32 sr = symbol_rate;
-	u32 gcd;
-	u8 scd;
-
-	if (symbol_rate > (state->clk * 3) / 16)
-		scd = 0;
-	else if (symbol_rate > (state->clk * 3) / 32)
-		scd = 1;
-	else if (symbol_rate > (state->clk * 3) / 64)
-		scd = 2;
-	else
-		scd = 3;
-
-	clk = scd ? (state->clk / (scd * 2)) : state->clk;
-
-	/*
-	 * Viterbi decoder:
-	 * Differential decoding off
-	 * Spectral inversion unknown
-	 * QPSK modulation
-	 */
-	if (inversion == INVERSION_ON)
-		buf[0] = 0x60;
-	else if (inversion == INVERSION_OFF)
-		buf[0] = 0x20;
-	else
-		buf[0] = 0x00;
-
-	/*
-	 * CLK ratio:
-	 * system clock frequency is up to 64 or 96 MHz
-	 *
-	 * formula:
-	 * r = k * clk / symbol_rate
-	 *
-	 * k:	2^21 for caa 0..3,
-	 *	2^20 for caa 4..5,
-	 *	2^19 for caa 6..7
-	 */
-	if (symbol_rate <= (clk * 3) / 32)
-		k = (1 << 19);
-	else if (symbol_rate <= (clk * 3) / 16)
-		k = (1 << 20);
-	else
-		k = (1 << 21);
-
-	gcd = tda80xx_gcd(clk, sr);
-	clk /= gcd;
-	sr /= gcd;
-
-	gcd = tda80xx_gcd(k, sr);
-	k /= gcd;
-	sr /= gcd;
-
-	ratio = (u64)k * (u64)clk;
-	do_div(ratio, sr);
-
-	buf[1] = ratio >> 16;
-	buf[2] = ratio >> 8;
-	buf[3] = ratio;
-
-	/* nyquist filter roll-off factor 35% */
-	buf[4] = 0x20;
-
-	clk = scd ? (state->clk / (scd * 2)) : state->clk;
-
-	/* Anti Alias Filter */
-	if (symbol_rate < (clk * 3) / 64)
-		printk("tda80xx: unsupported symbol rate: %u\n", symbol_rate);
-	else if (symbol_rate <= clk / 16)
-		buf[4] |= 0x07;
-	else if (symbol_rate <= (clk * 3) / 32)
-		buf[4] |= 0x06;
-	else if (symbol_rate <= clk / 8)
-		buf[4] |= 0x05;
-	else if (symbol_rate <= (clk * 3) / 16)
-		buf[4] |= 0x04;
-	else if (symbol_rate <= clk / 4)
-		buf[4] |= 0x03;
-	else if (symbol_rate <= (clk * 3) / 8)
-		buf[4] |= 0x02;
-	else if (symbol_rate <= clk / 2)
-		buf[4] |= 0x01;
-	else
-		buf[4] |= 0x00;
-
-	/* Sigma Delta converter */
-	buf[5] = 0x00;
-
-	/* FEC: Possible puncturing rates */
-	if (fec_inner == FEC_NONE)
-		buf[6] = 0x00;
-	else if ((fec_inner >= FEC_1_2) && (fec_inner <= FEC_8_9))
-		buf[6] = (1 << (8 - fec_inner));
-	else if (fec_inner == FEC_AUTO)
-		buf[6] = 0xff;
-	else
-		return -EINVAL;
-
-	/* carrier lock detector threshold value */
-	buf[7] = 0x30;
-	/* AFC1: proportional part settings */
-	buf[8] = 0x42;
-	/* AFC1: integral part settings */
-	buf[9] = 0x98;
-	/* PD: Leaky integrator SCPC mode */
-	buf[10] = 0x28;
-	/* AFC2, AFC1 controls */
-	buf[11] = 0x30;
-	/* PD: proportional part settings */
-	buf[12] = 0x42;
-	/* PD: integral part settings */
-	buf[13] = 0x99;
-	/* AGC */
-	buf[14] = 0x50 | scd;
-
-	printk("symbol_rate=%u clk=%u\n", symbol_rate, clk);
-
-	return tda80xx_write(state, 0x01, buf, sizeof(buf));
-}
-
-static int tda80xx_set_clk(struct tda80xx_state* state)
-{
-	u8 buf[2];
-
-	/* CLK proportional part */
-	buf[0] = (0x06 << 5) | 0x08;	/* CMP[2:0], CSP[4:0] */
-	/* CLK integral part */
-	buf[1] = (0x04 << 5) | 0x1a;	/* CMI[2:0], CSI[4:0] */
-
-	return tda80xx_write(state, 0x17, buf, sizeof(buf));
-}
-
-#if 0
-static int tda80xx_set_scpc_freq_offset(struct tda80xx_state* state)
-{
-	/* a constant value is nonsense here imho */
-	return tda80xx_writereg(state, 0x22, 0xf9);
-}
-#endif
-
-static int tda80xx_close_loop(struct tda80xx_state* state)
-{
-	u8 buf[2];
-
-	/* PD: Loop closed, LD: lock detect enable, SCPC: Sweep mode - AFC1 loop closed */
-	buf[0] = 0x68;
-	/* AFC1: Loop closed, CAR Feedback: 8192 */
-	buf[1] = 0x70;
-
-	return tda80xx_write(state, 0x0b, buf, sizeof(buf));
-}
-
-static irqreturn_t tda80xx_irq(int irq, void *priv, struct pt_regs *pt)
-{
-	schedule_work(priv);
-
-	return IRQ_HANDLED;
-}
-
-static void tda80xx_read_status_int(struct tda80xx_state* state)
-{
-	u8 val;
-
-	static const fe_spectral_inversion_t inv_tab[] = {
-		INVERSION_OFF, INVERSION_ON
-	};
-
-	static const fe_code_rate_t fec_tab[] = {
-		FEC_8_9, FEC_1_2, FEC_2_3, FEC_3_4,
-		FEC_4_5, FEC_5_6, FEC_6_7, FEC_7_8,
-	};
-
-	val = tda80xx_readreg(state, 0x02);
-
-	state->status = 0;
-
-	if (val & 0x01) /* demodulator lock */
-		state->status |= FE_HAS_SIGNAL;
-	if (val & 0x02) /* clock recovery lock */
-		state->status |= FE_HAS_CARRIER;
-	if (val & 0x04) /* viterbi lock */
-		state->status |= FE_HAS_VITERBI;
-	if (val & 0x08) /* deinterleaver lock (packet sync) */
-		state->status |= FE_HAS_SYNC;
-	if (val & 0x10) /* derandomizer lock (frame sync) */
-		state->status |= FE_HAS_LOCK;
-	if (val & 0x20) /* frontend can not lock */
-		state->status |= FE_TIMEDOUT;
-
-	if ((state->status & (FE_HAS_CARRIER)) && (state->afc_loop)) {
-		printk("tda80xx: closing loop\n");
-		tda80xx_close_loop(state);
-		state->afc_loop = 0;
-	}
-
-	if (state->status & (FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK)) {
-		val = tda80xx_readreg(state, 0x0e);
-		state->code_rate = fec_tab[val & 0x07];
-		if (state->status & (FE_HAS_SYNC | FE_HAS_LOCK))
-			state->spectral_inversion = inv_tab[(val >> 7) & 0x01];
-		else
-			state->spectral_inversion = INVERSION_AUTO;
-	}
-	else {
-		state->code_rate = FEC_AUTO;
-	}
-}
-
-static void tda80xx_worklet(void *priv)
-{
-	struct tda80xx_state *state = priv;
-
-	tda80xx_writereg(state, 0x00, 0x04);
-	enable_irq(state->config->irq);
-
-	tda80xx_read_status_int(state);
-}
-
-static void tda80xx_wait_diseqc_fifo(struct tda80xx_state* state)
-{
-	size_t i;
-
-	for (i = 0; i < 100; i++) {
-		if (tda80xx_readreg(state, 0x02) & 0x80)
-			break;
-		msleep(10);
-	}
-}
-
-static int tda8044_init(struct dvb_frontend* fe)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-	int ret;
-
-	/*
-	 * this function is a mess...
-	 */
-
-	if ((ret = tda80xx_write(state, 0x00, tda8044_inittab_pre, sizeof(tda8044_inittab_pre))))
-		return ret;
-
-	tda80xx_writereg(state, 0x0f, 0x50);
-#if 1
-	tda80xx_writereg(state, 0x20, 0x8F);		/* FIXME */
-	tda80xx_writereg(state, 0x20, state->config->volt18setting);	/* FIXME */
-	//tda80xx_writereg(state, 0x00, 0x04);
-	tda80xx_writereg(state, 0x00, 0x0C);
-#endif
-	//tda80xx_writereg(state, 0x00, 0x08); /* Reset AFC1 loop filter */
-
-	tda80xx_write(state, 0x00, tda8044_inittab_post, sizeof(tda8044_inittab_post));
-
-	if (state->config->pll_init) {
-		tda80xx_writereg(state, 0x1c, 0x80);
-		state->config->pll_init(fe);
-		tda80xx_writereg(state, 0x1c, 0x00);
-	}
-
-	return 0;
-}
-
-static int tda8083_init(struct dvb_frontend* fe)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	tda80xx_write(state, 0x00, tda8083_inittab, sizeof(tda8083_inittab));
-
-	if (state->config->pll_init) {
-		tda80xx_writereg(state, 0x1c, 0x80);
-		state->config->pll_init(fe);
-		tda80xx_writereg(state, 0x1c, 0x00);
-	}
-
-	return 0;
-}
-
-static int tda80xx_set_voltage(struct dvb_frontend* fe, fe_sec_voltage_t voltage)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	switch (voltage) {
-	case SEC_VOLTAGE_13:
-		return tda80xx_writereg(state, 0x20, state->config->volt13setting);
-	case SEC_VOLTAGE_18:
-		return tda80xx_writereg(state, 0x20, state->config->volt18setting);
-	case SEC_VOLTAGE_OFF:
-		return tda80xx_writereg(state, 0x20, 0);
-	default:
-		return -EINVAL;
-	}
-}
-
-static int tda80xx_set_tone(struct dvb_frontend* fe, fe_sec_tone_mode_t tone)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	switch (tone) {
-	case SEC_TONE_OFF:
-		return tda80xx_writereg(state, 0x29, 0x00);
-	case SEC_TONE_ON:
-		return tda80xx_writereg(state, 0x29, 0x80);
-	default:
-		return -EINVAL;
-	}
-}
-
-static int tda80xx_send_diseqc_msg(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	if (cmd->msg_len > 6)
-		return -EINVAL;
-
-	tda80xx_writereg(state, 0x29, 0x08 | (cmd->msg_len - 3));
-	tda80xx_write(state, 0x23, cmd->msg, cmd->msg_len);
-	tda80xx_writereg(state, 0x29, 0x0c | (cmd->msg_len - 3));
-	tda80xx_wait_diseqc_fifo(state);
-
-	return 0;
-}
-
-static int tda80xx_send_diseqc_burst(struct dvb_frontend* fe, fe_sec_mini_cmd_t cmd)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	switch (cmd) {
-	case SEC_MINI_A:
-		tda80xx_writereg(state, 0x29, 0x14);
-		break;
-	case SEC_MINI_B:
-		tda80xx_writereg(state, 0x29, 0x1c);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	tda80xx_wait_diseqc_fifo(state);
-
-	return 0;
-}
-
-static int tda80xx_sleep(struct dvb_frontend* fe)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	tda80xx_writereg(state, 0x00, 0x02);	/* enter standby */
-
-	return 0;
-}
-
-static int tda80xx_set_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters *p)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	tda80xx_writereg(state, 0x1c, 0x80);
-	state->config->pll_set(fe, p);
-	tda80xx_writereg(state, 0x1c, 0x00);
-
-	tda80xx_set_parameters(state, p->inversion, p->u.qpsk.symbol_rate, p->u.qpsk.fec_inner);
-	tda80xx_set_clk(state);
-	//tda80xx_set_scpc_freq_offset(state);
-	state->afc_loop = 1;
-
-	return 0;
-}
-
-static int tda80xx_get_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters *p)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	if (!state->config->irq)
-		tda80xx_read_status_int(state);
-
-	p->inversion = state->spectral_inversion;
-	p->u.qpsk.fec_inner = state->code_rate;
-
-	return 0;
-}
-
-static int tda80xx_read_status(struct dvb_frontend* fe, fe_status_t* status)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	if (!state->config->irq)
-		tda80xx_read_status_int(state);
-	*status = state->status;
-
-	return 0;
-}
-
-static int tda80xx_read_ber(struct dvb_frontend* fe, u32* ber)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-	int ret;
-	u8 buf[3];
-
-	if ((ret = tda80xx_read(state, 0x0b, buf, sizeof(buf))))
-		return ret;
-
-	*ber = ((buf[0] & 0x1f) << 16) | (buf[1] << 8) | buf[2];
-
-	return 0;
-}
-
-static int tda80xx_read_signal_strength(struct dvb_frontend* fe, u16* strength)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	u8 gain = ~tda80xx_readreg(state, 0x01);
-	*strength = (gain << 8) | gain;
-
-	return 0;
-}
-
-static int tda80xx_read_snr(struct dvb_frontend* fe, u16* snr)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	u8 quality = tda80xx_readreg(state, 0x08);
-	*snr = (quality << 8) | quality;
-
-	return 0;
-}
-
-static int tda80xx_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	*ucblocks = tda80xx_readreg(state, 0x0f);
-	if (*ucblocks == 0xff)
-		*ucblocks = 0xffffffff;
-
-	return 0;
-}
-
-static int tda80xx_init(struct dvb_frontend* fe)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	switch(state->id) {
-	case ID_TDA8044:
-		return tda8044_init(fe);
-
-	case ID_TDA8083:
-		return tda8083_init(fe);
-	}
-	return 0;
-}
-
-static void tda80xx_release(struct dvb_frontend* fe)
-{
-	struct tda80xx_state* state = fe->demodulator_priv;
-
-	if (state->config->irq)
-		free_irq(state->config->irq, &state->worklet);
-
-	kfree(state);
-}
-
-static struct dvb_frontend_ops tda80xx_ops;
-
-struct dvb_frontend* tda80xx_attach(const struct tda80xx_config* config,
-				    struct i2c_adapter* i2c)
-{
-	struct tda80xx_state* state = NULL;
-	int ret;
-
-	/* allocate memory for the internal state */
-	state = kmalloc(sizeof(struct tda80xx_state), GFP_KERNEL);
-	if (state == NULL) goto error;
-
-	/* setup the state */
-	state->config = config;
-	state->i2c = i2c;
-	memcpy(&state->ops, &tda80xx_ops, sizeof(struct dvb_frontend_ops));
-	state->spectral_inversion = INVERSION_AUTO;
-	state->code_rate = FEC_AUTO;
-	state->status = 0;
-	state->afc_loop = 0;
-
-	/* check if the demod is there */
-	if (tda80xx_writereg(state, 0x89, 0x00) < 0) goto error;
-	state->id = tda80xx_readreg(state, 0x00);
-
-	switch (state->id) {
-	case ID_TDA8044:
-		state->clk = 96000000;
-		printk("tda80xx: Detected tda8044\n");
-		break;
-
-	case ID_TDA8083:
-		state->clk = 64000000;
-		printk("tda80xx: Detected tda8083\n");
-		break;
-
-	default:
-		goto error;
-	}
-
-	/* setup IRQ */
-	if (state->config->irq) {
-		INIT_WORK(&state->worklet, tda80xx_worklet, state);
-		if ((ret = request_irq(state->config->irq, tda80xx_irq, SA_ONESHOT, "tda80xx", &state->worklet)) < 0) {
-			printk(KERN_ERR "tda80xx: request_irq failed (%d)\n", ret);
-			goto error;
-		}
-	}
-
-	/* create dvb_frontend */
-	state->frontend.ops = &state->ops;
-	state->frontend.demodulator_priv = state;
-	return &state->frontend;
-
-error:
-	kfree(state);
-	return NULL;
-}
-
-static struct dvb_frontend_ops tda80xx_ops = {
-
-	.info = {
-		.name = "Philips TDA80xx DVB-S",
-		.type = FE_QPSK,
-		.frequency_min = 500000,
-		.frequency_max = 2700000,
-		.frequency_stepsize = 125,
-		.symbol_rate_min = 4500000,
-		.symbol_rate_max = 45000000,
-		.caps =	FE_CAN_INVERSION_AUTO |
-			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
-			FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
-			FE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |
-			FE_CAN_QPSK |
-			FE_CAN_MUTE_TS
-	},
-
-	.release = tda80xx_release,
-
-	.init = tda80xx_init,
-	.sleep = tda80xx_sleep,
-
-	.set_frontend = tda80xx_set_frontend,
-	.get_frontend = tda80xx_get_frontend,
-
-	.read_status = tda80xx_read_status,
-	.read_ber = tda80xx_read_ber,
-	.read_signal_strength = tda80xx_read_signal_strength,
-	.read_snr = tda80xx_read_snr,
-	.read_ucblocks = tda80xx_read_ucblocks,
-
-	.diseqc_send_master_cmd = tda80xx_send_diseqc_msg,
-	.diseqc_send_burst = tda80xx_send_diseqc_burst,
-	.set_tone = tda80xx_set_tone,
-	.set_voltage = tda80xx_set_voltage,
-};
-
-module_param(debug, int, 0644);
-
-MODULE_DESCRIPTION("Philips TDA8044 / TDA8083 DVB-S Demodulator driver");
-MODULE_AUTHOR("Felix Domke, Andreas Oberritter");
-MODULE_LICENSE("GPL");
-
-EXPORT_SYMBOL(tda80xx_attach);
diff --git a/drivers/media/dvb/frontends/tda80xx.h b/drivers/media/dvb/frontends/tda80xx.h
diff --git a/drivers/media/dvb/frontends/tda80xx.h b/drivers/media/dvb/frontends/tda80xx.h
deleted file mode 100644
index cd639a0..0000000
--- a/drivers/media/dvb/frontends/tda80xx.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * tda80xx.c
- *
- * Philips TDA8044 / TDA8083 QPSK demodulator driver
- *
- * Copyright (C) 2001 Felix Domke <tmbinc@elitedvb.net>
- * Copyright (C) 2002-2004 Andreas Oberritter <obi@linuxtv.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifndef TDA80XX_H
-#define TDA80XX_H
-
-#include <linux/dvb/frontend.h>
-
-struct tda80xx_config
-{
-	/* the demodulator's i2c address */
-	u8 demod_address;
-
-	/* IRQ to use (0=>no IRQ used) */
-	u32 irq;
-
-	/* Register setting to use for 13v */
-	u8 volt13setting;
-
-	/* Register setting to use for 18v */
-	u8 volt18setting;
-
-	/* PLL maintenance */
-	int (*pll_init)(struct dvb_frontend* fe);
-	int (*pll_set)(struct dvb_frontend* fe, struct dvb_frontend_parameters* params);
-};
-
-extern struct dvb_frontend* tda80xx_attach(const struct tda80xx_config* config,
-					   struct i2c_adapter* i2c);
-
-#endif // TDA80XX_H

