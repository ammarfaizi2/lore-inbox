Return-Path: <linux-kernel-owner+willy=40w.ods.org-S1946378AbWJ0Ktu@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1946378AbWJ0Ktu (ORCPT <rfc822;willy@w.ods.org>);
	Fri, 27 Oct 2006 06:49:50 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S1946375AbWJ0Ktu
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Fri, 27 Oct 2006 06:49:50 -0400
Received: from fgwmail5.fujitsu.co.jp ([192.51.44.35]:37269 "EHLO
	fgwmail5.fujitsu.co.jp") by vger.kernel.org with ESMTP
	id S1946310AbWJ0Ktt (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
	Fri, 27 Oct 2006 06:49:49 -0400
Date: Fri, 27 Oct 2006 19:49:54 +0900
Message-ID: <87lkn2vxrh.wl%takeuchi_satoru@jp.fujitsu.com>
From: Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>
To: linux-ia64 <linux-ia64@vger.kernel.org>,
       Linux Kernel <linux-kernel@vger.kernel.org>
Cc: Andrew Morton <akpm@osdl.org>, Rusty Russell <rusty@rustycorp.com.au>,
       Srivatsa Vaddagiri <vatsa@in.ibm.com>,
       Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>
Subject: [BUGFIX] [PATH 2/2] cpu-hotplug: Releasing `workqueue_mutex' properly on CPU hot-remove
User-Agent: Wanderlust/2.11.30 (Wonderwall) SEMI/1.14.6 (Maruoka) FLIM/1.14.6 (Marutamachi) APEL/10.6 Emacs/21.4 (i386-pc-linux-gnu) MULE/5.0 (SAKAKI)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

Releasing `workqueue_mutex' properly on CPU hot-remove.

_cpu_down() acquires `workqueue_mutex' on its process, but doen't release it
if __cpu_disable() fails.

Signed-off-by: Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>

Index: linux-2.6.19-rc3/kernel/cpu.c
===================================================================
--- linux-2.6.19-rc3.orig/kernel/cpu.c	2006-10-24 14:01:39.000000000 +0900
+++ linux-2.6.19-rc3/kernel/cpu.c	2006-10-27 19:38:14.000000000 +0900
@@ -150,18 +150,18 @@
 	p = __stop_machine_run(take_cpu_down, NULL, cpu);
 	mutex_unlock(&cpu_bitmask_lock);
 
-	if (IS_ERR(p)) {
+	if (IS_ERR(p) || cpu_online(cpu)) {
 		/* CPU didn't die: tell everyone.  Can't complain. */
 		if (raw_notifier_call_chain(&cpu_chain, CPU_DOWN_FAILED,
 				(void *)(long)cpu) == NOTIFY_BAD)
 			BUG();
 
-		err = PTR_ERR(p);
-		goto out_allowed;
-	}
-
-	if (cpu_online(cpu))
+		if (IS_ERR(p)) {
+			err = PTR_ERR(p);
+			goto out_allowed;
+		}
 		goto out_thread;
+	}
 
 	/* Wait for it to sleep (leaving idle task). */
 	while (!idle_cpu(cpu))
