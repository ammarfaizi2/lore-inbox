Return-Path: <linux-kernel-owner+willy=40w.ods.org@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id <S261845AbSJQH3C>; Thu, 17 Oct 2002 03:29:02 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org
	id <S261848AbSJQH3C>; Thu, 17 Oct 2002 03:29:02 -0400
Received: from dell-paw-3.cambridge.redhat.com ([195.224.55.237]:24047 "EHLO
	executor.cambridge.redhat.com") by vger.kernel.org with ESMTP
	id <S261845AbSJQH22>; Thu, 17 Oct 2002 03:28:28 -0400
To: Matt Reppert <arashi@arashi.yi.org>, Chris Wright <chris@wirex.com>
Cc: dhowells@redhat.com, linux-kernel@vger.kernel.org
Subject: Re: [PATCH] AFS compile breakage in 2.5.43 
In-Reply-To: Message from Chris Wright <chris@wirex.com> 
   of "Wed, 16 Oct 2002 17:04:03 PDT." <20021016170403.A28039@figure1.int.wirex.com> 
User-Agent: EMH/1.14.1 SEMI/1.14.3 (Ushinoya) FLIM/1.14.3
 (=?ISO-8859-4?Q?Unebigory=F2mae?=) APEL/10.3 Emacs/21.2 (i686-pc-linux-gnu)
 MULE/5.0 (SAKAKI)
MIME-Version: 1.0 (generated by SEMI 1.14.3 - "Ushinoya")
Content-Type: text/plain; charset=US-ASCII
Date: Thu, 17 Oct 2002 08:34:20 +0100
Message-ID: <3845.1034840060@warthog.cambridge.redhat.com>
From: David Howells <dhowells@cambridge.redhat.com>
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org


> Yes, it's valid for newer compilers.  I have a similar patch that also
> updates the varargs macro stuff used in AFS (and rxrpc) (for akpm's "crusty"
> compilers ;-)

Can you try the attached patch please.

David

diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/cmservice.c /inst-afs/devel/afs/fs/afs/cmservice.c
--- linux-2.5.43/fs/afs/cmservice.c	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/cmservice.c	2002-10-16 13:31:18.000000000 +0100
@@ -129,11 +129,7 @@
 	/* only certain signals are of interest */
 	spin_lock_irq(&current->sig->siglock);
 	siginitsetinv(&current->blocked,0);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,3)
 	recalc_sigpending();
-#else
-	recalc_sigpending(current);
-#endif
 	spin_unlock_irq(&current->sig->siglock);
 
 	/* loop around looking for things to attend to */
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/dir.c /inst-afs/devel/afs/fs/afs/dir.c
--- linux-2.5.43/fs/afs/dir.c	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/dir.c	2002-10-16 13:31:55.000000000 +0100
@@ -38,19 +38,17 @@
 
 struct inode_operations afs_dir_inode_operations = {
 	.lookup		= afs_dir_lookup,
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	.getattr	= afs_inode_getattr,
-#else
-	.revalidate	= afs_inode_revalidate,
+#if 0 /* TODO */
+	.create		= afs_dir_create,
+	.link		= afs_dir_link,
+	.unlink		= afs_dir_unlink,
+	.symlink	= afs_dir_symlink,
+	.mkdir		= afs_dir_mkdir,
+	.rmdir		= afs_dir_rmdir,
+	.mknod		= afs_dir_mknod,
+	.rename		= afs_dir_rename,
 #endif
-//	.create		= afs_dir_create,
-//	.link		= afs_dir_link,
-//	.unlink		= afs_dir_unlink,
-//	.symlink	= afs_dir_symlink,
-//	.mkdir		= afs_dir_mkdir,
-//	.rmdir		= afs_dir_rmdir,
-//	.mknod		= afs_dir_mknod,
-//	.rename		= afs_dir_rename,
 };
 
 static struct dentry_operations afs_fs_dentry_operations = {
@@ -72,7 +70,7 @@
 		u8	name[16];
 		u8	overflow[4];	/* if any char of the name (inc NUL) reaches here, consume
 					 * the next dirent too */
-	};
+	} u;
 	u8	extended_name[32];
 } afs_dirent_t;
 
@@ -250,7 +248,7 @@
 
 		/* skip entries marked unused in the bitmap */
 		if (!(block->pagehdr.bitmap[offset/8] & (1 << (offset % 8)))) {
-			_debug("ENT[%u.%u]: unused\n",blkoff/sizeof(afs_dir_block_t),offset);
+			_debug("ENT[%Zu.%u]: unused\n",blkoff/sizeof(afs_dir_block_t),offset);
 			if (offset>=curr)
 				*fpos = blkoff + next * sizeof(afs_dirent_t);
 			continue;
@@ -258,28 +256,28 @@
 
 		/* got a valid entry */
 		dire = &block->dirents[offset];
-		nlen = strnlen(dire->name,sizeof(*block) - offset*sizeof(afs_dirent_t));
+		nlen = strnlen(dire->u.name,sizeof(*block) - offset*sizeof(afs_dirent_t));
 
-		_debug("ENT[%u.%u]: %s %u \"%.*s\"\n",
+		_debug("ENT[%Zu.%u]: %s %Zu \"%s\"\n",
 		       blkoff/sizeof(afs_dir_block_t),offset,
-		       offset<curr ? "skip" : "fill",
-		       nlen,nlen,dire->name);
+		       (offset<curr ? "skip" : "fill"),
+		       nlen,dire->u.name);
 
 		/* work out where the next possible entry is */
 		for (tmp=nlen; tmp>15; tmp-=sizeof(afs_dirent_t)) {
 			if (next>=AFS_DIRENT_PER_BLOCK) {
-				_debug("ENT[%u.%u]:"
-				       " %u travelled beyond end dir block (len %u/%u)\n",
+				_debug("ENT[%Zu.%u]:"
+				       " %u travelled beyond end dir block (len %u/%Zu)\n",
 				       blkoff/sizeof(afs_dir_block_t),offset,next,tmp,nlen);
 				return -EIO;
 			}
 			if (!(block->pagehdr.bitmap[next/8] & (1 << (next % 8)))) {
-				_debug("ENT[%u.%u]: %u unmarked extension (len %u/%u)\n",
+				_debug("ENT[%Zu.%u]: %u unmarked extension (len %u/%Zu)\n",
 				       blkoff/sizeof(afs_dir_block_t),offset,next,tmp,nlen);
 				return -EIO;
 			}
 
-			_debug("ENT[%u.%u]: ext %u/%u\n",
+			_debug("ENT[%Zu.%u]: ext %u/%Zu\n",
 			       blkoff/sizeof(afs_dir_block_t),next,tmp,nlen);
 			next++;
 		}
@@ -290,11 +288,11 @@
 
 		/* found the next entry */
 		ret = filldir(cookie,
-			      dire->name,
+			      dire->u.name,
 			      nlen,
 			      blkoff + offset * sizeof(afs_dirent_t),
-			      ntohl(dire->vnode),
-			      filldir==afs_dir_lookup_filldir ? dire->unique : DT_UNKNOWN);
+			      ntohl(dire->u.vnode),
+			      filldir==afs_dir_lookup_filldir ? dire->u.unique : DT_UNKNOWN);
 		if (ret<0) {
 			_leave(" = 0 [full]");
 			return 0;
@@ -397,7 +395,7 @@
 {
 	struct afs_dir_lookup_cookie *cookie = _cookie;
 
-	_enter("{%s,%u},%s,%u,,%lu,%u",cookie->name,cookie->nlen,name,nlen,ino,ntohl(dtype));
+	_enter("{%s,%Zu},%s,%u,,%lu,%u",cookie->name,cookie->nlen,name,nlen,ino,ntohl(dtype));
 
 	if (cookie->nlen != nlen || memcmp(cookie->name,name,nlen)!=0) {
 		_leave(" = 0 [no]");
@@ -471,7 +469,7 @@
 	}
 
 	dentry->d_op = &afs_fs_dentry_operations;
-	dentry->d_fsdata = (void*) (unsigned) vnode->status.version;
+	dentry->d_fsdata = (void*) (unsigned long) vnode->status.version;
 
 	d_add(dentry,inode);
 	_leave(" = 0 { vn=%u u=%u } -> { ino=%lu v=%lu }",
@@ -500,15 +498,9 @@
 	_enter("%s,%x",dentry->d_name.name,flags);
 
 	/* lock down the parent dentry so we can peer at it */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	read_lock(&dparent_lock);
 	parent = dget(dentry->d_parent);
 	read_unlock(&dparent_lock);
-#else
-	lock_kernel();
-	parent = dget(dentry->d_parent);
-	unlock_kernel();
-#endif
 
 	dir = parent->d_inode;
 	inode = dentry->d_inode;
@@ -541,10 +533,10 @@
 		goto out_bad;
 	}
 
-	if ((unsigned)dentry->d_fsdata != (unsigned)AFS_FS_I(dir)->status.version) {
-		_debug("%s: parent changed %u -> %u",
+	if ((unsigned long)dentry->d_fsdata != (unsigned long)AFS_FS_I(dir)->status.version) {
+		_debug("%s: parent changed %lu -> %u",
 		       dentry->d_name.name,
-		       (unsigned)dentry->d_fsdata,
+		       (unsigned long)dentry->d_fsdata,
 		       (unsigned)AFS_FS_I(dir)->status.version);
 
 		/* search the directory for this vnode */
@@ -585,7 +577,7 @@
 			goto out_bad;
 		}
 
-		dentry->d_fsdata = (void*) (unsigned) AFS_FS_I(dir)->status.version;
+		dentry->d_fsdata = (void*) (unsigned long) AFS_FS_I(dir)->status.version;
 	}
 
  out_valid:
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/errors.h /inst-afs/devel/afs/fs/afs/errors.h
--- linux-2.5.43/fs/afs/errors.h	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/errors.h	2002-10-16 13:25:21.000000000 +0100
@@ -9,8 +9,8 @@
  * 2 of the License, or (at your option) any later version.
  */
 
-#ifndef _H_DB712916_5113_11D6_9A6D_0002B3163499
-#define _H_DB712916_5113_11D6_9A6D_0002B3163499
+#ifndef _LINUX_AFS_ERRORS_H
+#define _LINUX_AFS_ERRORS_H
 
 #include "types.h"
 
@@ -31,4 +31,4 @@
 
 extern int afs_abort_to_error(int abortcode);
 
-#endif /* _H_DB712916_5113_11D6_9A6D_0002B3163499 */
+#endif /* _LINUX_AFS_ERRORS_H */
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/file.c /inst-afs/devel/afs/fs/afs/file.c
--- linux-2.5.43/fs/afs/file.c	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/file.c	2002-10-16 13:37:04.000000000 +0100
@@ -21,30 +21,28 @@
 #include <rxrpc/call.h>
 #include "internal.h"
 
-//static int afs_file_open(struct inode *inode, struct file *file);
-//static int afs_file_release(struct inode *inode, struct file *file);
+#if 0
+static int afs_file_open(struct inode *inode, struct file *file);
+static int afs_file_release(struct inode *inode, struct file *file);
+#endif
 
 static int afs_file_readpage(struct file *file, struct page *page);
 
-//static ssize_t afs_file_read(struct file *file, char *buf, size_t size, loff_t *off);
-
 static ssize_t afs_file_write(struct file *file, const char *buf, size_t size, loff_t *off);
 
 struct inode_operations afs_file_inode_operations = {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	.getattr	= afs_inode_getattr,
-#else
-	.revalidate	= afs_inode_revalidate,
-#endif
 };
 
 struct file_operations afs_file_file_operations = {
-//	.open		= afs_file_open,
-//	.release	= afs_file_release,
-	.read		= generic_file_read, //afs_file_read,
+	.read		= generic_file_read,
 	.write		= afs_file_write,
 	.mmap		= generic_file_mmap,
-//	.fsync		= afs_file_fsync,
+#if 0
+	.open		= afs_file_open,
+	.release	= afs_file_release,
+	.fsync		= afs_file_fsync,
+#endif
 };
 
 struct address_space_operations afs_fs_aops = {
@@ -53,23 +51,6 @@
 
 /*****************************************************************************/
 /*
- * AFS file read
- */
-#if 0
-static ssize_t afs_file_read(struct file *file, char *buf, size_t size, loff_t *off)
-{
-	struct afs_inode_info *ai;
-
-	ai = AFS_FS_I(file->f_dentry->d_inode);
-	if (ai->flags & AFS_INODE_DELETED)
-		return -ESTALE;
-
-	return -EIO;
-} /* end afs_file_read() */
-#endif
-
-/*****************************************************************************/
-/*
  * AFS file write
  */
 static ssize_t afs_file_write(struct file *file, const char *buf, size_t size, loff_t *off)
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/fsclient.c /inst-afs/devel/afs/fs/afs/fsclient.c
--- linux-2.5.43/fs/afs/fsclient.c	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/fsclient.c	2002-10-16 12:39:21.000000000 +0100
@@ -426,7 +426,7 @@
 	int ret;
 	u32 *bp;
 
-	_enter("%p,{fid={%u,%u,%u},sz=%u,of=%lu}",
+	_enter("%p,{fid={%u,%u,%u},sz=%Zu,of=%lu}",
 	       server,
 	       desc->fid.vid,
 	       desc->fid.vnode,
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/inode.c /inst-afs/devel/afs/fs/afs/inode.c
--- linux-2.5.43/fs/afs/inode.c	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/inode.c	2002-10-16 13:34:22.000000000 +0100
@@ -28,9 +28,6 @@
 struct afs_iget_data {
 	afs_fid_t		fid;
 	afs_volume_t		*volume;	/* volume on which resides */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	afs_vnode_t		*new_vnode;	/* new vnode record */
-#endif
 };
 
 /*****************************************************************************/
@@ -41,7 +38,7 @@
 {
 	struct inode *inode = AFS_VNODE_TO_I(vnode);
 
-	_debug("FS: ft=%d lk=%d sz=%u ver=%Lu mod=%hu",
+	_debug("FS: ft=%d lk=%d sz=%Zu ver=%Lu mod=%hu",
 	       vnode->status.type,
 	       vnode->status.nlink,
 	       vnode->status.size,
@@ -117,7 +114,6 @@
 /*
  * iget5() comparator
  */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 static int afs_iget5_test(struct inode *inode, void *opaque)
 {
 	struct afs_iget_data *data = opaque;
@@ -125,13 +121,11 @@
 	/* only match inodes with the same version number */
 	return inode->i_ino==data->fid.vnode && inode->i_version==data->fid.unique;
 } /* end afs_iget5_test() */
-#endif
 
 /*****************************************************************************/
 /*
  * iget5() inode initialiser
  */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 static int afs_iget5_set(struct inode *inode, void *opaque)
 {
 	struct afs_iget_data *data = opaque;
@@ -144,71 +138,6 @@
 
 	return 0;
 } /* end afs_iget5_set() */
-#endif
-
-/*****************************************************************************/
-/*
- * iget4() comparator
- */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-static int afs_iget4_test(struct inode *inode, ino_t ino, void *opaque)
-{
-	struct afs_iget_data *data = opaque;
-
-	/* only match inodes with the same version number */
-	return inode->i_ino==data->fid.vnode && inode->i_version==data->fid.unique;
-} /* end afs_iget4_test() */
-#endif
-
-/*****************************************************************************/
-/*
- * read an inode (2.4 only)
- */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-void afs_read_inode2(struct inode *inode, void *opaque)
-{
-	struct afs_iget_data *data = opaque;
-	afs_vnode_t *vnode;
-	int ret;
-
-	_enter(",{{%u,%u,%u},%p}",data->fid.vid,data->fid.vnode,data->fid.unique,data->volume);
-
-	if (inode->u.generic_ip) BUG();
-
-	/* attach a pre-allocated vnode record */
-	inode->u.generic_ip = vnode = data->new_vnode;
-	data->new_vnode = NULL;
-
-	memset(vnode,0,sizeof(*vnode));
-	vnode->inode = inode;
-	init_waitqueue_head(&vnode->update_waitq);
-	spin_lock_init(&vnode->lock);
-	INIT_LIST_HEAD(&vnode->cb_link);
-	INIT_LIST_HEAD(&vnode->cb_hash_link);
-	afs_timer_init(&vnode->cb_timeout,&afs_vnode_cb_timed_out_ops);
-	vnode->flags |= AFS_VNODE_CHANGED;
-	vnode->volume = data->volume;
-	vnode->fid = data->fid;
-
-	/* ask the server for a status check */
-	ret = afs_vnode_fetch_status(vnode);
-	if (ret<0) {
-		make_bad_inode(inode);
-		_leave(" [bad inode]");
-		return;
-	}
-
-	ret = afs_inode_map_status(vnode);
-	if (ret<0) {
-		make_bad_inode(inode);
-		_leave(" [bad inode]");
-		return;
-	}
-
-	_leave("");
-	return;
-} /* end afs_read_inode2() */
-#endif
 
 /*****************************************************************************/
 /*
@@ -227,7 +156,6 @@
 	as = sb->s_fs_info;
 	data.volume = as->volume;
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	inode = iget5_locked(sb,fid->vnode,afs_iget5_test,afs_iget5_set,&data);
 	if (!inode) {
 		_leave(" = -ENOMEM");
@@ -253,13 +181,6 @@
 	if (ret<0)
 		goto bad_inode;
 
-#if 0
-	/* find a cache entry for it */
-	ret = afs_cache_lookup_vnode(as->volume,vnode);
-	if (ret<0)
-		goto bad_inode;
-#endif
-
 	/* success */
 	unlock_new_inode(inode);
 
@@ -280,42 +201,12 @@
 
 	_leave(" = %d [bad]",ret);
 	return ret;
-
-#else
-
-	/* pre-allocate a vnode record so that afs_read_inode2() doesn't have to return an inode
-	 * without one attached
-	 */
-	data.new_vnode = kmalloc(sizeof(afs_vnode_t),GFP_KERNEL);
-	if (!data.new_vnode) {
-		_leave(" = -ENOMEM");
-		return -ENOMEM;
-	}
-
-	inode = iget4(sb,fid->vnode,afs_iget4_test,&data);
-	if (data.new_vnode) kfree(data.new_vnode); 
-	if (!inode) {
-		_leave(" = -ENOMEM");
-		return -ENOMEM;
-	}
-
-	vnode = AFS_FS_I(inode);
-	*_inode = inode;
-	_leave(" = 0 [CB { v=%u x=%lu t=%u nix=%u }]",
-	       vnode->cb_version,
-	       vnode->cb_timeout.timo_jif,
-	       vnode->cb_type,
-	       vnode->nix
-	       );
-	return 0;
-#endif
 } /* end afs_iget() */
 
 /*****************************************************************************/
 /*
  * read the attributes of an inode
  */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 int afs_inode_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
 	struct inode *inode;
@@ -349,44 +240,6 @@
 
 	return 0;
 } /* end afs_inode_getattr() */
-#endif
-
-/*****************************************************************************/
-/*
- * revalidate the inode
- */
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,0)
-int afs_inode_revalidate(struct dentry *dentry)
-{
-	struct inode *inode;
-	afs_vnode_t *vnode;
-	int ret;
-
-	inode = dentry->d_inode;
-
-	_enter("{ ino=%lu v=%lu }",inode->i_ino,inode->i_version);
-
-	vnode = AFS_FS_I(inode);
-
-	ret = afs_inode_fetch_status(inode);
-	if (ret==-ENOENT) {
-		_leave(" = %d [%d %p]",ret,atomic_read(&dentry->d_count),dentry->d_inode);
-		return ret;
-	}
-	else if (ret<0) {
-		make_bad_inode(inode);
-		_leave(" = %d",ret);
-		return ret;
-	}
-
-	_leave(" = 0 CB { v=%u x=%u t=%u }",
-	       vnode->cb_version,
-	       vnode->cb_expiry,
-	       vnode->cb_type);
-
-	return 0;
-} /* end afs_inode_revalidate() */
-#endif
 
 /*****************************************************************************/
 /*
@@ -410,9 +263,5 @@
 
 	afs_vnode_give_up_callback(vnode);
 
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,0)
-	if (inode->u.generic_ip) kfree(inode->u.generic_ip);
-#endif
-
 	_leave("");
 } /* end afs_clear_inode() */
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/internal.h /inst-afs/devel/afs/fs/afs/internal.h
--- linux-2.5.43/fs/afs/internal.h	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/internal.h	2002-10-16 13:34:43.000000000 +0100
@@ -21,34 +21,24 @@
 /*
  * debug tracing
  */
-#define kenter(FMT,...)	printk("==> %s("FMT")\n",__FUNCTION__,##__VA_ARGS__)
-#define kleave(FMT,...)	printk("<== %s()"FMT"\n",__FUNCTION__,##__VA_ARGS__)
-#define kdebug(FMT,...)	printk(FMT"\n",##__VA_ARGS__)
-#define kproto(FMT,...)	printk("### "FMT"\n",##__VA_ARGS__)
-#define knet(FMT,...)	printk(FMT"\n",##__VA_ARGS__)
+#define kenter(FMT, a...)	printk("==> %s("FMT")\n",__FUNCTION__ , ## a)
+#define kleave(FMT, a...)	printk("<== %s()"FMT"\n",__FUNCTION__ , ## a)
+#define kdebug(FMT, a...)	printk(FMT"\n" , ## a)
+#define kproto(FMT, a...)	printk("### "FMT"\n" , ## a)
+#define knet(FMT, a...)		printk(FMT"\n" , ## a)
 
 #if 0
-#define _enter(FMT,...)	kenter(FMT,##__VA_ARGS__)
-#define _leave(FMT,...)	kleave(FMT,##__VA_ARGS__)
-#define _debug(FMT,...)	kdebug(FMT,##__VA_ARGS__)
-#define _proto(FMT,...)	kproto(FMT,##__VA_ARGS__)
-#define _net(FMT,...)	knet(FMT,##__VA_ARGS__)
+#define _enter(FMT, a...)	kenter(FMT , ## a)
+#define _leave(FMT, a...)	kleave(FMT , ## a)
+#define _debug(FMT, a...)	kdebug(FMT , ## a)
+#define _proto(FMT, a...)	kproto(FMT , ## a)
+#define _net(FMT, a...)		knet(FMT , ## a)
 #else
-#define _enter(FMT,...)	do { } while(0)
-#define _leave(FMT,...)	do { } while(0)
-#define _debug(FMT,...)	do { } while(0)
-#define _proto(FMT,...)	do { } while(0)
-#define _net(FMT,...)	do { } while(0)
-#endif
-
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,0)
-#define wait_on_page_locked wait_on_page
-#define PageUptodate Page_Uptodate
-
-static inline struct proc_dir_entry *PDE(const struct inode *inode)
-{
-	return (struct proc_dir_entry *)inode->u.generic_ip;
-}
+#define _enter(FMT, a...)	do { } while(0)
+#define _leave(FMT, a...)	do { } while(0)
+#define _debug(FMT, a...)	do { } while(0)
+#define _proto(FMT, a...)	do { } while(0)
+#define _net(FMT, a...)		do { } while(0)
 #endif
 
 static inline void afs_discard_my_signals(void)
@@ -85,12 +75,7 @@
  * inode.c
  */
 extern int afs_iget(struct super_block *sb, afs_fid_t *fid, struct inode **_inode);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 extern int afs_inode_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat);
-#else
-extern void afs_read_inode2(struct inode *inode, void *opaque);
-extern int afs_inode_revalidate(struct dentry *dentry);
-#endif
 extern void afs_clear_inode(struct inode *inode);
 
 /*
@@ -113,7 +98,7 @@
 extern spinlock_t afs_cb_hash_lock;
 
 #define afs_cb_hash(SRV,FID) \
-	afs_cb_hash_tbl[((unsigned)(SRV) + (FID)->vid + (FID)->vnode + (FID)->unique) % \
+	afs_cb_hash_tbl[((unsigned long)(SRV) + (FID)->vid + (FID)->vnode + (FID)->unique) % \
 			AFS_CB_HASH_COUNT]
 
 /*
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/kafsasyncd.c /inst-afs/devel/afs/fs/afs/kafsasyncd.c
--- linux-2.5.43/fs/afs/kafsasyncd.c	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/kafsasyncd.c	2002-10-16 13:34:49.000000000 +0100
@@ -103,11 +103,7 @@
 	/* only certain signals are of interest */
 	spin_lock_irq(&current->sig->siglock);
 	siginitsetinv(&current->blocked,0);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,3)
 	recalc_sigpending();
-#else
-	recalc_sigpending(current);
-#endif
 	spin_unlock_irq(&current->sig->siglock);
 
 	/* loop around looking for things to attend to */
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/kafstimod.c /inst-afs/devel/afs/fs/afs/kafstimod.c
--- linux-2.5.43/fs/afs/kafstimod.c	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/kafstimod.c	2002-10-16 13:34:53.000000000 +0100
@@ -80,11 +80,7 @@
 	/* only certain signals are of interest */
 	spin_lock_irq(&current->sig->siglock);
 	siginitsetinv(&current->blocked,0);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,3)
 	recalc_sigpending();
-#else
-	recalc_sigpending(current);
-#endif
 	spin_unlock_irq(&current->sig->siglock);
 
 	/* loop around looking for things to attend to */
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/main.c /inst-afs/devel/afs/fs/afs/main.c
--- linux-2.5.43/fs/afs/main.c	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/main.c	2002-10-16 12:39:21.000000000 +0100
@@ -173,8 +173,8 @@
 
 	_debug("Discarding peer %08x (rtt=%lu.%lumS)\n",
 	       ntohl(peer->addr.s_addr),
-	       peer->rtt/1000,
-	       peer->rtt%1000);
+	       (long)(peer->rtt/1000),
+	       (long)(peer->rtt%1000));
 
 	/* uncross-point the structs under a global lock */
 	spin_lock(&afs_server_peer_lock);
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/Makefile /inst-afs/devel/afs/fs/afs/Makefile
--- linux-2.5.43/fs/afs/Makefile	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/Makefile	2002-10-16 13:29:58.000000000 +0100
@@ -23,14 +23,6 @@
 	vnode.o \
 	volume.o
 
-#	cache.o
-
 obj-m  := kafs.o
 
-# superfluous for 2.5, but needed for 2.4..
-ifeq "$(VERSION).$(PATCHLEVEL)" "2.4"
-kafs.o: $(kafs-objs)
-	$(LD) -r -o kafs.o $(kafs-objs)
-endif
-
 include $(TOPDIR)/Rules.make
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/mntpt.c /inst-afs/devel/afs/fs/afs/mntpt.c
--- linux-2.5.43/fs/afs/mntpt.c	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/mntpt.c	2002-10-16 13:34:58.000000000 +0100
@@ -31,11 +31,7 @@
 struct inode_operations afs_mntpt_inode_operations = {
 	.lookup		= afs_mntpt_lookup,
 	.readlink	= page_readlink,
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	.getattr	= afs_inode_getattr,
-#else
-	.revalidate	= afs_inode_revalidate,
-#endif
 };
 
 /*****************************************************************************/
@@ -70,7 +66,7 @@
 
 	/* examine the symlink's contents */
 	size = vnode->status.size;
-	_debug("symlink to %*.*s",size,size,buf);
+	_debug("symlink to %*.*s",size,(int)size,buf);
 
 	if (size>2 &&
 	    (buf[0]=='%' || buf[0]=='#') &&
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/proc.c /inst-afs/devel/afs/fs/afs/proc.c
--- linux-2.5.43/fs/afs/proc.c	2002-10-16 11:57:26.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/proc.c	2002-10-16 12:39:21.000000000 +0100
@@ -412,6 +412,7 @@
 
 	afs_put_cell(cell);
 
+	return ret;
 } /* end afs_proc_cell_volumes_release() */
 
 /*****************************************************************************/
@@ -536,6 +537,7 @@
 
 	afs_put_cell(cell);
 
+	return ret;
 } /* end afs_proc_cell_vlservers_release() */
 
 /*****************************************************************************/
@@ -651,6 +653,7 @@
 
 	afs_put_cell(cell);
 
+	return ret;
 } /* end afs_proc_cell_servers_release() */
 
 /*****************************************************************************/
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/super.c /inst-afs/devel/afs/fs/afs/super.c
--- linux-2.5.43/fs/afs/super.c	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/super.c	2002-10-16 13:36:15.000000000 +0100
@@ -39,12 +39,8 @@
 
 static void afs_i_init_once(void *foo, kmem_cache_t *cachep, unsigned long flags);
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 static struct super_block *afs_get_sb(struct file_system_type *fs_type,
 				      int flags, char *dev_name, void *data);
-#else
-static struct super_block *afs_read_super(struct super_block *sb, void *data, int);
-#endif
 
 static struct inode *afs_alloc_inode(struct super_block *sb);
 
@@ -55,30 +51,20 @@
 static struct file_system_type afs_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "afs",
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	.get_sb		= afs_get_sb,
 	.kill_sb	= kill_anon_super,
-#else
-	.read_super	= afs_read_super,
-#endif
 };
 
 static struct super_operations afs_super_ops = {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	.statfs		= simple_statfs,
 	.alloc_inode	= afs_alloc_inode,
 	.drop_inode	= generic_delete_inode,
 	.destroy_inode	= afs_destroy_inode,
-#else
-	.read_inode2	= afs_read_inode2,
-#endif
 	.clear_inode	= afs_clear_inode,
 	.put_super	= afs_put_super,
 };
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 static kmem_cache_t *afs_inode_cachep;
-#endif
 
 /*****************************************************************************/
 /*
@@ -90,23 +76,6 @@
 
 	kenter("");
 
-	/* open the cache */
-#if 0
-	ret = -EINVAL;
-	if (!cachedev) {
-		printk(KERN_NOTICE "kAFS: No cache device specified as module parm\n");
-		printk(KERN_NOTICE "kAFS: Set with \"cachedev=<devname>\" on insmod's cmdline\n");
-		return ret;
-	}
-
-	ret = afs_cache_open(cachedev,&afs_cache);
-	if (ret<0) {
-		printk(KERN_NOTICE "kAFS: Failed to open cache device\n");
-		return ret;
-	}
-#endif
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	/* create ourselves an inode cache */
 	ret = -ENOMEM;
 	afs_inode_cachep = kmem_cache_create("afs_inode_cache",
@@ -117,22 +86,13 @@
 						NULL);
 	if (!afs_inode_cachep) {
 		printk(KERN_NOTICE "kAFS: Failed to allocate inode cache\n");
-#if 0
-		afs_put_cache(afs_cache);
-#endif
 		return ret;
 	}
-#endif
 
 	/* now export our filesystem to lesser mortals */
 	ret = register_filesystem(&afs_fs_type);
 	if (ret<0) {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 		kmem_cache_destroy(afs_inode_cachep);
-#endif
-#if 0
-		afs_put_cache(afs_cache);
-#endif
 		kleave(" = %d",ret);
 		return ret;
 	}
@@ -148,16 +108,10 @@
 void __exit afs_fs_exit(void)
 {
 	/* destroy our private inode cache */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	kmem_cache_destroy(afs_inode_cachep);
-#endif
 
 	unregister_filesystem(&afs_fs_type);
 
-#if 0
-	if (afs_cache)
-		afs_put_cache(afs_cache);
-#endif
 } /* end afs_fs_exit() */
 
 /*****************************************************************************/
@@ -453,7 +407,6 @@
  * get an AFS superblock
  * - TODO: don't use get_sb_nodev(), but rather call sget() directly
  */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 static struct super_block *afs_get_sb(struct file_system_type *fs_type,
 				      int flags,
 				      char *dev_name,
@@ -482,39 +435,6 @@
 	_leave("");
 	return sb;
 } /* end afs_get_sb() */
-#endif
-
-/*****************************************************************************/
-/*
- * read an AFS superblock
- */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-static struct super_block *afs_read_super(struct super_block *sb, void *options, int silent)
-{
-	void *data[2] = { NULL, options };
-	int ret;
-
-	_enter(",,%s",(char*)options);
-
-	/* start the cache manager */
-	ret = afscm_start();
-	if (ret<0) {
-		_leave(" = NULL (%d)",ret);
-		return NULL;
-	}
-
-	/* allocate a deviceless superblock */
-	ret = afs_fill_super(sb,data,silent);
-	if (ret<0) {
-		afscm_stop();
-		_leave(" = NULL (%d)",ret);
-		return NULL;
-	}
-
-	_leave(" = %p",sb);
-	return sb;
-} /* end afs_read_super() */
-#endif
 
 /*****************************************************************************/
 /*
@@ -540,7 +460,6 @@
 /*
  * initialise an inode cache slab element prior to any use
  */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 static void afs_i_init_once(void *_vnode, kmem_cache_t *cachep, unsigned long flags)
 {
 	afs_vnode_t *vnode = (afs_vnode_t *) _vnode;
@@ -556,13 +475,11 @@
 	}
 
 } /* end afs_i_init_once() */
-#endif
 
 /*****************************************************************************/
 /*
  * allocate an AFS inode struct from our slab cache
  */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 static struct inode *afs_alloc_inode(struct super_block *sb)
 {
 	afs_vnode_t *vnode;
@@ -580,16 +497,13 @@
 
 	return &vnode->vfs_inode;
 } /* end afs_alloc_inode() */
-#endif
 
 /*****************************************************************************/
 /*
  * destroy an AFS inode struct
  */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 static void afs_destroy_inode(struct inode *inode)
 {
 	_enter("{%lu}",inode->i_ino);
 	kmem_cache_free(afs_inode_cachep, AFS_FS_I(inode));
 } /* end afs_destroy_inode() */
-#endif
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/vlclient.c /inst-afs/devel/afs/fs/afs/vlclient.c
--- linux-2.5.43/fs/afs/vlclient.c	2002-10-16 09:25:59.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/vlclient.c	2002-10-16 12:39:21.000000000 +0100
@@ -626,7 +626,7 @@
 	case RXRPC_CSTATE_CLNT_GOT_REPLY:
 		if (call->app_read_count==0)
 			break;
-		printk("kAFS: Reply bigger than expected {cst=%u asyn=%d mark=%d rdy=%u pr=%u%s}",
+		printk("kAFS: Reply bigger than expected {cst=%u asyn=%d mark=%Zu rdy=%Zu pr=%u%s}",
 		       call->app_call_state,
 		       call->app_async_read,
 		       call->app_mark,
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/fs/afs/vnode.h /inst-afs/devel/afs/fs/afs/vnode.h
--- linux-2.5.43/fs/afs/vnode.h	2002-10-16 09:26:00.000000000 +0100
+++ /inst-afs/devel/afs/fs/afs/vnode.h	2002-10-16 13:36:35.000000000 +0100
@@ -27,11 +27,7 @@
  */
 struct afs_vnode
 {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct inode		vfs_inode;	/* the VFS's inode record */
-#else
-	struct inode		*inode;		/* the VFS's inode */
-#endif
 
 	afs_volume_t		*volume;	/* volume on which vnode resides */
 	afs_fid_t		fid;		/* the file identifier for this inode */
@@ -59,20 +55,12 @@
 
 static inline afs_vnode_t *AFS_FS_I(struct inode *inode)
 {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-	return list_entry(inode,afs_vnode_t,vfs_inode);
-#else
-	return inode->u.generic_ip;
-#endif
+	return container_of(inode,afs_vnode_t,vfs_inode);
 }
 
 static inline struct inode *AFS_VNODE_TO_I(afs_vnode_t *vnode)
 {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	return &vnode->vfs_inode;
-#else
-	return vnode->inode;
-#endif
 }
 
 extern int afs_vnode_fetch_status(afs_vnode_t *vnode);
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/net/rxrpc/call.c /inst-afs/devel/afs/net/rxrpc/call.c
--- linux-2.5.43/net/rxrpc/call.c	2002-10-16 09:26:05.000000000 +0100
+++ /inst-afs/devel/afs/net/rxrpc/call.c	2002-10-16 12:45:13.000000000 +0100
@@ -1005,7 +1005,7 @@
 	}
 
 	/* next in sequence - simply append into the call's ready queue */
-	_debug("Call add packet %d to readyq (+%d => %d bytes)",
+	_debug("Call add packet %d to readyq (+%Zd => %Zd bytes)",
 	       msg->seq,msg->dsize,call->app_ready_qty);
 
 	spin_lock(&call->lock);
@@ -1021,7 +1021,7 @@
 			break;
 
 		/* next in sequence - just move list-to-list */
-		_debug("Call transfer packet %d to readyq (+%d => %d bytes)",
+		_debug("Call transfer packet %d to readyq (+%Zd => %Zd bytes)",
 		       pmsg->seq,pmsg->dsize,call->app_ready_qty);
 
 		call->app_ready_seq = pmsg->seq;
@@ -1156,7 +1156,7 @@
 	/* otherwise just invoke the data function whenever we can satisfy its desire for more
 	 * data
 	 */
-	_proto("Rx Received Op Data: st=%u qty=%u mk=%u%s",
+	_proto("Rx Received Op Data: st=%u qty=%Zu mk=%Zu%s",
 	       call->app_call_state,call->app_ready_qty,call->app_mark,
 	       call->app_last_rcv ? " last-rcvd" : "");
 
@@ -1394,7 +1394,7 @@
 	char resend, now_complete;
 	u8 acks[16];
 
-	_enter("%p{apc=%u ads=%u},%p,%u,%u",
+	_enter("%p{apc=%u ads=%u},%p,%u,%Zu",
 	       call,call->acks_pend_cnt,call->acks_dftv_seq,msg,seq,count);
 
 	/* handle re-ACK'ing of definitively ACK'd packets (may be out-of-order ACKs) */
@@ -1443,7 +1443,7 @@
 		}
 
 		_proto("Rx ACK of packets #%u-#%u [%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c] (pend=%u)",
-		       seq,seq+chunk-1,
+		       seq,(unsigned)(seq+chunk-1),
 		       _acktype[acks[0x0]],
 		       _acktype[acks[0x1]],
 		       _acktype[acks[0x2]],
@@ -1552,7 +1552,7 @@
 	size_t qty;
 	int ret;
 
-	_enter("%p{as=%d buf=%p qty=%u/%u}",
+	_enter("%p{as=%d buf=%p qty=%Zu/%Zu}",
 	       call,call->app_async_read,call->app_read_buf,call->app_ready_qty,call->app_mark);
 
 	/* check the state */
@@ -1560,7 +1560,7 @@
 	case RXRPC_CSTATE_SRVR_RCV_ARGS:
 	case RXRPC_CSTATE_CLNT_RCV_REPLY:
 		if (call->app_last_rcv) {
-			printk("%s(%p,%p,%d): Inconsistent call state (%s, last pkt)",
+			printk("%s(%p,%p,%Zd): Inconsistent call state (%s, last pkt)",
 			      __FUNCTION__,call,call->app_read_buf,call->app_mark,
 			      rxrpc_call_states[call->app_call_state]);
 			BUG();
@@ -1574,7 +1574,7 @@
 
 	case RXRPC_CSTATE_SRVR_SND_REPLY:
 		if (!call->app_last_rcv) {
-			printk("%s(%p,%p,%d): Inconsistent call state (%s, not last pkt)",
+			printk("%s(%p,%p,%Zd): Inconsistent call state (%s, not last pkt)",
 			      __FUNCTION__,call,call->app_read_buf,call->app_mark,
 			      rxrpc_call_states[call->app_call_state]);
 			BUG();
@@ -1616,11 +1616,11 @@
 		/* drag as much data as we need out of this packet */
 		qty = min(call->app_mark,msg->dsize);
 
-		_debug("reading %u from skb=%p off=%lu",qty,msg->pkt,msg->offset);
+		_debug("reading %Zu from skb=%p off=%lu",qty,msg->pkt,msg->offset);
 
 		if (call->app_read_buf)
 			if (skb_copy_bits(msg->pkt,msg->offset,call->app_read_buf,qty)<0)
-				panic("%s: Failed to copy data from packet: (%p,%p,%d)",
+				panic("%s: Failed to copy data from packet: (%p,%p,%Zd)",
 				      __FUNCTION__,call,call->app_read_buf,qty);
 
 		/* if that packet is now empty, discard it */
@@ -1673,7 +1673,7 @@
 	}
 
 	if (call->app_last_rcv) {
-		_debug("Insufficient data (%u/%u)",call->app_ready_qty,call->app_mark);
+		_debug("Insufficient data (%Zu/%Zu)",call->app_ready_qty,call->app_mark);
 		call->app_async_read = 0;
 		call->app_mark = RXRPC_APP_MARK_EOF;
 		call->app_read_buf = NULL;
@@ -1703,7 +1703,7 @@
 {
 	int ret;
 
-	_enter("%p{arq=%u},%p,%d,%x",call,call->app_ready_qty,buffer,size,flags);
+	_enter("%p{arq=%Zu},%p,%Zd,%x",call,call->app_ready_qty,buffer,size,flags);
 
 	spin_lock(&call->lock);
 
@@ -1799,7 +1799,7 @@
 	char *buf;
 	int ret;
 
-	_enter("%p,%u,%p,%02x,%x,%d,%p",call,sioc,siov,rxhdr_flags,alloc_flags,dup_data,size_sent);
+	_enter("%p,%Zu,%p,%02x,%x,%d,%p",call,sioc,siov,rxhdr_flags,alloc_flags,dup_data,size_sent);
 
 	*size_sent = 0;
 	size = 0;
@@ -1827,7 +1827,7 @@
 		size += sptr->iov_len;
 	}
 
-	_debug("- size=%u mtu=%u",size,call->conn->mtu_size);
+	_debug("- size=%Zu mtu=%Zu",size,call->conn->mtu_size);
 
 	do {
 		/* make sure there's a message under construction */
@@ -1837,7 +1837,7 @@
 						0,NULL,alloc_flags,&call->snd_nextmsg);
 			if (ret<0)
 				goto out;
-			_debug("- allocated new message [ds=%u]",call->snd_nextmsg->dsize);
+			_debug("- allocated new message [ds=%Zu]",call->snd_nextmsg->dsize);
 		}
 
 		msg = call->snd_nextmsg;
@@ -1857,7 +1857,7 @@
 		space = call->conn->mtu_size - msg->dsize;
 		chunk = min(space,size);
 
-		_debug("- [before] space=%u chunk=%u",space,chunk);
+		_debug("- [before] space=%Zu chunk=%Zu",space,chunk);
 
 		while (!siov->iov_len)
 			siov++;
@@ -1916,7 +1916,7 @@
 			}
 		}
 
-		_debug("- [loaded] chunk=%u size=%u",chunk,size);
+		_debug("- [loaded] chunk=%Zu size=%Zu",chunk,size);
 
 		/* dispatch the message when full, final or requesting ACK */
 		if (msg->dsize>=call->conn->mtu_size || rxhdr_flags) {
@@ -1929,7 +1929,7 @@
 
 	ret = 0;
  out:
-	_leave(" = %d (%d queued, %d rem)",ret,*size_sent,size);
+	_leave(" = %d (%Zd queued, %Zd rem)",ret,*size_sent,size);
 	return ret;
 
 } /* end rxrpc_call_write_data() */
@@ -1960,7 +1960,7 @@
 			msg->hdr.flags |= RXRPC_MORE_PACKETS;
 		}
 
-		_proto("Sending DATA message { ds=%u dc=%u df=%02lu }",
+		_proto("Sending DATA message { ds=%Zu dc=%u df=%02lu }",
 		       msg->dsize,msg->dcount,msg->dfree);
 
 		/* queue and adjust call state */
@@ -2061,7 +2061,7 @@
 		spin_unlock(&call->lock);
 
 		/* send each message again (and ignore any errors we might incur) */
-		_proto("Resending DATA message { ds=%u dc=%u df=%02lu }",
+		_proto("Resending DATA message { ds=%Zu dc=%u df=%02lu }",
 		       msg->dsize,msg->dcount,msg->dfree);
 
 		if (rxrpc_conn_sendmsg(call->conn,msg)==0)
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/net/rxrpc/connection.c /inst-afs/devel/afs/net/rxrpc/connection.c
--- linux-2.5.43/net/rxrpc/connection.c	2002-10-16 09:26:05.000000000 +0100
+++ /inst-afs/devel/afs/net/rxrpc/connection.c	2002-10-16 12:39:21.000000000 +0100
@@ -121,7 +121,7 @@
 	conn->out_epoch		= rxrpc_epoch;
 	conn->in_clientflag	= 0;
 	conn->out_clientflag	= RXRPC_CLIENT_INITIATED;
-	conn->conn_id		= htonl((unsigned) conn & RXRPC_CIDMASK);
+	conn->conn_id		= htonl((unsigned long) conn & RXRPC_CIDMASK);
 	conn->service_id	= htons(service_id);
 
 	/* attach to peer */
@@ -547,7 +547,7 @@
 	msghdr.msg_controllen	= 0;
 	msghdr.msg_flags	= MSG_CONFIRM|MSG_DONTWAIT;
 
-	_net("Sending message type %d of %d bytes to %08x:%d",
+	_net("Sending message type %d of %Zd bytes to %08x:%d",
 	     msg->hdr.type,
 	     msg->dsize,
 	     htonl(conn->addr.sin_addr.s_addr),
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/net/rxrpc/internal.h /inst-afs/devel/afs/net/rxrpc/internal.h
--- linux-2.5.43/net/rxrpc/internal.h	2002-10-16 09:26:05.000000000 +0100
+++ /inst-afs/devel/afs/net/rxrpc/internal.h	2002-10-16 12:39:21.000000000 +0100
@@ -29,24 +29,24 @@
 /*
  * debug tracing
  */
-#define kenter(FMT,...)	printk("==> %s("FMT")\n",__FUNCTION__,##__VA_ARGS__)
-#define kleave(FMT,...)	printk("<== %s()"FMT"\n",__FUNCTION__,##__VA_ARGS__)
-#define kdebug(FMT,...)	printk("    "FMT"\n",##__VA_ARGS__)
-#define kproto(FMT,...)	printk("### "FMT"\n",##__VA_ARGS__)
-#define knet(FMT,...)	printk("    "FMT"\n",##__VA_ARGS__)
+#define kenter(FMT, a...)	printk("==> %s("FMT")\n",__FUNCTION__ , ##a)
+#define kleave(FMT, a...)	printk("<== %s()"FMT"\n",__FUNCTION__ , ##a)
+#define kdebug(FMT, a...)	printk("    "FMT"\n" , ##a)
+#define kproto(FMT, a...)	printk("### "FMT"\n" , ##a)
+#define knet(FMT, a...)		printk("    "FMT"\n" , ##a)
 
 #if 0
-#define _enter(FMT,...)	kenter(FMT,##__VA_ARGS__)
-#define _leave(FMT,...)	kleave(FMT,##__VA_ARGS__)
-#define _debug(FMT,...)	kdebug(FMT,##__VA_ARGS__)
-#define _proto(FMT,...)	kproto(FMT,##__VA_ARGS__)
-#define _net(FMT,...)	knet(FMT,##__VA_ARGS__)
+#define _enter(FMT, a...)	kenter(FMT , ##a)
+#define _leave(FMT, a...)	kleave(FMT , ##a)
+#define _debug(FMT, a...)	kdebug(FMT , ##a)
+#define _proto(FMT, a...)	kproto(FMT , ##a)
+#define _net(FMT, a...)		knet(FMT , ##a)
 #else
-#define _enter(FMT,...)	do { if (rxrpc_ktrace) kenter(FMT,##__VA_ARGS__); } while(0)
-#define _leave(FMT,...)	do { if (rxrpc_ktrace) kleave(FMT,##__VA_ARGS__); } while(0)
-#define _debug(FMT,...)	do { if (rxrpc_kdebug) kdebug(FMT,##__VA_ARGS__); } while(0)
-#define _proto(FMT,...)	do { if (rxrpc_kproto) kproto(FMT,##__VA_ARGS__); } while(0)
-#define _net(FMT,...)	do { if (rxrpc_knet)   knet  (FMT,##__VA_ARGS__); } while(0)
+#define _enter(FMT, a...)	do { if (rxrpc_ktrace) kenter(FMT , ##a); } while(0)
+#define _leave(FMT, a...)	do { if (rxrpc_ktrace) kleave(FMT , ##a); } while(0)
+#define _debug(FMT, a...)	do { if (rxrpc_kdebug) kdebug(FMT , ##a); } while(0)
+#define _proto(FMT, a...)	do { if (rxrpc_kproto) kproto(FMT , ##a); } while(0)
+#define _net(FMT, a...)		do { if (rxrpc_knet)   knet  (FMT , ##a); } while(0)
 #endif
 
 static inline void rxrpc_discard_my_signals(void)
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/net/rxrpc/krxiod.c /inst-afs/devel/afs/net/rxrpc/krxiod.c
--- linux-2.5.43/net/rxrpc/krxiod.c	2002-10-16 09:26:05.000000000 +0100
+++ /inst-afs/devel/afs/net/rxrpc/krxiod.c	2002-10-16 13:37:27.000000000 +0100
@@ -49,11 +49,7 @@
 	/* only certain signals are of interest */
 	spin_lock_irq(&current->sig->siglock);
 	siginitsetinv(&current->blocked,0);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,3)
 	recalc_sigpending();
-#else
-	recalc_sigpending(current);
-#endif
 	spin_unlock_irq(&current->sig->siglock);
 
 	/* loop around waiting for work to do */
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/net/rxrpc/krxsecd.c /inst-afs/devel/afs/net/rxrpc/krxsecd.c
--- linux-2.5.43/net/rxrpc/krxsecd.c	2002-10-16 09:26:05.000000000 +0100
+++ /inst-afs/devel/afs/net/rxrpc/krxsecd.c	2002-10-16 13:37:32.000000000 +0100
@@ -61,11 +61,7 @@
 	/* only certain signals are of interest */
 	spin_lock_irq(&current->sig->siglock);
 	siginitsetinv(&current->blocked,0);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,3)
 	recalc_sigpending();
-#else
-	recalc_sigpending(current);
-#endif
 	spin_unlock_irq(&current->sig->siglock);
 
 	/* loop around waiting for work to do */
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/net/rxrpc/krxtimod.c /inst-afs/devel/afs/net/rxrpc/krxtimod.c
--- linux-2.5.43/net/rxrpc/krxtimod.c	2002-10-16 09:26:05.000000000 +0100
+++ /inst-afs/devel/afs/net/rxrpc/krxtimod.c	2002-10-16 13:37:36.000000000 +0100
@@ -79,11 +79,7 @@
 	/* only certain signals are of interest */
 	spin_lock_irq(&current->sig->siglock);
 	siginitsetinv(&current->blocked,0);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,3)
 	recalc_sigpending();
-#else
-	recalc_sigpending(current);
-#endif
 	spin_unlock_irq(&current->sig->siglock);
 
 	/* loop around looking for things to attend to */
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/net/rxrpc/main.c /inst-afs/devel/afs/net/rxrpc/main.c
--- linux-2.5.43/net/rxrpc/main.c	2002-10-16 09:26:05.000000000 +0100
+++ /inst-afs/devel/afs/net/rxrpc/main.c	2002-10-16 12:39:21.000000000 +0100
@@ -123,5 +123,5 @@
 	__RXACCT(printk("Outstanding Peers      : %d\n",atomic_read(&rxrpc_peer_count)));
 	__RXACCT(printk("Outstanding Transports : %d\n",atomic_read(&rxrpc_transport_count)));
 
-	kleave();
+	kleave("");
 } /* end rxrpc_cleanup() */
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/net/rxrpc/Makefile /inst-afs/devel/afs/net/rxrpc/Makefile
--- linux-2.5.43/net/rxrpc/Makefile	2002-10-16 09:26:05.000000000 +0100
+++ /inst-afs/devel/afs/net/rxrpc/Makefile	2002-10-16 13:29:44.000000000 +0100
@@ -15,19 +15,13 @@
 	rxrpc_syms.o \
 	transport.o
 
-#ifeq ($(CONFIG_PROC_FS),y)
-rxrpc-objs	+= proc.o
-#endif
-#ifeq ($(CONFIG_SYSCTL),y)
+ifeq ($(CONFIG_PROC_FS),y)
+rxrpc-objs += proc.o
+endif
+ifeq ($(CONFIG_SYSCTL),y)
 rxrpc-objs += sysctl.o
-#endif
+endif
 
 obj-m  := rxrpc.o
 
-# superfluous for 2.5, but needed for 2.4..
-ifeq "$(VERSION).$(PATCHLEVEL)" "2.4"
-rxrpc.o: $(rxrpc-objs)
-	$(LD) -r -o $@ $(rxrpc-objs)
-endif
-
 include $(TOPDIR)/Rules.make
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/net/rxrpc/peer.c /inst-afs/devel/afs/net/rxrpc/peer.c
--- linux-2.5.43/net/rxrpc/peer.c	2002-10-16 09:26:05.000000000 +0100
+++ /inst-afs/devel/afs/net/rxrpc/peer.c	2002-10-16 12:39:21.000000000 +0100
@@ -375,6 +375,6 @@
 
 	peer->rtt = do_div(rtt,peer->rtt_usage);
 
-	_leave(" RTT=%lu.%lums",peer->rtt/1000,peer->rtt%1000);
+	_leave(" RTT=%lu.%lums",(long)(peer->rtt/1000),(long)(peer->rtt%1000));
 
 } /* end rxrpc_peer_calculate_rtt() */
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/net/rxrpc/proc.c /inst-afs/devel/afs/net/rxrpc/proc.c
--- linux-2.5.43/net/rxrpc/proc.c	2002-10-16 09:26:05.000000000 +0100
+++ /inst-afs/devel/afs/net/rxrpc/proc.c	2002-10-16 13:37:40.000000000 +0100
@@ -22,13 +22,6 @@
 #include <rxrpc/message.h>
 #include "internal.h"
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-static inline struct proc_dir_entry *PDE(const struct inode *inode)
-{
-	return (struct proc_dir_entry *)inode->u.generic_ip;
-}
-#endif
-
 static struct proc_dir_entry *proc_rxrpc;
 
 static int rxrpc_proc_transports_open(struct inode *inode, struct file *file);
@@ -379,14 +372,14 @@
 	if (!list_empty(&peer->timeout.link))
 		timeout = (signed long)peer->timeout.timo_jif - (signed long)jiffies;
 
-	seq_printf(m,"%5hu %08x %5d %5d %8ld %5u %7lu\n",
+	seq_printf(m,"%5hu %08x %5d %5d %8ld %5Zu %7lu\n",
 		   peer->trans->port,
 		   ntohl(peer->addr.s_addr),
 		   atomic_read(&peer->usage),
 		   atomic_read(&peer->conn_count),
 		   timeout,
 		   peer->if_mtu,
-		   peer->rtt
+		   (long) peer->rtt
 		   );
 
 	return 0;
@@ -484,7 +477,7 @@
 	if (!list_empty(&conn->timeout.link))
 		timeout = (signed long)conn->timeout.timo_jif - (signed long)jiffies;
 
-	seq_printf(m,"%5hu %08x %5hu %04hx %08x %-3.3s %08x %08x %5u %8ld\n",
+	seq_printf(m,"%5hu %08x %5hu %04hx %08x %-3.3s %08x %08x %5Zu %8ld\n",
 		   conn->trans->port,
 		   ntohl(conn->addr.sin_addr.s_addr),
 		   ntohs(conn->addr.sin_port),
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/net/rxrpc/transport.c /inst-afs/devel/afs/net/rxrpc/transport.c
--- linux-2.5.43/net/rxrpc/transport.c	2002-10-16 09:26:05.000000000 +0100
+++ /inst-afs/devel/afs/net/rxrpc/transport.c	2002-10-16 12:46:26.000000000 +0100
@@ -691,12 +691,12 @@
 		msg.msg_controllen = (char*)msg.msg_control - (char*)&emsg;
 
 		if (msg.msg_controllen<sizeof(emsg.cmsg) || msg.msg_namelen<sizeof(sin)) {
-			printk("%s: short control message (nlen=%u clen=%u fl=%x)\n",
+			printk("%s: short control message (nlen=%u clen=%Zu fl=%x)\n",
 			       __FUNCTION__,msg.msg_namelen,msg.msg_controllen,msg.msg_flags);
 			continue;
 		}
 
-		_net("Rx Received control message { len=%u level=%u type=%u }",
+		_net("Rx Received control message { len=%Zu level=%u type=%u }",
 		     emsg.cmsg.cmsg_len,emsg.cmsg.cmsg_level,emsg.cmsg.cmsg_type);
 
 		if (sin.sin_family!=AF_INET) {
@@ -715,7 +715,7 @@
 		}
 
 		if (msg.msg_controllen<sizeof(emsg.cmsg)+sizeof(emsg.ee)) {
-			printk("%s: short error message (%u)\n",__FUNCTION__,msg.msg_controllen);
+			printk("%s: short error message (%Zu)\n",__FUNCTION__,msg.msg_controllen);
 			_leave("");
 			return;
 		}
diff -ur -x '*.o' -x '*.cmd' -x '*~' linux-2.5.43/include/rxrpc/call.h /inst-afs/devel/afs/include/rxrpc/call.h
--- linux-2.5.43/include/rxrpc/call.h	2002-10-16 09:26:02.000000000 +0100
+++ /inst-afs/devel/afs/include/rxrpc/call.h	2002-10-16 12:39:21.000000000 +0100
@@ -153,7 +153,7 @@
 	(CALL)->app_scr_alloc += (SIZE);						\
 	if ((SIZE)>RXRPC_CALL_SCRATCH_SIZE ||						\
 	    (size_t)((CALL)->app_scr_alloc - (u8*)(CALL)) > RXRPC_CALL_SCRATCH_SIZE) {	\
-		printk("rxrpc_call_alloc_scratch(%p,%u)\n",(CALL),(SIZE));		\
+		printk("rxrpc_call_alloc_scratch(%p,%Zu)\n",(CALL),(size_t)(SIZE));	\
 		BUG();									\
 	}										\
 	ptr;										\
@@ -167,7 +167,7 @@
 	(CALL)->app_scr_alloc += size;							\
 	if (size>RXRPC_CALL_SCRATCH_SIZE ||						\
 	    (size_t)((CALL)->app_scr_alloc - (u8*)(CALL)) > RXRPC_CALL_SCRATCH_SIZE) {	\
-		printk("rxrpc_call_alloc_scratch(%p,%u)\n",(CALL),size);		\
+		printk("rxrpc_call_alloc_scratch(%p,%Zu)\n",(CALL),size);		\
 		BUG();									\
 	}										\
 	ptr;										\

