Return-Path: <linux-kernel-owner+willy=40w.ods.org-S1030193AbWJRKZB@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1030193AbWJRKZB (ORCPT <rfc822;willy@w.ods.org>);
	Wed, 18 Oct 2006 06:25:01 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S1030187AbWJRKY7
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Wed, 18 Oct 2006 06:24:59 -0400
Received: from mail.suse.de ([195.135.220.2]:23722 "EHLO mx1.suse.de")
	by vger.kernel.org with ESMTP id S1751455AbWJRKY6 (ORCPT
	<rfc822;linux-kernel@vger.kernel.org>);
	Wed, 18 Oct 2006 06:24:58 -0400
Date: Wed, 18 Oct 2006 12:24:54 +0200
Message-ID: <s5hmz7tapl5.wl%tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: Prakash Punnoor <prakash@punnoor.de>
Cc: Adrian Bunk <bunk@stusta.de>, alsa-devel@alsa-project.org,
       linux-kernel@vger.kernel.org, mingo@redhat.com, hnguyen@de.ibm.com,
       Stephen Hemminger <shemminger@osdl.org>, perex@suse.cz
Subject: Re: [Alsa-devel] [RFC: 2.6.19 patch] snd-hda-intel: default MSI to	off
In-Reply-To: <20061017144053.29b6b29c@freekitty>
References: <200610050938.10997.prakash@punnoor.de>
	<5aa69f860610051030l7323ec2el545873570052f077@mail.gmail.com>
	<200610052309.01155.prakash@punnoor.de>
	<20061017211301.GE3502@stusta.de>
	<20061017144053.29b6b29c@freekitty>
User-Agent: Wanderlust/2.12.0 (Your Wildest Dreams) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.7 (=?ISO-8859-4?Q?Sanj=F2?=) APEL/10.6 MULE XEmacs/21.5 (beta25)
 (eggplant) (+CVS-20060326) (i386-suse-linux)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

At Tue, 17 Oct 2006 14:40:53 -0700,
Stephen Hemminger wrote:
> 
> On Tue, 17 Oct 2006 23:13:01 +0200
> Adrian Bunk <bunk@stusta.de> wrote:
> 
> > On Thu, Oct 05, 2006 at 11:08:57PM +0200, Prakash Punnoor wrote:
> > > Am Donnerstag 05 Oktober 2006 19:30 schrieb Fatih A????c??:
> > > > 2006/10/5, Prakash Punnoor <prakash@punnoor.de>:
> > > > > Hi,
> > > > >
> > > > > subjects say it all. Without irqpoll my nic doesn't work anymore. I added
> > > > > Ingo
> > > > > to cc, as my IRQs look different, so it may be a prob of APIC routing or
> > > > > the
> > > > > like.
> > > 
> > > > > Can you try booting with pci=nomsi ? I have a similar problem with my
> > > 
> > > I used snd-hda-intel.disable_msi=1 and this actually helped! Now the nforce 
> > > nic works w/o problems. So it was the audio driver causing havoc on the nic. 
> > >...
> > 
> > Unless someone finds and fixes what causes such problems, I'd therefore 
> > suggest the patch below to let MSI support to be turned off by default.
> > 
> > cu
> > Adrian
> > 
> 
> It shouldn't be that hard to write a small bit of code to force an interrupt
> and catch it, that's what other drivers do to workaround the BIOS braindamage
> that seems to be rampant (until M$ Vista comes out and supports MSI).

OK, what about a patch like below?

It's against the latest ALSA tree, so please pull alsa.git from
	git://kernel.org/pub/scm/linux/kernel/git/perex/alsa.git
before applying it (this tree includes only patches to be pushed to
2.6.19).


Takashi

diff -r 0047a372140b pci/hda/hda_intel.c
--- a/pci/hda/hda_intel.c	Tue Oct 17 20:41:38 2006 +0200
+++ b/pci/hda/hda_intel.c	Wed Oct 18 11:12:01 2006 +0200
@@ -337,6 +337,7 @@ struct azx {
 	unsigned int initialized :1;
 	unsigned int single_cmd :1;
 	unsigned int polling_mode :1;
+	unsigned int msi :1;
 };
 
 /* driver types */
@@ -397,6 +398,7 @@ static char *driver_short_names[] __devi
  */
 #define upper_32bit(addr) (sizeof(addr) > 4 ? (u32)((addr) >> 32) : (u32)0)
 
+static int azx_acquire_irq(struct azx *chip);
 
 /*
  * Interface for HD codec
@@ -535,6 +537,18 @@ static unsigned int azx_rirb_get_respons
 			return chip->rirb.res; /* the last value */
 		schedule_timeout_interruptible(1);
 	} while (time_after_eq(timeout, jiffies));
+
+	if (chip->msi) {
+		snd_printk(KERN_WARNING "hda_intel: No response from codec, "
+			   "disabling MSI...\n");
+		free_irq(chip->irq, chip);
+		chip->irq = -1;
+		pci_disable_msi(chip->pci);
+		chip->msi = 0;
+		if (azx_acquire_irq(chip) < 0)
+			return -1;
+		goto again;
+	}
 
 	if (!chip->polling_mode) {
 		snd_printk(KERN_WARNING "hda_intel: azx_get_response timeout, "
@@ -1364,6 +1378,19 @@ static int __devinit azx_init_stream(str
 	return 0;
 }
 
+static int azx_acquire_irq(struct azx *chip)
+{
+	if (request_irq(chip->pci->irq, azx_interrupt, IRQF_DISABLED|IRQF_SHARED,
+			"HDA Intel", chip)) {
+		printk(KERN_ERR "hda-intel: unable to grab IRQ %d, "
+		       "disabling device\n", chip->pci->irq);
+		snd_card_disconnect(chip->card);
+		return -1;
+	}
+	chip->irq = chip->pci->irq;
+	return 0;
+}
+
 
 #ifdef CONFIG_PM
 /*
@@ -1385,7 +1412,7 @@ static int azx_suspend(struct pci_dev *p
 		free_irq(chip->irq, chip);
 		chip->irq = -1;
 	}
-	if (!disable_msi)
+	if (chip->msi)
 		pci_disable_msi(chip->pci);
 	pci_disable_device(pci);
 	pci_save_state(pci);
@@ -1407,16 +1434,10 @@ static int azx_resume(struct pci_dev *pc
 		return -EIO;
 	}
 	pci_set_master(pci);
-	if (!disable_msi)
+	if (chip->msi)
 		pci_enable_msi(pci);
-	if (request_irq(pci->irq, azx_interrupt, IRQF_DISABLED|IRQF_SHARED,
-			"HDA Intel", chip)) {
-		printk(KERN_ERR "hda-intel: unable to grab IRQ %d, "
-		       "disabling device\n", pci->irq);
-		snd_card_disconnect(card);
+	if (azx_acquire_irq(chip) < 0)
 		return -EIO;
-	}
-	chip->irq = pci->irq;
 	azx_init_chip(chip);
 	snd_hda_resume(chip->bus);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
@@ -1452,7 +1473,7 @@ static int azx_free(struct azx *chip)
 		synchronize_irq(chip->irq);
 		free_irq(chip->irq, (void*)chip);
 	}
-	if (!disable_msi)
+	if (chip->msi)
 		pci_disable_msi(chip->pci);
 	if (chip->remap_addr)
 		iounmap(chip->remap_addr);
@@ -1508,6 +1529,7 @@ static int __devinit azx_create(struct s
 	chip->pci = pci;
 	chip->irq = -1;
 	chip->driver_type = driver_type;
+	chip->msi = !disable_msi;
 
 	chip->position_fix = position_fix;
 	chip->single_cmd = single_cmd;
@@ -1537,7 +1559,7 @@ static int __devinit azx_create(struct s
 		goto errout;
 	}
 
-	if (!disable_msi)
+	if (chip->msi)
 		pci_enable_msi(pci);
 
 	if (request_irq(pci->irq, azx_interrupt, IRQF_DISABLED|IRQF_SHARED,
