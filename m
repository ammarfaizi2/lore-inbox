Return-Path: <linux-kernel-owner+willy=40w.ods.org-S264579AbUFXOhv@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S264579AbUFXOhv (ORCPT <rfc822;willy@w.ods.org>);
	Thu, 24 Jun 2004 10:37:51 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S264658AbUFXOhv
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Thu, 24 Jun 2004 10:37:51 -0400
Received: from cantor.suse.de ([195.135.220.2]:17128 "EHLO Cantor.suse.de")
	by vger.kernel.org with ESMTP id S264579AbUFXOhs (ORCPT
	<rfc822;linux-kernel@vger.kernel.org>);
	Thu, 24 Jun 2004 10:37:48 -0400
Date: Thu, 24 Jun 2004 16:36:47 +0200
Message-ID: <s5h4qp1hvk0.wl@alsa2.suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: Andi Kleen <ak@suse.de>
Cc: Andi Kleen <ak@muc.de>, Terence Ripperda <tripperda@nvidia.com>,
       discuss@x86-64.org, linux-kernel@vger.kernel.org, andrea@suse.de
Subject: Re: [discuss] Re: 32-bit dma allocations on 64-bit platforms
In-Reply-To: <20040624112900.GE16727@wotan.suse.de>
References: <m3acyu6pwd.fsf@averell.firstfloor.org>
	<20040623213643.GB32456@hygelac>
	<20040623234644.GC38425@colin2.muc.de>
	<s5hhdt1i4yc.wl@alsa2.suse.de>
	<20040624112900.GE16727@wotan.suse.de>
User-Agent: Wanderlust/2.10.1 (Watching The Wheels) SEMI/1.14.5 (Awara-Onsen) FLIM/1.14.5 (Demachiyanagi) APEL/10.6 MULE XEmacs/21.4 (patch 15) (Security Through Obscurity) (i386-suse-linux)
MIME-Version: 1.0 (generated by SEMI 1.14.5 - "Awara-Onsen")
Content-Type: text/plain; charset=US-ASCII
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

At Thu, 24 Jun 2004 13:29:00 +0200,
Andi Kleen wrote:
> 
> > Can't it be called with GFP_KERNEL at first, then with GFP_DMA if the
> > allocated pages are out of dma mask, just like in pci-gart.c?
> > (with ifdef x86-64)
> 
> That won't work reliable enough in extreme cases.

Well, it's not perfect, but it'd be far better than GFP_DMA only :)


BTW, we have the similar problem on i386, too.  The non-32bit DMA mask
always results in the allocation with GFP_DMA.  The patch below does
similar hack as described above, calling with GFP_DMA as fallback.


Takashi

--- linux-2.6.7/arch/i386/kernel/pci-dma.c	2004-06-24 15:56:46.017473544 +0200
+++ linux-2.6.7/arch/i386/kernel/pci-dma.c	2004-06-24 16:05:02.449803937 +0200
@@ -17,17 +17,35 @@ void *dma_alloc_coherent(struct device *
 			   dma_addr_t *dma_handle, int gfp)
 {
 	void *ret;
+	unsigned long dma_mask;
+
 	/* ignore region specifiers */
 	gfp &= ~(__GFP_DMA | __GFP_HIGHMEM);
 
-	if (dev == NULL || (dev->coherent_dma_mask < 0xffffffff))
+	if (dev == NULL) {
 		gfp |= GFP_DMA;
+		dma_mask = 0xffffffUL;
+	} else {
+		dma_mask = 0xffffffffUL;
+		if (dev->dma_mask)
+			dma_mask = *dev->dma_mask;
+		if (dev->coherent_dma_mask)
+			dma_mask &= (unsigned long)dev->coherent_dma_mask;
+	}
 
+ again:
 	ret = (void *)__get_free_pages(gfp, get_order(size));
 
 	if (ret != NULL) {
-		memset(ret, 0, size);
 		*dma_handle = virt_to_phys(ret);
+		if (((unsigned long)*dma_handle + size - 1) & ~dma_mask) {
+			free_pages((unsigned long)ret, get_order(size));
+			if (gfp & GFP_DMA)
+				return NULL;
+			gfp |= GFP_DMA;
+			goto again;
+		}
+		memset(ret, 0, size);
 	}
 	return ret;
 }
