Return-Path: <linux-kernel-owner+willy=40w.ods.org@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S263847AbTFUNjz (ORCPT <rfc822;willy@w.ods.org>);
	Sat, 21 Jun 2003 09:39:55 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S264232AbTFUNj0
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Sat, 21 Jun 2003 09:39:26 -0400
Received: from twilight.ucw.cz ([81.30.235.3]:23714 "EHLO twilight.ucw.cz")
	by vger.kernel.org with ESMTP id S263847AbTFUNiD convert rfc822-to-8bit
	(ORCPT <rfc822;linux-kernel@vger.kernel.org>);
	Sat, 21 Jun 2003 09:38:03 -0400
Subject: [PATCH 6/11] input: Add Logitech MX PS2++ support
In-Reply-To: <10562035173709@twilight.ucw.cz>
X-Mailer: gregkh_patchbomb_levon_offspring
Date: Sat, 21 Jun 2003 15:51:57 +0200
Message-Id: <10562035171778@twilight.ucw.cz>
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
To: torvalds@transmeta.com, linux-kernel@vger.kernel.org
Content-Transfer-Encoding: 7BIT
From: Vojtech Pavlik <vojtech@ucw.cz>
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

You can pull this changeset from:
	bk://kernel.bkbits.net/vojtech/input

===================================================================

ChangeSet@1.1364, 2003-06-21 04:41:52-07:00, vojtech@kernel.bkbits.net
  input: Add Logitech MX PS2++ support, move Logitech PS2++ code to a
         separate source file, always enable Synaptics support. Some more
         fixes in Synaptics code and documentation.


 drivers/input/mouse/Kconfig        |   17 --
 drivers/input/mouse/Makefile       |    5 
 drivers/input/mouse/logips2pp.c    |  228 +++++++++++++++++++++++++++++++++++++
 drivers/input/mouse/logips2pp.h    |   17 ++
 drivers/input/mouse/psmouse-base.c |  193 +++++++++----------------------
 drivers/input/mouse/psmouse.h      |    2 
 drivers/input/mouse/synaptics.c    |    7 -
 drivers/input/mouse/synaptics.h    |   10 -
 include/linux/input.h              |    1 
 9 files changed, 315 insertions(+), 165 deletions(-)

===================================================================

diff -Nru a/drivers/input/mouse/Kconfig b/drivers/input/mouse/Kconfig
--- a/drivers/input/mouse/Kconfig	Sat Jun 21 15:25:29 2003
+++ b/drivers/input/mouse/Kconfig	Sat Jun 21 15:25:29 2003
@@ -19,7 +19,9 @@
 	  Say Y here if you have a PS/2 mouse connected to your system. This
 	  includes the standard 2 or 3-button PS/2 mouse, as well as PS/2
 	  mice with wheels and extra buttons, Microsoft, Logitech or Genius
-	  compatible.
+	  compatible. Support for Synaptics TouchPads is also included.
+	  For Synaptics TouchPad support in XFree86 you'll need this XFree86
+	  driver: http://w1.894.telia.com/~u89404340/touchpad/index.html
 
 	  If unsure, say Y.
 
@@ -27,19 +29,6 @@
 	  inserted in and removed from the running kernel whenever you want).
 	  The module will be called psmouse. If you want to compile it as a
 	  module, say M here and read <file:Documentation/modules.txt>.
-
-config MOUSE_PS2_SYNAPTICS
-	bool "Synaptics TouchPad"
-	default n
-	depends on INPUT && INPUT_MOUSE && SERIO && MOUSE_PS2
-	---help---
-	  Say Y here if you have a Synaptics TouchPad connected to your system.
-	  This touchpad is found on many modern laptop computers.
-	  Note that you also need a user space driver to interpret the data
-	  generated by the kernel. A compatible driver for XFree86 is available
-	  from http://...
-
-	  If unsure, say Y.
 
 config MOUSE_SERIAL
 	tristate "Serial mouse"
diff -Nru a/drivers/input/mouse/Makefile b/drivers/input/mouse/Makefile
--- a/drivers/input/mouse/Makefile	Sat Jun 21 15:25:29 2003
+++ b/drivers/input/mouse/Makefile	Sat Jun 21 15:25:29 2003
@@ -14,7 +14,4 @@
 obj-$(CONFIG_MOUSE_PS2)		+= psmouse.o
 obj-$(CONFIG_MOUSE_SERIAL)	+= sermouse.o
 
-psmouse-objs  := psmouse-base.o
-ifeq ($(CONFIG_MOUSE_PS2_SYNAPTICS),y)
-        psmouse-objs += synaptics.o
-endif
+psmouse-objs  := psmouse-base.o logips2pp.o synaptics.o
diff -Nru a/drivers/input/mouse/logips2pp.c b/drivers/input/mouse/logips2pp.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/input/mouse/logips2pp.c	Sat Jun 21 15:25:29 2003
@@ -0,0 +1,228 @@
+/*
+ * Logitech PS/2++ mouse driver
+ *
+ * Copyright (c) 1999-2003 Vojtech Pavlik <vojtech@suse.cz>
+ * Copyright (c) 2003 Eric Wong <eric@yhbt.net>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/input.h>
+#include "psmouse.h"
+#include "logips2pp.h"
+
+/*
+ * Process a PS2++ or PS2T++ packet.
+ */
+
+void ps2pp_process_packet(struct psmouse *psmouse)
+{
+	struct input_dev *dev = &psmouse->dev;
+        unsigned char *packet = psmouse->packet;
+
+	if ((packet[0] & 0x48) == 0x48 && (packet[1] & 0x02) == 0x02) {
+
+		switch ((packet[1] >> 4) | (packet[0] & 0x30)) {
+
+			case 0x0d: /* Mouse extra info */
+
+				input_report_rel(dev, packet[2] & 0x80 ? REL_HWHEEL : REL_WHEEL,
+					(int) (packet[2] & 8) - (int) (packet[2] & 7));
+				input_report_key(dev, BTN_SIDE, (packet[2] >> 4) & 1);
+				input_report_key(dev, BTN_EXTRA, (packet[2] >> 5) & 1);
+
+				break;
+
+			case 0x0e: /* buttons 4, 5, 6, 7, 8, 9, 10 info */
+
+				input_report_key(dev, BTN_SIDE, (packet[2]) & 1);
+				input_report_key(dev, BTN_EXTRA, (packet[2] >> 1) & 1);
+				input_report_key(dev, BTN_BACK, (packet[2] >> 3) & 1);
+				input_report_key(dev, BTN_FORWARD, (packet[2] >> 4) & 1);
+				input_report_key(dev, BTN_TASK, (packet[2] >> 2) & 1);
+
+				break;
+
+			case 0x0f: /* TouchPad extra info */
+
+				input_report_rel(dev, packet[2] & 0x08 ? REL_HWHEEL : REL_WHEEL,
+					(int) ((packet[2] >> 4) & 8) - (int) ((packet[2] >> 4) & 7));
+				packet[0] = packet[2] | 0x08;
+				break;
+
+#ifdef DEBUG
+			default:
+				printk(KERN_WARNING "psmouse.c: Received PS2++ packet #%x, but don't know how to handle.\n",
+					(packet[1] >> 4) | (packet[0] & 0x30));
+#endif
+		}
+
+		packet[0] &= 0x0f;
+		packet[1] = 0;
+		packet[2] = 0;
+
+	}
+}
+
+/*
+ * ps2pp_cmd() sends a PS2++ command, sliced into two bit
+ * pieces through the SETRES command. This is needed to send extended
+ * commands to mice on notebooks that try to understand the PS/2 protocol
+ * Ugly.
+ */
+
+static int ps2pp_cmd(struct psmouse *psmouse, unsigned char *param, unsigned char command)
+{
+	unsigned char d;
+	int i;
+
+	if (psmouse_command(psmouse,  NULL, PSMOUSE_CMD_SETSCALE11))
+		return -1;
+
+	for (i = 6; i >= 0; i -= 2) {
+		d = (command >> i) & 3;
+		if(psmouse_command(psmouse, &d, PSMOUSE_CMD_SETRES))
+			return -1;
+	}
+
+	if (psmouse_command(psmouse, param, PSMOUSE_CMD_POLL))
+		return -1;
+
+	return 0;
+}
+
+/*
+ * SmartScroll / CruiseControl for some newer Logitech mice Defaults to
+ * enabled if we do nothing to it. Of course I put this in because I want it
+ * disabled :P
+ * 1 - enabled (if previously disabled, also default)
+ * 0/2 - disabled 
+ */
+
+static void ps2pp_set_smartscroll(struct psmouse *psmouse)
+{
+	unsigned char param[4];
+
+	ps2pp_cmd(psmouse, param, 0x32);
+
+	param[0] = 0;
+	psmouse_command(psmouse, param, PSMOUSE_CMD_SETRES);
+	psmouse_command(psmouse, param, PSMOUSE_CMD_SETRES);
+	psmouse_command(psmouse, param, PSMOUSE_CMD_SETRES);
+
+	if (psmouse_smartscroll == 1) 
+		param[0] = 1;
+	else
+	if (psmouse_smartscroll > 2)
+		return;
+
+	/* else leave param[0] == 0 to disable */
+	psmouse_command(psmouse, param, PSMOUSE_CMD_SETRES);
+}
+
+/*
+ * Support 800 dpi resolution _only_ if the user wants it (there are good
+ * reasons to not use it even if the mouse supports it, and of course there are
+ * also good reasons to use it, let the user decide).
+ */
+
+void ps2pp_set_800dpi(struct psmouse *psmouse)
+{
+	unsigned char param = 3;
+	psmouse_command(psmouse, NULL, PSMOUSE_CMD_SETSCALE11);
+	psmouse_command(psmouse, NULL, PSMOUSE_CMD_SETSCALE11);
+	psmouse_command(psmouse, NULL, PSMOUSE_CMD_SETSCALE11);
+	psmouse_command(psmouse, &param, PSMOUSE_CMD_SETRES);
+}
+
+/*
+ * Detect the exact model and features of a PS2++ or PS2T++ Logitech mouse or
+ * touchpad.
+ */
+
+int ps2pp_detect_model(struct psmouse *psmouse, unsigned char param *param)
+{
+	int i;
+	static int logitech_4btn[] = { 12, 40, 41, 42, 43, 52, 73, 80, -1 };
+	static int logitech_wheel[] = { 52, 53, 75, 76, 80, 81, 83, 88, 112, -1 };
+	static int logitech_ps2pp[] = { 12, 13, 40, 41, 42, 43, 50, 51, 52, 53, 73, 75,
+						76, 80, 81, 83, 88, 96, 97, 112, -1 };
+	static int logitech_mx[] = { 112, -1 };
+
+	psmouse->vendor = "Logitech";
+	psmouse->model = ((param[0] >> 4) & 0x07) | ((param[0] << 3) & 0x78);
+
+	if (param[1] < 3)
+		clear_bit(BTN_MIDDLE, psmouse->dev.keybit);
+	if (param[1] < 2)
+		clear_bit(BTN_RIGHT, psmouse->dev.keybit);
+
+	psmouse->type = PSMOUSE_PS2;
+
+	for (i = 0; logitech_ps2pp[i] != -1; i++)
+		if (logitech_ps2pp[i] == psmouse->model)
+			psmouse->type = PSMOUSE_PS2PP;
+
+	if (psmouse->type == PSMOUSE_PS2PP) {
+
+		for (i = 0; logitech_4btn[i] != -1; i++)
+			if (logitech_4btn[i] == psmouse->model)
+				set_bit(BTN_SIDE, psmouse->dev.keybit);
+
+		for (i = 0; logitech_wheel[i] != -1; i++)
+			if (logitech_wheel[i] == psmouse->model) {
+				set_bit(REL_WHEEL, psmouse->dev.relbit);
+				psmouse->name = "Wheel Mouse";
+			}
+
+		for (i = 0; logitech_mx[i] != -1; i++)
+			if (logitech_mx[i]  == psmouse->model) {
+				set_bit(BTN_SIDE, psmouse->dev.keybit);
+				set_bit(BTN_EXTRA, psmouse->dev.keybit);
+				set_bit(BTN_BACK, psmouse->dev.keybit);
+				set_bit(BTN_FORWARD, psmouse->dev.keybit);
+				set_bit(BTN_TASK, psmouse->dev.keybit);
+				psmouse->name = "MX Mouse";
+			}
+
+/*
+ * Do Logitech PS2++ / PS2T++ magic init.
+ */
+
+		if (psmouse->model == 97) { /* TouchPad 3 */
+
+			set_bit(REL_WHEEL, psmouse->dev.relbit);
+			set_bit(REL_HWHEEL, psmouse->dev.relbit);
+
+			param[0] = 0x11; param[1] = 0x04; param[2] = 0x68; /* Unprotect RAM */
+			psmouse_command(psmouse, param, 0x30d1);
+			param[0] = 0x11; param[1] = 0x05; param[2] = 0x0b; /* Enable features */
+			psmouse_command(psmouse, param, 0x30d1);
+			param[0] = 0x11; param[1] = 0x09; param[2] = 0xc3; /* Enable PS2++ */
+			psmouse_command(psmouse, param, 0x30d1);
+
+			param[0] = 0;
+			if (!psmouse_command(psmouse, param, 0x13d1) &&
+				param[0] == 0x06 && param[1] == 0x00 && param[2] == 0x14) {
+				psmouse->name = "TouchPad 3";
+				return PSMOUSE_PS2TPP;
+			}
+
+		} else {
+
+			param[0] = param[1] = param[2] = 0;
+			ps2pp_cmd(psmouse, param, 0x39); /* Magic knock */
+			ps2pp_cmd(psmouse, param, 0xDB);
+
+			if ((param[0] & 0x78) == 0x48 && (param[1] & 0xf3) == 0xc2 &&
+				(param[2] & 3) == ((param[1] >> 2) & 3)) {
+					ps2pp_set_smartscroll(psmouse);
+					return PSMOUSE_PS2PP;
+			}
+		}
+	}
+
+	return 0;
+}
diff -Nru a/drivers/input/mouse/logips2pp.h b/drivers/input/mouse/logips2pp.h
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/input/mouse/logips2pp.h	Sat Jun 21 15:25:29 2003
@@ -0,0 +1,17 @@
+/*
+ * Logitech PS/2++ mouse driver header
+ *
+ * Copyright (c) 2003 Vojtech Pavlik <vojtech@suse.cz>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#ifndef _LOGIPS2PP_H
+#define _LOGIPS2PP_H
+struct psmouse;
+void ps2pp_process_packet(struct psmouse *psmouse);
+void ps2pp_set_800dpi(struct psmouse *psmouse);
+int ps2pp_detect_model(struct psmouse *psmouse);
+#endif
diff -Nru a/drivers/input/mouse/psmouse-base.c b/drivers/input/mouse/psmouse-base.c
--- a/drivers/input/mouse/psmouse-base.c	Sat Jun 21 15:25:29 2003
+++ b/drivers/input/mouse/psmouse-base.c	Sat Jun 21 15:25:29 2003
@@ -19,13 +19,23 @@
 #include <linux/init.h>
 #include "psmouse.h"
 #include "synaptics.h"
+#include "logips2pp.h"
 
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
 MODULE_DESCRIPTION("PS/2 mouse driver");
 MODULE_PARM(psmouse_noext, "1i");
+MODULE_PARM_DESC(psmouse_noext, "Disable any protocol extensions. Useful for KVM switches.");
+MODULE_PARM(psmouse_resolution, "i");
+MODULE_PARM_DESC(psmouse_resolution, "Resolution, in dpi.");
+MODULE_PARM(psmouse_smartscroll, "i");
+MODULE_PARM_DESC(psmouse_smartscroll, "Logitech Smartscroll autorepeat, 1 = enabled (default), 0 = disabled.");
 MODULE_LICENSE("GPL");
 
+#define PSMOUSE_LOGITECH_SMARTSCROLL	1
+
 static int psmouse_noext;
+int psmouse_resolution;
+int psmouse_smartscroll = PSMOUSE_LOGITECH_SMARTSCROLL;
 
 static char *psmouse_protocols[] = { "None", "PS/2", "PS2++", "PS2T++", "GenPS/2", "ImPS/2", "ImExPS/2", "Synaptics"};
 
@@ -45,43 +55,8 @@
  * The PS2++ protocol is a little bit complex
  */
 
-	if (psmouse->type == PSMOUSE_PS2PP || psmouse->type == PSMOUSE_PS2TPP) {
-
-		if ((packet[0] & 0x40) == 0x40 && abs((int)packet[1] - (((int)packet[0] & 0x10) << 4)) > 191 ) {
-
-			switch (((packet[1] >> 4) & 0x03) | ((packet[0] >> 2) & 0x0c)) {
-
-			case 1: /* Mouse extra info */
-
-				input_report_rel(dev, packet[2] & 0x80 ? REL_HWHEEL : REL_WHEEL,
-					(int) (packet[2] & 8) - (int) (packet[2] & 7));
-				input_report_key(dev, BTN_SIDE, (packet[2] >> 4) & 1);
-				input_report_key(dev, BTN_EXTRA, (packet[2] >> 5) & 1);
-					
-				break;
-
-			case 3: /* TouchPad extra info */
-
-				input_report_rel(dev, packet[2] & 0x08 ? REL_HWHEEL : REL_WHEEL,
-					(int) ((packet[2] >> 4) & 8) - (int) ((packet[2] >> 4) & 7));
-				packet[0] = packet[2] | 0x08;
-
-				break;
-
-#ifdef DEBUG
-			default:
-				printk(KERN_WARNING "psmouse.c: Received PS2++ packet #%x, but don't know how to handle.\n",
-					((packet[1] >> 4) & 0x03) | ((packet[0] >> 2) & 0x0c));
-#endif
-
-			}
-
-		packet[0] &= 0x0f;
-		packet[1] = 0;
-		packet[2] = 0;
-
-		}
-	}
+	if (psmouse->type == PSMOUSE_PS2PP || psmouse->type == PSMOUSE_PS2TPP)
+		ps2pp_process_packet(psmouse);
 
 /*
  * Scroll wheel on IntelliMice, scroll buttons on NetMice
@@ -259,33 +234,6 @@
 }
 
 /*
- * psmouse_ps2pp_cmd() sends a PS2++ command, sliced into two bit
- * pieces through the SETRES command. This is needed to send extended
- * commands to mice on notebooks that try to understand the PS/2 protocol
- * Ugly.
- */
-
-static int psmouse_ps2pp_cmd(struct psmouse *psmouse, unsigned char *param, unsigned char command)
-{
-	unsigned char d;
-	int i;
-
-	if (psmouse_command(psmouse,  NULL, PSMOUSE_CMD_SETSCALE11))
-		return -1;
-
-	for (i = 6; i >= 0; i -= 2) {
-		d = (command >> i) & 3;
-		if(psmouse_command(psmouse, &d, PSMOUSE_CMD_SETRES))
-			return -1;
-	}
-
-	if (psmouse_command(psmouse, param, PSMOUSE_CMD_POLL))
-		return -1;
-
-	return 0;
-}
-
-/*
  * psmouse_extensions() probes for any extensions to the basic PS/2 protocol
  * the mouse may have.
  */
@@ -353,73 +301,13 @@
 	psmouse_command(psmouse,  NULL, PSMOUSE_CMD_SETSCALE11);
 	psmouse_command(psmouse,  NULL, PSMOUSE_CMD_SETSCALE11);
 	psmouse_command(psmouse,  NULL, PSMOUSE_CMD_SETSCALE11);
+	param[1] = 0;
 	psmouse_command(psmouse, param, PSMOUSE_CMD_GETINFO);
 
 	if (param[1]) {
-
-		int i;
-		static int logitech_4btn[] = { 12, 40, 41, 42, 43, 52, 73, 80, -1 };
-		static int logitech_wheel[] = { 52, 53, 75, 76, 80, 81, 83, 88, -1 };
-		static int logitech_ps2pp[] = { 12, 13, 40, 41, 42, 43, 50, 51, 52, 53, 73, 75,
-							76, 80, 81, 83, 88, 96, 97, -1 };
-		psmouse->vendor = "Logitech";
-		psmouse->model = ((param[0] >> 4) & 0x07) | ((param[0] << 3) & 0x78);
-
-		if (param[1] < 3)
-			clear_bit(BTN_MIDDLE, psmouse->dev.keybit);
-		if (param[1] < 2)
-			clear_bit(BTN_RIGHT, psmouse->dev.keybit);
-
-		psmouse->type = PSMOUSE_PS2;
-
-		for (i = 0; logitech_ps2pp[i] != -1; i++)
-			if (logitech_ps2pp[i] == psmouse->model)
-				psmouse->type = PSMOUSE_PS2PP;
-
-		if (psmouse->type == PSMOUSE_PS2PP) {
-
-			for (i = 0; logitech_4btn[i] != -1; i++)
-				if (logitech_4btn[i] == psmouse->model)
-					set_bit(BTN_SIDE, psmouse->dev.keybit);
-
-			for (i = 0; logitech_wheel[i] != -1; i++)
-				if (logitech_wheel[i] == psmouse->model) {
-					set_bit(REL_WHEEL, psmouse->dev.relbit);
-					psmouse->name = "Wheel Mouse";
-				}
-
-/*
- * Do Logitech PS2++ / PS2T++ magic init.
- */
-
-			if (psmouse->model == 97) { /* TouchPad 3 */
-
-				set_bit(REL_WHEEL, psmouse->dev.relbit);
-				set_bit(REL_HWHEEL, psmouse->dev.relbit);
-
-				param[0] = 0x11; param[1] = 0x04; param[2] = 0x68; /* Unprotect RAM */
-				psmouse_command(psmouse, param, 0x30d1);
-				param[0] = 0x11; param[1] = 0x05; param[2] = 0x0b; /* Enable features */
-				psmouse_command(psmouse, param, 0x30d1);
-				param[0] = 0x11; param[1] = 0x09; param[2] = 0xc3; /* Enable PS2++ */
-				psmouse_command(psmouse, param, 0x30d1);
-
-				param[0] = 0;
-				if (!psmouse_command(psmouse, param, 0x13d1) &&
-					param[0] == 0x06 && param[1] == 0x00 && param[2] == 0x14)
-					return PSMOUSE_PS2TPP;
-
-			} else {
-				param[0] = param[1] = param[2] = 0;
-
-				psmouse_ps2pp_cmd(psmouse, param, 0x39); /* Magic knock */
-				psmouse_ps2pp_cmd(psmouse, param, 0xDB);
-
-				if ((param[0] & 0x78) == 0x48 && (param[1] & 0xf3) == 0xc2 &&
-					(param[2] & 3) == ((param[1] >> 2) & 3))
-						return PSMOUSE_PS2PP;
-			}
-		}
+		int type = ps2pp_detect_model(psmouse, param);
+		if (type)
+			return type;
 	}
 
 /*
@@ -508,6 +396,31 @@
 }
 
 /*
+ * Here we set the mouse resolution.
+ */
+
+static void psmouse_set_resolution(struct psmouse *psmouse)
+{
+	unsigned char param[1];
+
+	if (psmouse->type == PSMOUSE_PS2PP && psmouse_resolution > 400) {
+		ps2pp_set_800dpi(psmouse);
+		return;
+	}
+
+	if (!psmouse_resolution || psmouse_resolution >= 200)
+		param[0] = 3;
+	else if (psmouse_resolution >= 100)
+		param[0] = 2;
+	else if (psmouse_resolution >= 50)
+		param[0] = 1;
+	else if (psmouse_resolution)
+		param[0] = 0;
+
+        psmouse_command(psmouse, param, PSMOUSE_CMD_SETRES);
+}
+
+/*
  * psmouse_initialize() initializes the mouse to a sane state.
  */
 
@@ -519,7 +432,6 @@
  * We set the mouse report rate to a highest possible value.
  * We try 100 first in case mouse fails to set 200.
  */
-
 	param[0] = 100;
 	psmouse_command(psmouse, param, PSMOUSE_CMD_SETRATE);
 
@@ -530,8 +442,7 @@
  * We also set the resolution and scaling.
  */
 
-	param[0] = 3;
-	psmouse_command(psmouse, param, PSMOUSE_CMD_SETRES);
+	psmouse_set_resolution(psmouse);
 	psmouse_command(psmouse,  NULL, PSMOUSE_CMD_SETSCALE11);
 
 /*
@@ -638,12 +549,28 @@
 };
 
 #ifndef MODULE
-static int __init psmouse_setup(char *str)
+static int __init psmouse_noext_setup(char *str)
 {
 	psmouse_noext = 1;
 	return 1;
 }
-__setup("psmouse_noext", psmouse_setup);
+
+static int __init psmouse_resolution_setup(char *str)
+{
+	get_option(&str, &psmouse_resolution);
+	return 1;
+}
+
+static int __init psmouse_smartscroll_setup(char *str)
+{
+	get_option(&str, &psmouse_smartscroll);
+	return 1;
+}
+
+__setup("psmouse_noext", psmouse_noext_setup);
+__setup("psmouse_resolution=", psmouse_resolution_setup);
+__setup("psmouse_smartscroll=", psmouse_smartscroll_setup);
+
 #endif
 
 int __init psmouse_init(void)
diff -Nru a/drivers/input/mouse/psmouse.h b/drivers/input/mouse/psmouse.h
--- a/drivers/input/mouse/psmouse.h	Sat Jun 21 15:25:29 2003
+++ b/drivers/input/mouse/psmouse.h	Sat Jun 21 15:25:29 2003
@@ -46,4 +46,6 @@
 
 int psmouse_command(struct psmouse *psmouse, unsigned char *param, int command);
 
+extern int psmouse_smartscroll;
+
 #endif /* _PSMOUSE_H */
diff -Nru a/drivers/input/mouse/synaptics.c b/drivers/input/mouse/synaptics.c
--- a/drivers/input/mouse/synaptics.c	Sat Jun 21 15:25:29 2003
+++ b/drivers/input/mouse/synaptics.c	Sat Jun 21 15:25:29 2003
@@ -171,9 +171,9 @@
 static int query_hardware(struct psmouse *psmouse)
 {
 	struct synaptics_data *priv = psmouse->private;
-	int retries = 3;
+	int retries = 0;
 
-	while ((retries++ <= 3) && synaptics_reset(psmouse))
+	while ((retries++ < 3) && synaptics_reset(psmouse))
 		printk(KERN_ERR "synaptics reset failed\n");
 
 	if (synaptics_identify(psmouse, &priv->identity))
@@ -266,8 +266,7 @@
  *	Functions to interpret the absolute mode packets
  ****************************************************************************/
 
-static void synaptics_parse_hw_state(struct synaptics_data *priv,
-				     struct synaptics_hw_state *hw)
+static void synaptics_parse_hw_state(struct synaptics_data *priv, struct synaptics_hw_state *hw)
 {
 	unsigned char *buf = priv->proto_buf;
 
diff -Nru a/drivers/input/mouse/synaptics.h b/drivers/input/mouse/synaptics.h
--- a/drivers/input/mouse/synaptics.h	Sat Jun 21 15:25:29 2003
+++ b/drivers/input/mouse/synaptics.h	Sat Jun 21 15:25:29 2003
@@ -9,20 +9,10 @@
 #ifndef _SYNAPTICS_H
 #define _SYNAPTICS_H
 
-#ifdef CONFIG_MOUSE_PS2_SYNAPTICS
 
 extern void synaptics_process_byte(struct psmouse *psmouse, struct pt_regs *regs);
 extern int synaptics_init(struct psmouse *psmouse);
 extern void synaptics_disconnect(struct psmouse *psmouse);
-
-#else
-
-static inline void synaptics_process_byte(struct psmouse *psmouse, struct pt_regs *regs) {}
-static inline int synaptics_init(struct psmouse *psmouse) { return -1; }
-static inline void synaptics_disconnect(struct psmouse *psmouse) {}
-
-#endif
-
 
 /* synaptics queries */
 #define SYN_QUE_IDENTIFY		0x00
diff -Nru a/include/linux/input.h b/include/linux/input.h
--- a/include/linux/input.h	Sat Jun 21 15:25:29 2003
+++ b/include/linux/input.h	Sat Jun 21 15:25:29 2003
@@ -358,6 +358,7 @@
 #define BTN_EXTRA		0x114
 #define BTN_FORWARD		0x115
 #define BTN_BACK		0x116
+#define BTN_TASK		0x117
 
 #define BTN_JOYSTICK		0x120
 #define BTN_TRIGGER		0x120

