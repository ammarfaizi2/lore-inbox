Return-Path: <linux-kernel-owner@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id <S132775AbRDIP5r>; Mon, 9 Apr 2001 11:57:47 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org
	id <S132776AbRDIP5b>; Mon, 9 Apr 2001 11:57:31 -0400
Received: from d12lmsgate.de.ibm.com ([195.212.91.199]:53934 "EHLO
	d12lmsgate.de.ibm.com") by vger.kernel.org with ESMTP
	id <S132775AbRDIP5I>; Mon, 9 Apr 2001 11:57:08 -0400
From: schwidefsky@de.ibm.com
X-Lotus-FromDomain: IBMDE
To: linux-kernel@vger.kernel.org
Message-ID: <C1256A29.00575FA2.00@d12mta07.de.ibm.com>
Date: Mon, 9 Apr 2001 17:54:37 +0200
Subject: No 100 HZ timer !
Mime-Version: 1.0
Content-type: multipart/mixed; 
	Boundary="0__=AxUwewK46NPW3l78cMfeqzg27zDccjV0SOMwunyt3i8B0oHhABq1qiLy"
Content-Disposition: inline
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

--0__=AxUwewK46NPW3l78cMfeqzg27zDccjV0SOMwunyt3i8B0oHhABq1qiLy
Content-type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-transfer-encoding: quoted-printable




Hi,
seems like my first try with the complete patch hasn't made it through
to the mailing list. This is the second try with only the common part o=
f
the patch. Here we go (again):
---

I have a suggestion that might seem unusual at first but it is importan=
t
for Linux on S/390. We are facing the problem that we want to start man=
y
(> 1000) Linux images on a big S/390 machine. Every image has its own
100 HZ timer on every processor the images uses (normally 1). On a sing=
le
image system the processor use of the 100 HZ timer is not a big deal bu=
t
with > 1000 images you need a lot of processing power just to execute t=
he
100 HZ timers. You quickly end up with 100% CPU only for the timer
interrupts of otherwise idle images. Therefore I had a go at the timer
stuff and now I have a system running without the 100 HZ timer. Unluckl=
y
I need to make changes to common code and I want you opinion on it.

The first problem was how to get rid of the jiffies. The solution is
simple. I simply defined a macro that calculates the jiffies value from=

the TOD clock:
  #define jiffies ({ \
          uint64_t __ticks; \
          asm ("STCK %0" : "=3Dm" (__ticks) ); \
          __ticks =3D (__ticks - init_timer_cc) >> 12; \
          do_div(__ticks, (1000000/HZ)); \
          ((unsigned long) __ticks); \
  })
With this define you are independent of the jiffies variable which is n=
o
longer needed so I ifdef'ed the definition. There are some places where=
 a
local variable is named jiffies. You may not replace these so I renamed=

them to _jiffies. A kernel compiled with only this change works as alwa=
ys.

The second problem is that you need to be able to find out when the nex=
t
timer event is due to happen. You'll find a new function "next_timer_ev=
ent"
in the patch which traverses tv1-tv5 and returns the timer_list of the =
next
timer event. It is used in timer_bh to indicate to the backend when the=

next interrupt should happen. This leads us to the notifier functions.
Each time a new timer is added, a timer is modified, or a timer expires=

the architecture backend needs to reset its timeout value. That is what=
 the
"timer_notify" callback is used for. The implementation on S/390 uses t=
he
clock comparator and looks like this:
  static void s390_timer_notify(unsigned long expires)
  {
          S390_lowcore.timer_event =3D
                  ((__u64) expires*CLK_TICKS_PER_JIFFY) + init_timer_cc=
;
          asm volatile ("SCKC %0" : : "m" (S390_lowcore.timer_event));
  }
This causes an interrupt on the cpu which executed s390_timer_notify af=
ter
"expires" has passed. That means that timer events are spread over the =
cpus
in the system. Modified or deleted timer events do not cause a deletion=

notification. A cpu might be errornously interrupted to early because o=
f a
timer event that has been modified or deleted. But that doesn't do any
harm,
it is just unnecessary work.

There is a second callback "itimer_notify" that is used to get the per
process timers right. We use the cpu timer for this purpose:
  void set_cpu_timer(void)
  {
          unsigned long min_ticks;
          __u64 time_slice;
          if (current->pid !=3D 0 && current->need_resched =3D=3D 0) {
                  min_ticks =3D current->counter;
                  if (current->it_prof_value !=3D 0 &&
                      current->it_prof_value < min_ticks)
                          min_ticks =3D current->it_prof_value;
                  if (current->it_virt_value !=3D 0 &&
                      current->it_virt_value < min_ticks)
                          min_ticks =3D current->it_virt_value;
                  time_slice =3D (__u64) min_ticks*CLK_TICKS_PER_JIFFY;=

                  asm volatile ("spt %0" : : "m" (time_slice));
          }
  }
The cpu timer is a one shot timer that interrupts after the specified
amount
of time has passed. Not a 100% accurate because VM can schedule the vir=
tual
processor before the "spt" has been done but good enough for per proces=
s
timers.

The remaining changes to common code parts deal with the problem that m=
any
ticks may be accounted at once. For example without the 100 HZ timer it=
 is
possible that a process runs for half a second in user space. With the =
next
interrupt all the ticks between the last update and the interrupt have =
to
be added to the tick counters. This is why update_wall_time and do_it_p=
rof
have changed and update_process_times2 has been introduced.

That leaves three problems: 1) you need to check on every system entry =
if
a tick or more has passed and do the update if necessary, 2) you need t=
o
keep track of the elapsed time in user space and in kernel space and 3)=
 you
need to check tq_timer every time the system is left and setup a timer
event for the next timer tick if there is work to do on the timer queue=
.
These three problems are related and have to be implemented architectur=
e
dependent. A nice thing we get for free is that the user/kernel elapsed=

time
measurement gets much more accurate.

The number of interrupts in an idle system due to timer activity drops =
from
from 100 per second on every cpu to about 5-6 on all (!) cpus if this p=
atch
is used. Exactly what we want to have.

All this new timer code is only used if the config option
CONFIG_NO_HZ_TIMER
is set. Without it everything works as always, especially for architect=
ures
that will not use it.

Now what do you think?

(See attached file: timer_common)

blue skies,
   Martin

Linux/390 Design & Development, IBM Deutschland Entwicklung GmbH
Sch=F6naicherstr. 220, D-71032 B=F6blingen, Telefon: 49 - (0)7031 - 16-=
2247
E-Mail: schwidefsky@de.ibm.com
=

--0__=AxUwewK46NPW3l78cMfeqzg27zDccjV0SOMwunyt3i8B0oHhABq1qiLy
Content-type: application/octet-stream; 
	name="timer_common"
Content-Disposition: attachment; filename="timer_common"
Content-transfer-encoding: base64

ZGlmZiAtdXJOIGxpbnV4LTIuNC4zL2luY2x1ZGUvbGludXgvc2NoZWQuaCBsaW51eC0yLjQuMy1z
MzkwL2luY2x1ZGUvbGludXgvc2NoZWQuaAotLS0gbGludXgtMi40LjMvaW5jbHVkZS9saW51eC9z
Y2hlZC5oCVR1ZSBNYXIgMjcgMDE6NDg6MTEgMjAwMQorKysgbGludXgtMi40LjMtczM5MC9pbmNs
dWRlL2xpbnV4L3NjaGVkLmgJVGh1IEFwciAgNSAxMDoyMzo0OCAyMDAxCkBAIC0xNDQsNiArMTQ0
LDcgQEAKIGV4dGVybiB2b2lkIGNwdV9pbml0ICh2b2lkKTsKIGV4dGVybiB2b2lkIHRyYXBfaW5p
dCh2b2lkKTsKIGV4dGVybiB2b2lkIHVwZGF0ZV9wcm9jZXNzX3RpbWVzKGludCB1c2VyKTsKK2V4
dGVybiB2b2lkIHVwZGF0ZV9wcm9jZXNzX3RpbWVzMihpbnQgdXNlciwgaW50IHN5c3RlbSk7CiBl
eHRlcm4gdm9pZCB1cGRhdGVfb25lX3Byb2Nlc3Moc3RydWN0IHRhc2tfc3RydWN0ICpwLCB1bnNp
Z25lZCBsb25nIHVzZXIsCiAJCQkgICAgICAgdW5zaWduZWQgbG9uZyBzeXN0ZW0sIGludCBjcHUp
OwogCkBAIC01MzQsNyArNTM1LDkgQEAKIAogI2luY2x1ZGUgPGFzbS9jdXJyZW50Lmg+CiAKKyNp
Zm5kZWYgQ09ORklHX05PX0haX1RJTUVSCiBleHRlcm4gdW5zaWduZWQgbG9uZyB2b2xhdGlsZSBq
aWZmaWVzOworI2VuZGlmCiBleHRlcm4gdW5zaWduZWQgbG9uZyBpdGltZXJfdGlja3M7CiBleHRl
cm4gdW5zaWduZWQgbG9uZyBpdGltZXJfbmV4dDsKIGV4dGVybiBzdHJ1Y3QgdGltZXZhbCB4dGlt
ZTsKZGlmZiAtdXJOIGxpbnV4LTIuNC4zL2luY2x1ZGUvbGludXgvdGltZS5oIGxpbnV4LTIuNC4z
LXMzOTAvaW5jbHVkZS9saW51eC90aW1lLmgKLS0tIGxpbnV4LTIuNC4zL2luY2x1ZGUvbGludXgv
dGltZS5oCVR1ZSBNYXIgMjcgMDE6NDg6MTAgMjAwMQorKysgbGludXgtMi40LjMtczM5MC9pbmNs
dWRlL2xpbnV4L3RpbWUuaAlUaHUgQXByICA1IDEwOjIzOjQ4IDIwMDEKQEAgLTQyLDEwICs0Miwx
MCBAQAogfQogCiBzdGF0aWMgX19pbmxpbmVfXyB2b2lkCi1qaWZmaWVzX3RvX3RpbWVzcGVjKHVu
c2lnbmVkIGxvbmcgamlmZmllcywgc3RydWN0IHRpbWVzcGVjICp2YWx1ZSkKK2ppZmZpZXNfdG9f
dGltZXNwZWModW5zaWduZWQgbG9uZyBfamlmZmllcywgc3RydWN0IHRpbWVzcGVjICp2YWx1ZSkK
IHsKLQl2YWx1ZS0+dHZfbnNlYyA9IChqaWZmaWVzICUgSFopICogKDEwMDAwMDAwMDBMIC8gSFop
OwotCXZhbHVlLT50dl9zZWMgPSBqaWZmaWVzIC8gSFo7CisJdmFsdWUtPnR2X25zZWMgPSAoX2pp
ZmZpZXMgJSBIWikgKiAoMTAwMDAwMDAwMEwgLyBIWik7CisJdmFsdWUtPnR2X3NlYyA9IF9qaWZm
aWVzIC8gSFo7CiB9CiAKIApkaWZmIC11ck4gbGludXgtMi40LjMvaW5jbHVkZS9saW51eC90aW1l
ci5oIGxpbnV4LTIuNC4zLXMzOTAvaW5jbHVkZS9saW51eC90aW1lci5oCi0tLSBsaW51eC0yLjQu
My9pbmNsdWRlL2xpbnV4L3RpbWVyLmgJVHVlIE1hciAyNyAwMTo0ODoxMCAyMDAxCisrKyBsaW51
eC0yLjQuMy1zMzkwL2luY2x1ZGUvbGludXgvdGltZXIuaAlUaHUgQXByICA1IDEwOjIzOjQ4IDIw
MDEKQEAgLTM1LDYgKzM1LDE4IEBACiAjZGVmaW5lIHN5bmNfdGltZXJzKCkJCWRvIHsgfSB3aGls
ZSAoMCkKICNlbmRpZgogCisjaWZkZWYgQ09ORklHX05PX0haX1RJTUVSCisvKgorICogU2V0dGlu
ZyB0aW1lcl9ub3RpZnkgdG8gc29tZXRoaW5nICE9IE5VTEwgd2lsbCBtYWtlCisgKiB0aGUgdGlt
ZXIgcm91dGluZXMgY2FsbCB0aGUgbm90aWZpY2F0aW9uIHJvdXRpbmUKKyAqIHdoZW5ldmVyIGEg
bmV3IGFkZF90aW1lci9tb2RfdGltZXIgaGFzIHNldCBhIG5ldworICogc29vbmVzdCB0aW1lciBl
dmVudC4KKyAqLworZXh0ZXJuIHZvaWQgKCp0aW1lcl9ub3RpZnkpKHVuc2lnbmVkIGxvbmcgZXhw
aXJlcyk7CitleHRlcm4gdm9pZCAoKml0aW1lcl9ub3RpZnkpKHZvaWQpOworZXh0ZXJuIHZvaWQg
dXBkYXRlX3RpbWVzX2lycXNhdmUodm9pZCk7CisjZW5kaWYKKwogLyoKICAqIG1vZF90aW1lciBp
cyBhIG1vcmUgZWZmaWNpZW50IHdheSB0byB1cGRhdGUgdGhlIGV4cGlyZSBmaWVsZCBvZiBhbgog
ICogYWN0aXZlIHRpbWVyIChpZiB0aGUgdGltZXIgaXMgaW5hY3RpdmUgaXQgd2lsbCBiZSBhY3Rp
dmF0ZWQpCmRpZmYgLXVyTiBsaW51eC0yLjQuMy9rZXJuZWwvaXRpbWVyLmMgbGludXgtMi40LjMt
czM5MC9rZXJuZWwvaXRpbWVyLmMKLS0tIGxpbnV4LTIuNC4zL2tlcm5lbC9pdGltZXIuYwlUaHUg
SnVuIDI5IDE5OjA3OjM2IDIwMDAKKysrIGxpbnV4LTIuNC4zLXMzOTAva2VybmVsL2l0aW1lci5j
CVRodSBBcHIgIDUgMTA6MjM6NDggMjAwMQpAQCAtMzQsMTAgKzM0LDEwIEBACiAJcmV0dXJuIEha
KnNlYyt1c2VjOwogfQogCi1zdGF0aWMgdm9pZCBqaWZmaWVzdG90dih1bnNpZ25lZCBsb25nIGpp
ZmZpZXMsIHN0cnVjdCB0aW1ldmFsICp2YWx1ZSkKK3N0YXRpYyB2b2lkIGppZmZpZXN0b3R2KHVu
c2lnbmVkIGxvbmcgX2ppZmZpZXMsIHN0cnVjdCB0aW1ldmFsICp2YWx1ZSkKIHsKLQl2YWx1ZS0+
dHZfdXNlYyA9IChqaWZmaWVzICUgSFopICogKDEwMDAwMDAgLyBIWik7Ci0JdmFsdWUtPnR2X3Nl
YyA9IGppZmZpZXMgLyBIWjsKKwl2YWx1ZS0+dHZfdXNlYyA9IChfamlmZmllcyAlIEhaKSAqICgx
MDAwMDAwIC8gSFopOworCXZhbHVlLT50dl9zZWMgPSBfamlmZmllcyAvIEhaOwogfQogCiBpbnQg
ZG9fZ2V0aXRpbWVyKGludCB3aGljaCwgc3RydWN0IGl0aW1lcnZhbCAqdmFsdWUpCkBAIC0xMDUs
NiArMTA1LDE2IEBACiAJfQogfQogCisjaWZkZWYgQ09ORklHX05PX0haX1RJTUVSCit2b2lkICgq
aXRpbWVyX25vdGlmeSkodm9pZCkgPSBOVUxMOworCitzdGF0aWMgaW5saW5lIHZvaWQgZG9faXRp
bWVyX25vdGlmeSh2b2lkKQoreworCWlmIChpdGltZXJfbm90aWZ5ICE9IE5VTEwpCisgICAgICAg
ICAgICAgICAgKCppdGltZXJfbm90aWZ5KSgpOworfQorI2VuZGlmCisKIGludCBkb19zZXRpdGlt
ZXIoaW50IHdoaWNoLCBzdHJ1Y3QgaXRpbWVydmFsICp2YWx1ZSwgc3RydWN0IGl0aW1lcnZhbCAq
b3ZhbHVlKQogewogCXJlZ2lzdGVyIHVuc2lnbmVkIGxvbmcgaSwgajsKQEAgLTEzMiwxMiArMTQy
LDE4IEBACiAJCQkJaisrOwogCQkJY3VycmVudC0+aXRfdmlydF92YWx1ZSA9IGo7CiAJCQljdXJy
ZW50LT5pdF92aXJ0X2luY3IgPSBpOworI2lmZGVmIENPTkZJR19OT19IWl9USU1FUgorCQkJZG9f
aXRpbWVyX25vdGlmeSgpOworI2VuZGlmCiAJCQlicmVhazsKIAkJY2FzZSBJVElNRVJfUFJPRjoK
IAkJCWlmIChqKQogCQkJCWorKzsKIAkJCWN1cnJlbnQtPml0X3Byb2ZfdmFsdWUgPSBqOwogCQkJ
Y3VycmVudC0+aXRfcHJvZl9pbmNyID0gaTsKKyNpZmRlZiBDT05GSUdfTk9fSFpfVElNRVIKKwkJ
CWRvX2l0aW1lcl9ub3RpZnkoKTsKKyNlbmRpZgogCQkJYnJlYWs7CiAJCWRlZmF1bHQ6CiAJCQly
ZXR1cm4gLUVJTlZBTDsKZGlmZiAtdXJOIGxpbnV4LTIuNC4zL2tlcm5lbC9rc3ltcy5jIGxpbnV4
LTIuNC4zLXMzOTAva2VybmVsL2tzeW1zLmMKLS0tIGxpbnV4LTIuNC4zL2tlcm5lbC9rc3ltcy5j
CVRodSBBcHIgIDUgMTA6MjM6MzYgMjAwMQorKysgbGludXgtMi40LjMtczM5MC9rZXJuZWwva3N5
bXMuYwlUaHUgQXByICA1IDEwOjIzOjQ4IDIwMDEKQEAgLTQyOSw3ICs0MjksOSBAQAogRVhQT1JU
X1NZTUJPTChpbnRlcnJ1cHRpYmxlX3NsZWVwX29uX3RpbWVvdXQpOwogRVhQT1JUX1NZTUJPTChz
Y2hlZHVsZSk7CiBFWFBPUlRfU1lNQk9MKHNjaGVkdWxlX3RpbWVvdXQpOworI2lmbmRlZiBDT05G
SUdfTk9fSFpfVElNRVIKIEVYUE9SVF9TWU1CT0woamlmZmllcyk7CisjZW5kaWYKIEVYUE9SVF9T
WU1CT0woeHRpbWUpOwogRVhQT1JUX1NZTUJPTChkb19nZXR0aW1lb2ZkYXkpOwogRVhQT1JUX1NZ
TUJPTChkb19zZXR0aW1lb2ZkYXkpOwpkaWZmIC11ck4gbGludXgtMi40LjMva2VybmVsL3RpbWVy
LmMgbGludXgtMi40LjMtczM5MC9rZXJuZWwvdGltZXIuYwotLS0gbGludXgtMi40LjMva2VybmVs
L3RpbWVyLmMJU3VuIERlYyAxMCAxODo1MzoxOSAyMDAwCisrKyBsaW51eC0yLjQuMy1zMzkwL2tl
cm5lbC90aW1lci5jCVRodSBBcHIgIDUgMTA6MjM6NDggMjAwMQpAQCAtNjUsNyArNjUsOSBAQAog
CiBleHRlcm4gaW50IGRvX3NldGl0aW1lcihpbnQsIHN0cnVjdCBpdGltZXJ2YWwgKiwgc3RydWN0
IGl0aW1lcnZhbCAqKTsKIAorI2lmbmRlZiBDT05GSUdfTk9fSFpfVElNRVIKIHVuc2lnbmVkIGxv
bmcgdm9sYXRpbGUgamlmZmllczsKKyNlbmRpZgogCiB1bnNpZ25lZCBpbnQgKiBwcm9mX2J1ZmZl
cjsKIHVuc2lnbmVkIGxvbmcgcHJvZl9sZW47CkBAIC0xNzMsNiArMTc1LDIyIEBACiAjZGVmaW5l
IHRpbWVyX2V4aXQoKQkJZG8geyB9IHdoaWxlICgwKQogI2VuZGlmCiAKKyNpZmRlZiBDT05GSUdf
Tk9fSFpfVElNRVIKK3ZvaWQgKCp0aW1lcl9ub3RpZnkpKHVuc2lnbmVkIGxvbmcpID0gTlVMTDsK
K3Vuc2lnbmVkIGxvbmcgbm90aWZ5X2ppZmZ5ID0gMDsKKworc3RhdGljIGlubGluZSB2b2lkIGRv
X3RpbWVyX25vdGlmeShzdHJ1Y3QgdGltZXJfbGlzdCAqdGltZXIpCit7CisJaWYgKHRpbWVyX25v
dGlmeSAhPSBOVUxMKSB7CisJCWlmIChub3RpZnlfamlmZnkgPT0gMCB8fAorCQkgICAgdGltZV9i
ZWZvcmUodGltZXItPmV4cGlyZXMsIG5vdGlmeV9qaWZmeSkpIHsKKwkJCSgqdGltZXJfbm90aWZ5
KSh0aW1lci0+ZXhwaXJlcyk7CisJCQlub3RpZnlfamlmZnkgPSB0aW1lci0+ZXhwaXJlczsKKwkJ
fQorCX0KK30KKyNlbmRpZgorCiB2b2lkIGFkZF90aW1lcihzdHJ1Y3QgdGltZXJfbGlzdCAqdGlt
ZXIpCiB7CiAJdW5zaWduZWQgbG9uZyBmbGFnczsKQEAgLTE4MSw2ICsxOTksOSBAQAogCWlmICh0
aW1lcl9wZW5kaW5nKHRpbWVyKSkKIAkJZ290byBidWc7CiAJaW50ZXJuYWxfYWRkX3RpbWVyKHRp
bWVyKTsKKyNpZmRlZiBDT05GSUdfTk9fSFpfVElNRVIKKwlkb190aW1lcl9ub3RpZnkodGltZXIp
OworI2VuZGlmCiAJc3Bpbl91bmxvY2tfaXJxcmVzdG9yZSgmdGltZXJsaXN0X2xvY2ssIGZsYWdz
KTsKIAlyZXR1cm47CiBidWc6CkBAIC0yMDYsNiArMjI3LDkgQEAKIAl0aW1lci0+ZXhwaXJlcyA9
IGV4cGlyZXM7CiAJcmV0ID0gZGV0YWNoX3RpbWVyKHRpbWVyKTsKIAlpbnRlcm5hbF9hZGRfdGlt
ZXIodGltZXIpOworI2lmZGVmIENPTkZJR19OT19IWl9USU1FUgorCWRvX3RpbWVyX25vdGlmeSh0
aW1lcik7CisjZW5kaWYKIAlzcGluX3VubG9ja19pcnFyZXN0b3JlKCZ0aW1lcmxpc3RfbG9jaywg
ZmxhZ3MpOwogCXJldHVybiByZXQ7CiB9CkBAIC0zMjMsNiArMzQ3LDg5IEBACiAJc3Bpbl91bmxv
Y2tfaXJxKCZ0aW1lcmxpc3RfbG9jayk7CiB9CiAKKyNpZmRlZiBDT05GSUdfTk9fSFpfVElNRVIK
Ky8qCisgKiBDaGVjayB0aW1lciBsaXN0IGZvciBlYXJsaWVzdCB0aW1lcgorICovCitzdGF0aWMg
aW5saW5lIHN0cnVjdCB0aW1lcl9saXN0ICoKK2VhcmxpZXJfdGltZXJfaW5fbGlzdChzdHJ1Y3Qg
bGlzdF9oZWFkICpoZWFkLCBzdHJ1Y3QgdGltZXJfbGlzdCAqZXZlbnQpCit7CisJc3RydWN0IGxp
c3RfaGVhZCAqY3VycjsKKworCWlmIChsaXN0X2VtcHR5KGhlYWQpKQorCQlyZXR1cm4gZXZlbnQ7
CisJY3VyciA9IGhlYWQtPm5leHQ7CisJaWYgKGV2ZW50ID09IE5VTEwpIHsKKwkJZXZlbnQgPSBs
aXN0X2VudHJ5KGN1cnIsIHN0cnVjdCB0aW1lcl9saXN0LCBsaXN0KTsKKwkJY3VyciA9IGN1cnIt
Pm5leHQ7CisJfQorCXdoaWxlIChjdXJyICE9IGhlYWQpIHsKKwkJc3RydWN0IHRpbWVyX2xpc3Qg
KiB0bXA7CisKKwkJdG1wID0gbGlzdF9lbnRyeShjdXJyLCBzdHJ1Y3QgdGltZXJfbGlzdCwgbGlz
dCk7CisJCWlmICh0aW1lX2JlZm9yZSh0bXAtPmV4cGlyZXMsIGV2ZW50LT5leHBpcmVzKSkKKwkJ
CWV2ZW50ID0gdG1wOworCQljdXJyID0gY3Vyci0+bmV4dDsKKwl9CisJcmV0dXJuIGV2ZW50Owor
fQorCisvKgorICogRmluZCBvdXQgd2hlbiB0aGUgbmV4dCB0aW1lciBldmVudCBpcyBkdWUgdG8g
aGFwcGVuLiBUaGlzCisgKiBpcyB1c2VkIG9uIFMvMzkwIHRvIGJlIGFibGUgdG8gc2tpcCB0aW1l
ciB0aWNrcy4KKyAqIFRoZSB0aW1lcmxpc3RfbG9jayBtdXN0IGJlIGFjcXVpcmVkIGJlZm9yZSBj
YWxsaW5nIHRoaXMgZnVuY3Rpb24uCisgKi8KK3N0cnVjdCB0aW1lcl9saXN0ICpuZXh0X3RpbWVy
X2V2ZW50KHZvaWQpCit7CisJc3RydWN0IHRpbWVyX2xpc3QgKm50ZSA9IE5VTEw7CisJaW50IGk7
CisKKwkvKiBMb29rIGZvciB0aGUgbmV4dCB0aW1lciBldmVudCBpbiB0djEuICovCisJaSA9IHR2
MS5pbmRleDsKKwlkbyB7CisJCXN0cnVjdCBsaXN0X2hlYWQgKmhlYWQgPSB0djEudmVjICsgaTsK
KwkJaWYgKCFsaXN0X2VtcHR5KGhlYWQpKSB7CisJCQludGUgPSBsaXN0X2VudHJ5KGhlYWQtPm5l
eHQsIHN0cnVjdCB0aW1lcl9saXN0LCBsaXN0KTsKKwkJCWlmIChpIDwgdHYxLmluZGV4KSB7CisJ
CQkJLyogCisJCQkJICogVGhlIHNlYXJjaCB3cmFwcGVkLiBXZSBuZWVkIHRvIGxvb2sKKwkJCQkg
KiBhdCB0aGUgbmV4dCBsaXN0IGZyb20gdHZlY3NbMV0gdGhhdAorCQkJCSAqIHdvdWxkIGNhc2Nh
ZGUgaW50byB0djEuCisJCQkJICovCisJCQkJaGVhZCA9IHR2ZWNzWzFdLT52ZWMgKyB0dmVjc1sx
XS0+aW5kZXg7CisJCQkJbnRlID0gZWFybGllcl90aW1lcl9pbl9saXN0KGhlYWQsIG50ZSk7CisJ
CQl9CisJCQlnb3RvIG91dDsKKwkJfQorCQlpID0gKGkgKyAxKSAmIFRWUl9NQVNLOworCX0gd2hp
bGUgKGkgIT0gdHYxLmluZGV4KTsKKworCS8qIE5vIGV2ZW50IGZvdW5kIGluIHR2MS4gQ2hlY2sg
dHYyLXR2NS4gKi8KKwlmb3IgKGkgPSAxOyBpIDwgTk9PRl9UVkVDUzsgaSsrKSB7CisJCWludCBq
ID0gdHZlY3NbaV0tPmluZGV4OworCQlkbyB7CisJCQlzdHJ1Y3QgbGlzdF9oZWFkICpoZWFkID0g
dHZlY3NbaV0tPnZlYyArIGo7CisJCQludGUgPSBlYXJsaWVyX3RpbWVyX2luX2xpc3QoaGVhZCwg
TlVMTCk7CisJCQlpZiAobnRlKSB7CisJCQkJaWYgKGogPCB0dmVjc1tpXS0+aW5kZXggJiYgaSA8
IE5PT0ZfVFZFQ1MtMSkgeworCQkJCQkvKiAKKwkJCQkJICogVGhlIHNlYXJjaCB3cmFwcGVkLiBX
ZSBuZWVkIHRvIGxvb2sKKwkJCQkJICogYXQgdGhlIG5leHQgbGlzdCBmcm9tIHR2ZWNzW2krMV0K
KwkJCQkJICogdGhhdCB3b3VsZCBjYXNjYWRlIGludG8gdHZlY3NbaV0uCisJCQkJCSAqLworCQkJ
CQloZWFkID0gdHZlY3NbaSsxXS0+dmVjK3R2ZWNzW2krMV0tPmluZGV4OworCQkJCQludGUgPSBl
YXJsaWVyX3RpbWVyX2luX2xpc3QoaGVhZCwgbnRlKTsKKwkJCQl9CisJCQkJZ290byBvdXQ7CisJ
CQl9CisJCQlqID0gKGogKyAxKSAmIFRWTl9NQVNLOworCQl9IHdoaWxlIChqICE9IHR2ZWNzW2ld
LT5pbmRleCk7CisJfQorIG91dDoKKwlyZXR1cm4gbnRlOworfQorI2VuZGlmCisKIHNwaW5sb2Nr
X3QgdHF1ZXVlX2xvY2sgPSBTUElOX0xPQ0tfVU5MT0NLRUQ7CiAKIHZvaWQgdHF1ZXVlX2JoKHZv
aWQpCkBAIC00NTgsOCArNTY1LDEzIEBACiAjZW5kaWYKIH0KIAotLyogaW4gdGhlIE5UUCByZWZl
cmVuY2UgdGhpcyBpcyBjYWxsZWQgImhhcmRjbG9jaygpIiAqLwotc3RhdGljIHZvaWQgdXBkYXRl
X3dhbGxfdGltZV9vbmVfdGljayh2b2lkKQorLyoKKyAqIFRoZSB0aWNrcyBsb29wIHVzZWQgaW4g
dGhlIHBhc3QgaXMgZ29uZSBiZWNhdXNlIHdpdGgKKyAqIHRoZSBDT05GSUdfTk9fSFpfVElNRVIg
Y29uZmlnIG9wdGlvbiBvbiBTLzM5MCBpdCBpcworICogcG9zc2libGUgdGhhdCB0aWNrcyBpcyBh
IGxvdCBiaWdnZXIgdGhhbiBvbmUuCisgKiAgIC0tIG1hcnRpbgorICovCitzdGF0aWMgdm9pZCB1
cGRhdGVfd2FsbF90aW1lKHVuc2lnbmVkIGxvbmcgdGlja3MpCiB7CiAJaWYgKCAodGltZV9hZGp1
c3Rfc3RlcCA9IHRpbWVfYWRqdXN0KSAhPSAwICkgewogCSAgICAvKiBXZSBhcmUgZG9pbmcgYW4g
YWRqdGltZSB0aGluZy4gCkBAIC00NzAsMjEgKzU4MiwyMiBAQAogCSAgICAgKgogCSAgICAgKiBM
aW1pdCB0aGUgYW1vdW50IG9mIHRoZSBzdGVwIHRvIGJlIGluIHRoZSByYW5nZQogCSAgICAgKiAt
dGlja2FkaiAuLiArdGlja2FkagorICAgICAgICAgICAgICogcGVyIHRpY2suCiAJICAgICAqLwot
CSAgICAgaWYgKHRpbWVfYWRqdXN0ID4gdGlja2FkaikKLQkJdGltZV9hZGp1c3Rfc3RlcCA9IHRp
Y2thZGo7Ci0JICAgICBlbHNlIGlmICh0aW1lX2FkanVzdCA8IC10aWNrYWRqKQotCQl0aW1lX2Fk
anVzdF9zdGVwID0gLXRpY2thZGo7CisJICAgICBpZiAodGltZV9hZGp1c3QgPiB0aWNrYWRqKnRp
Y2tzKQorCQl0aW1lX2FkanVzdF9zdGVwID0gdGlja2Fkaip0aWNrczsKKwkgICAgIGVsc2UgaWYg
KHRpbWVfYWRqdXN0IDwgLXRpY2thZGoqdGlja3MpCisJCXRpbWVfYWRqdXN0X3N0ZXAgPSAtdGlj
a2Fkaip0aWNrczsKIAkgICAgIAogCSAgICAvKiBSZWR1Y2UgYnkgdGhpcyBzdGVwIHRoZSBhbW91
bnQgb2YgdGltZSBsZWZ0ICAqLwogCSAgICB0aW1lX2FkanVzdCAtPSB0aW1lX2FkanVzdF9zdGVw
OwogCX0KLQl4dGltZS50dl91c2VjICs9IHRpY2sgKyB0aW1lX2FkanVzdF9zdGVwOworCXh0aW1l
LnR2X3VzZWMgKz0gdGljayp0aWNrcyArIHRpbWVfYWRqdXN0X3N0ZXA7CiAJLyoKIAkgKiBBZHZh
bmNlIHRoZSBwaGFzZSwgb25jZSBpdCBnZXRzIHRvIG9uZSBtaWNyb3NlY29uZCwgdGhlbgogCSAq
IGFkdmFuY2UgdGhlIHRpY2sgbW9yZS4KIAkgKi8KLQl0aW1lX3BoYXNlICs9IHRpbWVfYWRqOwor
CXRpbWVfcGhhc2UgKz0gdGltZV9hZGoqdGlja3M7CiAJaWYgKHRpbWVfcGhhc2UgPD0gLUZJTkVV
U0VDKSB7CiAJCWxvbmcgbHRlbXAgPSAtdGltZV9waGFzZSA+PiBTSElGVF9TQ0FMRTsKIAkJdGlt
ZV9waGFzZSArPSBsdGVtcCA8PCBTSElGVF9TQ0FMRTsKQEAgLTQ5NSwyMSArNjA4LDYgQEAKIAkJ
dGltZV9waGFzZSAtPSBsdGVtcCA8PCBTSElGVF9TQ0FMRTsKIAkJeHRpbWUudHZfdXNlYyArPSBs
dGVtcDsKIAl9Ci19Ci0KLS8qCi0gKiBVc2luZyBhIGxvb3AgbG9va3MgaW5lZmZpY2llbnQsIGJ1
dCAidGlja3MiIGlzCi0gKiB1c3VhbGx5IGp1c3Qgb25lICh3ZSBzaG91bGRuJ3QgYmUgbG9zaW5n
IHRpY2tzLAotICogd2UncmUgZG9pbmcgdGhpcyB0aGlzIHdheSBtYWlubHkgZm9yIGludGVycnVw
dAotICogbGF0ZW5jeSByZWFzb25zLCBub3QgYmVjYXVzZSB3ZSB0aGluayB3ZSdsbAotICogaGF2
ZSBsb3RzIG9mIGxvc3QgdGltZXIgdGlja3MKLSAqLwotc3RhdGljIHZvaWQgdXBkYXRlX3dhbGxf
dGltZSh1bnNpZ25lZCBsb25nIHRpY2tzKQotewotCWRvIHsKLQkJdGlja3MtLTsKLQkJdXBkYXRl
X3dhbGxfdGltZV9vbmVfdGljaygpOwotCX0gd2hpbGUgKHRpY2tzKTsKIAogCWlmICh4dGltZS50
dl91c2VjID49IDEwMDAwMDApIHsKIAkgICAgeHRpbWUudHZfdXNlYyAtPSAxMDAwMDAwOwpAQCAt
NTI3LDcgKzYyNSw3IEBACiAJcHNlY3MgKz0gKHAtPnRpbWVzLnRtc19zdGltZSArPSBzeXN0ZW0p
OwogCWlmIChwc2VjcyAvIEhaID4gcC0+cmxpbVtSTElNSVRfQ1BVXS5ybGltX2N1cikgewogCQkv
KiBTZW5kIFNJR1hDUFUgZXZlcnkgc2Vjb25kLi4gKi8KLQkJaWYgKCEocHNlY3MgJSBIWikpCisJ
CWlmICgocHNlY3MgJSBIWikgPCB1c2VyK3N5c3RlbSkKIAkJCXNlbmRfc2lnKFNJR1hDUFUsIHAs
IDEpOwogCQkvKiBhbmQgU0lHS0lMTCB3aGVuIHdlIGdvIG92ZXIgbWF4Li4gKi8KIAkJaWYgKHBz
ZWNzIC8gSFogPiBwLT5ybGltW1JMSU1JVF9DUFVdLnJsaW1fbWF4KQpAQCAtNTQwLDI0ICs2Mzgs
MjUgQEAKIAl1bnNpZ25lZCBsb25nIGl0X3ZpcnQgPSBwLT5pdF92aXJ0X3ZhbHVlOwogCiAJaWYg
KGl0X3ZpcnQpIHsKLQkJaXRfdmlydCAtPSB0aWNrczsKLQkJaWYgKCFpdF92aXJ0KSB7CisJCWlm
IChpdF92aXJ0IDw9IHRpY2tzKSB7CiAJCQlpdF92aXJ0ID0gcC0+aXRfdmlydF9pbmNyOwogCQkJ
c2VuZF9zaWcoU0lHVlRBTFJNLCBwLCAxKTsKLQkJfQorCQl9IGVsc2UKKwkJCWl0X3ZpcnQgLT0g
dGlja3M7CiAJCXAtPml0X3ZpcnRfdmFsdWUgPSBpdF92aXJ0OwogCX0KIH0KIAotc3RhdGljIGlu
bGluZSB2b2lkIGRvX2l0X3Byb2Yoc3RydWN0IHRhc2tfc3RydWN0ICpwKQorc3RhdGljIGlubGlu
ZSB2b2lkIGRvX2l0X3Byb2Yoc3RydWN0IHRhc2tfc3RydWN0ICpwLCB1bnNpZ25lZCBsb25nIHRp
Y2tzKQogewogCXVuc2lnbmVkIGxvbmcgaXRfcHJvZiA9IHAtPml0X3Byb2ZfdmFsdWU7CiAKIAlp
ZiAoaXRfcHJvZikgewotCQlpZiAoLS1pdF9wcm9mID09IDApIHsKKwkJaWYgKGl0X3Byb2YgPD0g
dGlja3MpIHsKIAkJCWl0X3Byb2YgPSBwLT5pdF9wcm9mX2luY3I7CiAJCQlzZW5kX3NpZyhTSUdQ
Uk9GLCBwLCAxKTsKLQkJfQorCQl9IGVsc2UKKwkJCWl0X3Byb2YgLT0gdGlja3M7CiAJCXAtPml0
X3Byb2ZfdmFsdWUgPSBpdF9wcm9mOwogCX0KIH0KQEAgLTU2OSw3ICs2NjgsNyBAQAogCXAtPnBl
cl9jcHVfc3RpbWVbY3B1XSArPSBzeXN0ZW07CiAJZG9fcHJvY2Vzc190aW1lcyhwLCB1c2VyLCBz
eXN0ZW0pOwogCWRvX2l0X3ZpcnQocCwgdXNlcik7Ci0JZG9faXRfcHJvZihwKTsKKwlkb19pdF9w
cm9mKHAsIHVzZXIgKyBzeXN0ZW0pOwogfQkKIAogLyoKQEAgLTU5Nyw2ICs2OTYsMzEgQEAKIH0K
IAogLyoKKyAqIENhbGxlZCBmcm9tIHRoZSB0aW1lciBpbnRlcnJ1cHQgaGFuZGxlciB0byBjaGFy
Z2UgYSBjb3VwbGUgb2YKKyAqIHN5c3RlbSBhbmQgdXNlciB0aWNrcy4gCisgKi8KK3ZvaWQgdXBk
YXRlX3Byb2Nlc3NfdGltZXMyKGludCB1c2VyLCBpbnQgc3lzdGVtKQoreworCXN0cnVjdCB0YXNr
X3N0cnVjdCAqcCA9IGN1cnJlbnQ7CisJaW50IGNwdSA9IHNtcF9wcm9jZXNzb3JfaWQoKTsKKwor
CXVwZGF0ZV9vbmVfcHJvY2VzcyhwLCB1c2VyLCBzeXN0ZW0sIGNwdSk7CisJaWYgKHAtPnBpZCkg
eworCQlwLT5jb3VudGVyIC09IHVzZXIgKyBzeXN0ZW07CisJCWlmIChwLT5jb3VudGVyIDw9IDAp
IHsKKwkJCXAtPmNvdW50ZXIgPSAwOworCQkJcC0+bmVlZF9yZXNjaGVkID0gMTsKKwkJfQorCQlp
ZiAocC0+bmljZSA+IDApCisJCQlrc3RhdC5wZXJfY3B1X25pY2VbY3B1XSArPSB1c2VyOworCQll
bHNlCisJCQlrc3RhdC5wZXJfY3B1X3VzZXJbY3B1XSArPSB1c2VyOworCQlrc3RhdC5wZXJfY3B1
X3N5c3RlbVtjcHVdICs9IHN5c3RlbTsKKwl9IGVsc2UgaWYgKGxvY2FsX2JoX2NvdW50KGNwdSkg
fHwgbG9jYWxfaXJxX2NvdW50KGNwdSkgPiAxKQorCQlrc3RhdC5wZXJfY3B1X3N5c3RlbVtjcHVd
ICs9IHN5c3RlbTsKK30KKworLyoKICAqIE5yIG9mIGFjdGl2ZSB0YXNrcyAtIGNvdW50ZWQgaW4g
Zml4ZWQtcG9pbnQgbnVtYmVycwogICovCiBzdGF0aWMgdW5zaWduZWQgbG9uZyBjb3VudF9hY3Rp
dmVfdGFza3Modm9pZCkKQEAgLTYyOCw3ICs3NTIsNyBAQAogCXN0YXRpYyBpbnQgY291bnQgPSBM
T0FEX0ZSRVE7CiAKIAljb3VudCAtPSB0aWNrczsKLQlpZiAoY291bnQgPCAwKSB7CisJd2hpbGUg
KGNvdW50IDwgMCkgewogCQljb3VudCArPSBMT0FEX0ZSRVE7CiAJCWFjdGl2ZV90YXNrcyA9IGNv
dW50X2FjdGl2ZV90YXNrcygpOwogCQlDQUxDX0xPQUQoYXZlbnJ1blswXSwgRVhQXzEsIGFjdGl2
ZV90YXNrcyk7CkBAIC02NTAsNyArNzc0LDcgQEAKIAl1bnNpZ25lZCBsb25nIHRpY2tzOwogCiAJ
LyoKLQkgKiB1cGRhdGVfdGltZXMoKSBpcyBydW4gZnJvbSB0aGUgcmF3IHRpbWVyX2JoIGhhbmRs
ZXIgc28gd2UKKwkgKiBkb191cGRhdGVfdGltZXMoKSBpcyBydW4gZnJvbSB0aGUgcmF3IHRpbWVy
X2JoIGhhbmRsZXIgc28gd2UKIAkgKiBqdXN0IGtub3cgdGhhdCB0aGUgaXJxcyBhcmUgbG9jYWxs
eSBlbmFibGVkIGFuZCBzbyB3ZSBkb24ndAogCSAqIG5lZWQgdG8gc2F2ZS9yZXN0b3JlIHRoZSBm
bGFncyBvZiB0aGUgbG9jYWwgQ1BVIGhlcmUuIC1hcmNhCiAJICovCkBAIC02NjUsMTIgKzc4OSw0
OSBAQAogCWNhbGNfbG9hZCh0aWNrcyk7CiB9CiAKK3ZvaWQgdXBkYXRlX3RpbWVzX2lycXNhdmUo
dm9pZCkKK3sKKwl1bnNpZ25lZCBsb25nIHRpY2tzOworCXVuc2lnbmVkIGxvbmcgZmxhZ3M7CisK
KwkvKgorCSAqIGRvX3VwZGF0ZV90aW1lcygpIGlzIHJ1biBmcm9tIHRoZSByYXcgdGltZXJfYmgg
aGFuZGxlciBzbyB3ZQorCSAqIGp1c3Qga25vdyB0aGF0IHRoZSBpcnFzIGFyZSBsb2NhbGx5IGVu
YWJsZWQgYW5kIHNvIHdlIGRvbid0CisJICogbmVlZCB0byBzYXZlL3Jlc3RvcmUgdGhlIGZsYWdz
IG9mIHRoZSBsb2NhbCBDUFUgaGVyZS4gLWFyY2EKKwkgKi8KKwl3cml0ZV9sb2NrX2lycXNhdmUo
Jnh0aW1lX2xvY2ssIGZsYWdzKTsKKworCXRpY2tzID0gamlmZmllcyAtIHdhbGxfamlmZmllczsK
KwlpZiAodGlja3MpIHsKKwkJd2FsbF9qaWZmaWVzICs9IHRpY2tzOworCQl1cGRhdGVfd2FsbF90
aW1lKHRpY2tzKTsKKwl9CisJd3JpdGVfdW5sb2NrX2lycXJlc3RvcmUoJnh0aW1lX2xvY2ssIGZs
YWdzKTsKKwljYWxjX2xvYWQodGlja3MpOworfQorCiB2b2lkIHRpbWVyX2JoKHZvaWQpCiB7CiAJ
dXBkYXRlX3RpbWVzKCk7CiAJcnVuX3RpbWVyX2xpc3QoKTsKKyNpZmRlZiBDT05GSUdfTk9fSFpf
VElNRVIKKwlpZiAodGltZXJfbm90aWZ5ICE9IE5VTEwpIHsKKwkJc3RydWN0IHRpbWVyX2xpc3Qg
KnRpbWVyOworCQl1bnNpZ25lZCBsb25nIGZsYWdzOworCisJCXNwaW5fbG9ja19pcnFzYXZlKCZ0
aW1lcmxpc3RfbG9jaywgZmxhZ3MpOworCQl0aW1lciA9IG5leHRfdGltZXJfZXZlbnQoKTsKKwkJ
aWYgKHRpbWVyICE9IE5VTEwpIHsKKwkJCSgqdGltZXJfbm90aWZ5KSh0aW1lci0+ZXhwaXJlcyk7
CisJCQlub3RpZnlfamlmZnkgPSB0aW1lci0+ZXhwaXJlczsKKwkJfSBlbHNlCisJCQlub3RpZnlf
amlmZnkgPSAwOworCQlzcGluX3VubG9ja19pcnFyZXN0b3JlKCZ0aW1lcmxpc3RfbG9jaywgZmxh
Z3MpOworCX0KKyNlbmRpZgogfQogCisjaWZuZGVmIENPTkZJR19OT19IWl9USU1FUgogdm9pZCBk
b190aW1lcihzdHJ1Y3QgcHRfcmVncyAqcmVncykKIHsKIAkoKih1bnNpZ25lZCBsb25nICopJmpp
ZmZpZXMpKys7CkBAIC02ODMsNiArODQ0LDcgQEAKIAlpZiAoVFFfQUNUSVZFKHRxX3RpbWVyKSkK
IAkJbWFya19iaChUUVVFVUVfQkgpOwogfQorI2VuZGlmCiAKICNpZiAhZGVmaW5lZChfX2FscGhh
X18pICYmICFkZWZpbmVkKF9faWE2NF9fKQogCg==

--0__=AxUwewK46NPW3l78cMfeqzg27zDccjV0SOMwunyt3i8B0oHhABq1qiLy--

