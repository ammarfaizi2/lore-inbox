Return-Path: <linux-kernel-owner+willy=40w.ods.org-S964980AbVLMRPe@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S964980AbVLMRPe (ORCPT <rfc822;willy@w.ods.org>);
	Tue, 13 Dec 2005 12:15:34 -0500
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S964986AbVLMRPe
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Tue, 13 Dec 2005 12:15:34 -0500
Received: from rtsoft2.corbina.net ([85.21.88.2]:54737 "HELO
	mail.dev.rtsoft.ru") by vger.kernel.org with SMTP id S964980AbVLMRPd
	(ORCPT <rfc822;linux-kernel@vger.kernel.org>);
	Tue, 13 Dec 2005 12:15:33 -0500
Subject: Re: [spi-devel-general] Re: [PATCH 2.6-git 0/4] SPI core refresh
From: dmitry pervushin <dpervushin@gmail.com>
To: Rui Sousa <rui.sousa@laposte.net>
Cc: Vitaly Wool <vwool@ru.mvista.com>,
       Linux Kernel Mailing List <linux-kernel@vger.kernel.org>,
       David Brownell <david-b@pacbell.net>, basicmark@yahoo.com,
       komal_shah802003@yahoo.com, stephen@streetfiresound.com,
       spi-devel-general@lists.sourceforge.net, Joachim_Jaeger@digi.com
In-Reply-To: <1134486683.10394.7.camel@localhost.localdomain>
References: <20051212182026.4e393d5a.vwool@ru.mvista.com>
	 <1134410498.12925.8.camel@localhost.localdomain>
	 <1134475765.1590.2.camel@fj-laptop>
	 <1134486683.10394.7.camel@localhost.localdomain>
Content-Type: text/plain
Date: Tue, 13 Dec 2005 20:06:22 +0300
Message-Id: <1134493582.1590.26.camel@fj-laptop>
Mime-Version: 1.0
X-Mailer: Evolution 2.0.1 
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, 2005-12-13 at 16:11 +0100, Rui Sousa wrote:
> On Tue, 2005-12-13 at 15:09 +0300, dmitry pervushin wrote:
> > On Mon, 2005-12-12 at 19:01 +0100, Rui Sousa wrote:
> > > How do you handle IRQ's generated by a SPI device (e.g ack the
> > > interrupt, check if it was the SPI device that generated the
> > > interrupt, ...) if you can't read/write on the SPI bus from interrupt
> > > context?
> > Hmm... what do you mean by "cannot read/write" ? Normally you can
> > write/read registers in interrupt context
> 
I expect the answer from David Brownell too; and, because both discussed
frameworks are going to be the only (and the best), please also pay
attention to his (possible) answer. But I'd comment your code :)
> If I read the API correctly reading/writing a byte from the SPI bus
> (synchronously) always implies putting the task doing the read to sleep:
> 
> int spi_transfer(struct spi_msg *msg, void (*callback) (struct spi_msg
> *, int))
> {
> 
> ...
> 	err = TO_SPI_BUS_DRIVER(bus->driver)->queue(msg);
> 	wait_for_completion(&msg->sync);
> ...
> }
> 
> So, how can I, from an interrupt handler, read/write a couple of bytes
> from my SPI device using this API?
You can issue the request (in terms of core that you are using, queue
the message) in interrupt context, and perform the rest of processing in
`status' callback. It will be called when message is processed. You can
ack the irq here, and continue your processing. 


