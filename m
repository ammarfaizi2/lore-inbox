Return-Path: <linux-kernel-owner+willy=40w.ods.org-S261796AbVGEKU5@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261796AbVGEKU5 (ORCPT <rfc822;willy@w.ods.org>);
	Tue, 5 Jul 2005 06:20:57 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261778AbVGEKU4
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Tue, 5 Jul 2005 06:20:56 -0400
Received: from mx1.redhat.com ([66.187.233.31]:6538 "EHLO mx1.redhat.com")
	by vger.kernel.org with ESMTP id S261796AbVGEKT0 (ORCPT
	<rfc822;linux-kernel@vger.kernel.org>);
	Tue, 5 Jul 2005 06:19:26 -0400
Date: Tue, 05 Jul 2005 19:12:21 +0900 (JST)
Message-Id: <20050705.191221.92572119.jet@gyve.org>
To: linux-usb-devel@lists.sourceforge.net
Cc: linux-kernel@vger.kernel.org
Subject: [PATCH] Avoid to use kmalloc in usb/core/message.c
From: Masatake YAMATO <jet@gyve.org>
X-Mailer: Mew version 4.2 on Emacs 22.0.50 / Mule 5.0 (SAKAKI)
Mime-Version: 1.0
Content-Type: Text/Plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

In some functions in drivers/usb/core/message.c kmalloc is used to
allocate fix size of memory chunks; and the chunks is freed at the end
of each functions. The sizes are not so large: 8(struct
usb_ctrlrequest), 18(struct usb_device_descriptor), and 2(u16) bytes.
I wonder why the invocations of kmalloc are needed in these functions.

Following patch is for avoiding invocations of kmalloc. Instead stacks
are used.

The patch is generated by co-diff against 
rsync://kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git


Signed-off-by: Masatake YAMATO <jet@gyve.org>

Index: drivers/usb/core/message.c
===================================================================
--- 6f51e67e4a433ee0ff866a6ac18a4bce798fe0c7/drivers/usb/core/message.c  (mode:100644)
+++ uncommitted/drivers/usb/core/message.c  (mode:100644)
@@ -142,11 +142,9 @@
 int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request, __u8 requesttype,
                         __u16 value, __u16 index, void *data, __u16 size, int timeout)
 {
-       struct usb_ctrlrequest *dr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_NOIO);
+       struct usb_ctrlrequest dr_rec;
+       struct usb_ctrlrequest *dr = &dr_rec;
        int ret;
-
-       if (!dr)
-               return -ENOMEM;

        dr->bRequestType= requesttype;
        dr->bRequest = request;
@@ -158,7 +156,6 @@

        ret = usb_internal_control_msg(dev, pipe, dr, data, size, timeout);

-       kfree(dr);

        return ret;
 }
@@ -794,19 +791,17 @@
  */
 int usb_get_device_descriptor(struct usb_device *dev, unsigned int size)
 {
+       struct usb_device_descriptor  desc_rec;
        struct usb_device_descriptor *desc;
        int ret;

        if (size > sizeof(*desc))
                return -EINVAL;
-       desc = kmalloc(sizeof(*desc), GFP_NOIO);
-       if (!desc)
-               return -ENOMEM;
+       desc = &desc_rec;

        ret = usb_get_descriptor(dev, USB_DT_DEVICE, 0, desc, size);
        if (ret >= 0)
                memcpy(&dev->descriptor, desc, size);
-       kfree(desc);
        return ret;
 }

@@ -835,17 +830,13 @@
 int usb_get_status(struct usb_device *dev, int type, int target, void *data)
 {
        int ret;
-       u16 *status = kmalloc(sizeof(*status), GFP_KERNEL);
-
-       if (!status)
-               return -ENOMEM;
+       u16 status;

        ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
-               USB_REQ_GET_STATUS, USB_DIR_IN | type, 0, target, status,
-               sizeof(*status), USB_CTRL_GET_TIMEOUT);
+               USB_REQ_GET_STATUS, USB_DIR_IN | type, 0, target, &status,
+               sizeof(status), USB_CTRL_GET_TIMEOUT);

-       *(u16 *)data = *status;
-       kfree(status);
+       *(u16 *)data = status;
        return ret;
 }

