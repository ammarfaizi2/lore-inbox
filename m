Return-Path: <linux-kernel-owner+willy=40w.ods.org-S268355AbUJDDY3@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S268355AbUJDDY3 (ORCPT <rfc822;willy@w.ods.org>);
	Sun, 3 Oct 2004 23:24:29 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S268356AbUJDDY3
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Sun, 3 Oct 2004 23:24:29 -0400
Received: from sv1.valinux.co.jp ([210.128.90.2]:20708 "EHLO sv1.valinux.co.jp")
	by vger.kernel.org with ESMTP id S268355AbUJDDY1 (ORCPT
	<rfc822;linux-kernel@vger.kernel.org>);
	Sun, 3 Oct 2004 23:24:27 -0400
Date: Mon, 04 Oct 2004 12:24:25 +0900
From: IWAMOTO Toshihiro <iwamoto@valinux.co.jp>
To: Marcelo Tosatti <marcelo.tosatti@cyclades.com>
Cc: Hirokazu Takahashi <taka@valinux.co.jp>, iwamoto@valinux.co.jp,
       haveblue@us.ibm.com, akpm@osdl.org, linux-mm@kvack.org,
       piggin@cyberone.com.au, arjanv@redhat.com, linux-kernel@vger.kernel.org
Subject: Re: [RFC] memory defragmentation to satisfy high order allocations
In-Reply-To: <20041003140723.GD4635@logos.cnet>
References: <20041001234200.GA4635@logos.cnet>
	<20041002.183015.41630389.taka@valinux.co.jp>
	<20041002183349.GA7986@logos.cnet>
	<20041003.131338.41636688.taka@valinux.co.jp>
	<20041003140723.GD4635@logos.cnet>
User-Agent: Wanderlust/2.10.1 (Watching The Wheels) SEMI/1.14.6 (Maruoka) FLIM/1.14.6 (Marutamachi) APEL/10.6 Emacs/21.3 (i386-pc-linux-gnu) MULE/5.0 (SAKAKI)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Message-Id: <20041004032425.AD3F470A2D@sv1.valinux.co.jp>
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

At Sun, 3 Oct 2004 11:07:23 -0300,
Marcelo Tosatti wrote:
> 
> On Sun, Oct 03, 2004 at 01:13:38PM +0900, Hirokazu Takahashi wrote:
> > > 2) 
> > > At migrate_onepage you add anonymous pages which aren't swap allocated
> > > to the swap cache
> > > +       /*
> > > +        * Put the page in a radix tree if it isn't in the tree yet.
> > > +        */
> > > +#ifdef CONFIG_SWAP
> > > +       if (PageAnon(page) && !PageSwapCache(page))
> > > +               if (!add_to_swap(page, GFP_KERNEL)) {
> > > +                       unlock_page(page);
> > > +                       return ERR_PTR(-ENOSPC);
> > > +               }
> > > +#endif /* CONFIG_SWAP */
> > > 
> > > Why's that? You can copy anonymous pages without adding them to swap (thats
> > > what the patch I posted does).
> > 
> > The reason is to guarantee that any anonymous page can be migrated anytime.
> > I want to block newly occurred accesses to the page during the migration
> > because it can't be migrated if there remain some references on it by
> > system calls, direct I/O and page faults.
> 
> It would be nice if we could block pte faults in a way such to not need
> adding each anonymous page to swap. It can be too costly if you have a lot memory
> and it makes the whole operation dependable on swap size (if you dont have enough
> swap, you're dead).
> 
> Maybe hold mm->page_table_lock (might be too costly in terms of CPU time, but since
> migration is not a common operation anyway), or create a semaphore? 

I chose the swap cache based implementation in order to minimize
slowdown of the normal code path.  (I thought there's zero code
addition on the normal pagefault path when I designed this, but it's
no longer true...)

If we can agree on adding a new lock, there might be a better
implementation.

--
IWAMOTO Toshihiro
