Return-Path: <linux-kernel-owner+willy=40w.ods.org-S932261AbWFVFsG@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932261AbWFVFsG (ORCPT <rfc822;willy@w.ods.org>);
	Thu, 22 Jun 2006 01:48:06 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S932798AbWFVFsG
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Thu, 22 Jun 2006 01:48:06 -0400
Received: from e5.ny.us.ibm.com ([32.97.182.145]:12196 "EHLO e5.ny.us.ibm.com")
	by vger.kernel.org with ESMTP id S932261AbWFVFsE (ORCPT
	<rfc822;linux-kernel@vger.kernel.org>);
	Thu, 22 Jun 2006 01:48:04 -0400
Subject: Re: [Lse-tech] [PATCH 00/11] Task watchers:  Introduction
From: Matt Helsley <matthltc@us.ibm.com>
To: Peter Williams <pwil3058@bigpond.net.au>
Cc: Andrew Morton <akpm@osdl.org>, Shailabh Nagar <nagar@watson.ibm.com>,
       Chandra S Seetharaman <sekharan@us.ibm.com>,
       John T Kohl <jtk@us.ibm.com>, Balbir Singh <balbir@in.ibm.com>,
       Jes Sorensen <jes@sgi.com>, Linux-Kernel <linux-kernel@vger.kernel.org>,
       Alan Stern <stern@rowland.harvard.edu>,
       LSE-Tech <lse-tech@lists.sourceforge.net>
In-Reply-To: <449A1C0D.7030906@bigpond.net.au>
References: <1150242721.21787.138.camel@stark>
	 <4498DC23.2010400@bigpond.net.au> <1150876292.21787.911.camel@stark>
	 <44992EAA.6060805@bigpond.net.au> <44993079.40300@bigpond.net.au>
	 <1150925387.21787.1056.camel@stark> <4499D097.5030604@bigpond.net.au>
	 <1150936337.21787.1114.camel@stark> <4499EE29.9020703@bigpond.net.au>
	 <1150947965.21787.1228.camel@stark>  <449A1C0D.7030906@bigpond.net.au>
Content-Type: text/plain
Date: Wed, 21 Jun 2006 22:37:00 -0700
Message-Id: <1150954621.21787.1272.camel@stark>
Mime-Version: 1.0
X-Mailer: Evolution 2.0.4 
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

On Thu, 2006-06-22 at 14:26 +1000, Peter Williams wrote:

<snip>

> >>>> BTW as a former user of PAGG, I think there are ideas in the PAGG 
> >>>> implementation that you should look at.  In particular:
> >>>>
> >>>> 1. The use of an array of function pointers (one for each hook) can cut 
> >>>> down on the overhead.  The notifier_block only needs to contain a 
> >>>> pointer to the array so there's no increase in the size of that 
> >>>> structure.  Within the array a null pointer would mean "don't bother 
> >>>> calling".  Only one real array needs to exist even for per task as 
> >>>> they're all using the same functions (just separate data).  It removes 
> >>>> the need for a switch statement in the client's function as well as 
> >>>> saving on unnecessary function calls.
> >>> 	I don't think having an explicit array of function pointers is likely
> >>> to be as fast as a switch statement (or a simple branch) generated by
> >>> the compiler.
> >> With the array there's no need for any switch or branching.  You know 
> >> exactly which function in the array to use in each hook.
> > 
> > 	I don't forsee enough of a difference to make this worth arguing about.
> > You're welcome to benchmark and compare arrays vs. switches/branches on
> > a variety of archs, SMP boxen, NUMA boxen, etc. and post the results.
> > I'm going to focus on other issues for now.
> > 
> >>> 	It doesn't save unecessary function calls unless I modify the core
> >>> notifier block structure. Otherwise I still need to stuff a generic
> >>> function into .notifier_call and from there get the pointer to the array
> >>> to make the next call. So it adds more pointer indirection but does not
> >>> reduce the number of intermediate function calls.
> >> There comes a point when trying to reuse existing code is less cost 
> >> effective than starting over.
> > 
> > Write my own notifier chains just to avoid a function call? I don't
> > think that's sufficient justification for implementing my own.
> 
> Can't help thinking why the easier option of adding setuid and setgid 
> hooks to PAGG and then including PAGG wasn't adopted.

	Task watchers is not intended to group tasks. It's intended to factor a
common pattern out of these paths in a way useful to existing parts of
the kernel, proposed changes, and modules.

	Your goal of grouping tasks seems like it could use task watchers. That
does not mean that every task watcher needs to manage groups of tasks.

Cheers,
	-Matt Helsley

