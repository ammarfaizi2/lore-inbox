Return-Path: <linux-kernel-owner@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id <S264256AbRFDNfl>; Mon, 4 Jun 2001 09:35:41 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org
	id <S264257AbRFDNfc>; Mon, 4 Jun 2001 09:35:32 -0400
Received: from smtp.alcove.fr ([212.155.209.139]:59911 "EHLO smtp.alcove.fr")
	by vger.kernel.org with ESMTP id <S264256AbRFDNfT>;
	Mon, 4 Jun 2001 09:35:19 -0400
Date: Mon, 4 Jun 2001 15:35:15 +0200
From: Stelian Pop <stelian.pop@fr.alcove.com>
To: linux-kernel@vger.kernel.org
Subject: [PATCH 2.4.5] New driver for Sony Programmable I/O Control Device
Message-ID: <20010604153515.A31991@ontario.alcove-fr>
Reply-To: Stelian Pop <stelian.pop@fr.alcove.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
User-Agent: Mutt/1.2.4i
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

Hi,

You'll find attached a driver for the Sony Programmable I/O
Control Device, which can be found on many (all ?) Sony Vaio
laptops.

This driver enables a user mode application to receive (through
a misc character device node) the events generated by:
	- the jogdial (the small wheel)
	- the capture button (on picture book series)
	- the Fn keys (on some laptops only)
	- the bluetooth button (if you have one :-) ).

A sample application, demonstrating the polling of the character
device and translating the jogdial events into X mousewheel events
can be found at:
	http://mapage.noos.fr/pop/sonypi/sonypid.tar.gz
(note that this location is different from the one documented
in Documentation/sonypi.txt, since the latter is rather slow to
update, but it will be the the stable one).

This driver is also a prerequisite for the video4linux driver
for the Motion Eye camera (found on Vaio Picturebook series),
which I wrote and I'm cleaning up a bit right now, before I send
it on the list, probably by the end of this week.

The patch is attached below and should apply cleanly on 2.4.5.

Thanks,

Stelian.

diff -uNr --exclude-from=dontdiff linux-2.4.5.orig/Documentation/Configure.help linux-2.4.5/Documentation/Configure.help
--- linux-2.4.5.orig/Documentation/Configure.help	Thu May 31 17:18:44 2001
+++ linux-2.4.5/Documentation/Configure.help	Sun Jun  3 15:58:20 2001
@@ -13695,6 +13695,19 @@
 
   If unsure, say N.
 
+Sony Vaio Programmable I/O Control Device support
+CONFIG_SONYPI
+  This driver enables access to the Sony Programmable I/O Control Device
+  which can be found in many (all ?) Sony Vaio laptops.
+
+  If you have one of those laptops, read Documentation/sonypi.txt,
+  and say Y or M here.
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called sonypi.o.
+
 Intel Random Number Generator support
 CONFIG_INTEL_RNG
   This driver provides kernel-side support for the Random Number
diff -uNr --exclude-from=dontdiff linux-2.4.5.orig/Documentation/sonypi.txt linux-2.4.5/Documentation/sonypi.txt
--- linux-2.4.5.orig/Documentation/sonypi.txt	Thu Jan  1 01:00:00 1970
+++ linux-2.4.5/Documentation/sonypi.txt	Sun Jun  3 15:36:43 2001
@@ -0,0 +1,45 @@
+Sony Programmable I/O Control Device Driver Readme
+--------------------------------------------------
+	Copyright (C) 2001 Stelian Pop <stelian.pop@fr.alcove.com>, Alcôve
+	Copyright (C) 2001 Junichi Morita <jun1m@mars.dti.ne.jp>
+	Copyright (C) 2000 Takaya Kinjo <t-kinjo@tc4.so-net.ne.jp>
+	Copyright (C) 2000 Andrew Tridgell <tridge@samba.org>
+
+This driver enables access to the Sony Programmable I/O Control Device which
+can be found in many (all ?) Sony Vaio laptops.
+
+It will give access (through a user space utility) to some events those laptops
+generate, like:
+	- jogdial events (the small wheel on the side of Vaios)
+	- capture button events (only on Vaio Picturebook series)
+	- Fn keys
+	- bluetooth button (only on C1VR model)
+
+Those events (see linux/sonypi.h) can be polled using the character device node
+/dev/sonypi (major 10, minor auto allocated or specified as a option).
+
+A simple daemon which translates the jogdial movements into mouse wheel events
+can be downloaded at: <http://www.alcove-labs.org/en/software/sonypi/>
+
+This driver can also be used to set the camera controls on Picturebook series
+(brightness, contrast etc), and is used by the video4linux driver for the 
+Motion Eye camera.
+
+Please note that this driver was created by reverse engineering the Windows
+driver and the ACPI BIOS, because Sony doesn't agree to release any programming
+specs for its laptops. If someone convinces them to do so, drop me a note.
+
+Module options:
+---------------
+
+	minor: 		minor number of the misc device /dev/sonypi, 
+			default is -1 (automatic allocation, see /proc/misc
+			or kernel logs)
+
+	verbose:	print unknown events from the sonypi device
+
+Bugs:
+-----
+
+	- the Fn keys events seem to work on some Vaio models, but not on others
+	  (it doesn't work on C1VE, C1VR)...
diff -uNr --exclude-from=dontdiff linux-2.4.5.orig/drivers/char/Config.in linux-2.4.5/drivers/char/Config.in
--- linux-2.4.5.orig/drivers/char/Config.in	Wed Mar  7 04:44:34 2001
+++ linux-2.4.5/drivers/char/Config.in	Sun Jun  3 15:56:02 2001
@@ -169,6 +169,9 @@
 tristate 'Double Talk PC internal speech card support' CONFIG_DTLK
 tristate 'Siemens R3964 line discipline' CONFIG_R3964
 tristate 'Applicom intelligent fieldbus card support' CONFIG_APPLICOM
+if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+  tristate 'Sony Vaio Programmable I/O Control Device support' CONFIG_SONYPI $CONFIG_PCI
+fi
 
 mainmenu_option next_comment
 comment 'Ftape, the floppy tape device driver'
diff -uNr --exclude-from=dontdiff linux-2.4.5.orig/drivers/char/Makefile linux-2.4.5/drivers/char/Makefile
--- linux-2.4.5.orig/drivers/char/Makefile	Thu May 31 17:18:55 2001
+++ linux-2.4.5/drivers/char/Makefile	Sun Jun  3 15:44:15 2001
@@ -23,7 +23,7 @@
 
 export-objs     :=	busmouse.o console.o keyboard.o sysrq.o \
 			misc.o pty.o random.o selection.o serial.o \
-			tty_io.o
+			sonypi.o tty_io.o
 
 mod-subdirs	:=	joystick ftape drm pcmcia
 
@@ -162,6 +162,7 @@
 obj-$(CONFIG_DTLK) += dtlk.o
 obj-$(CONFIG_R3964) += n_r3964.o
 obj-$(CONFIG_APPLICOM) += applicom.o
+obj-$(CONFIG_SONYPI) += sonypi.o
 obj-$(CONFIG_MS_BUSMOUSE) += msbusmouse.o
 obj-$(CONFIG_82C710_MOUSE) += qpmouse.o
 obj-$(CONFIG_AMIGAMOUSE) += amigamouse.o
diff -uNr --exclude-from=dontdiff linux-2.4.5.orig/drivers/char/sonypi.c linux-2.4.5/drivers/char/sonypi.c
--- linux-2.4.5.orig/drivers/char/sonypi.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.5/drivers/char/sonypi.c	Mon Jun  4 14:45:40 2001
@@ -0,0 +1,587 @@
+/* 
+ * Sony Programmable I/O Control Device driver for VAIO
+ *
+ * Copyright (C) 2001 Stelian Pop <stelian.pop@fr.alcove.com>, Alcôve
+ *
+ * Copyright (C) 2001 Junichi Morita <jun1m@mars.dti.ne.jp>
+ *
+ * Copyright (C) 2000 Takaya Kinjo <t-kinjo@tc4.so-net.ne.jp>
+ *
+ * Copyright (C) 2000 Andrew Tridgell <tridge@valinux.com>
+ *
+ * Earlier work by Werner Almesberger, Paul `Rusty' Russell and Paul Mackerras.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include "sonypi.h"
+#include <linux/sonypi.h>
+
+static struct sonypi_device sonypi_device;
+static int minor = -1;
+static int verbose; /* = 0 */
+
+/* Inits the queue */
+static inline void sonypi_initq(void) {
+        sonypi_device.queue.head = sonypi_device.queue.tail = 0;
+	sonypi_device.queue.len = 0;
+	sonypi_device.queue.s_lock = (spinlock_t)SPIN_LOCK_UNLOCKED;
+	init_waitqueue_head(&sonypi_device.queue.proc_list);
+}
+
+/* Pulls an event from the queue */
+static inline unsigned char sonypi_pullq(void) {
+        unsigned char result;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sonypi_device.queue.s_lock, flags);
+	if (!sonypi_device.queue.len) {
+		spin_unlock_irqrestore(&sonypi_device.queue.s_lock, flags);
+		return 0;
+	}
+	result = sonypi_device.queue.buf[sonypi_device.queue.head];
+        sonypi_device.queue.head++;
+	sonypi_device.queue.head &= (SONYPI_BUF_SIZE - 1);
+	sonypi_device.queue.len--;
+	spin_unlock_irqrestore(&sonypi_device.queue.s_lock, flags);
+        return result;
+}
+
+/* Pushes an event into the queue */
+static inline void sonypi_pushq(unsigned char event) {
+	unsigned long flags;
+
+	spin_lock_irqsave(&sonypi_device.queue.s_lock, flags);
+	if (sonypi_device.queue.len == SONYPI_BUF_SIZE) {
+		/* remove the first element */
+        	sonypi_device.queue.head++;
+		sonypi_device.queue.head &= (SONYPI_BUF_SIZE - 1);
+		sonypi_device.queue.len--;
+	}
+	sonypi_device.queue.buf[sonypi_device.queue.tail] = event;
+	sonypi_device.queue.tail++;
+	sonypi_device.queue.tail &= (SONYPI_BUF_SIZE - 1);
+	sonypi_device.queue.len++;
+
+	kill_fasync(&sonypi_device.queue.fasync, SIGIO, POLL_IN);
+	wake_up_interruptible(&sonypi_device.queue.proc_list);
+	spin_unlock_irqrestore(&sonypi_device.queue.s_lock, flags);
+}
+
+/* Tests if the queue is empty */
+static inline int sonypi_emptyq(void) {
+        int result;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sonypi_device.queue.s_lock, flags);
+        result = (sonypi_device.queue.len == 0);
+	spin_unlock_irqrestore(&sonypi_device.queue.s_lock, flags);
+        return result;
+}
+
+/* Initializes the device - this comes from the AML code in the ACPI bios */
+static void __devinit sonypi_srs(void) {
+	u32 v;
+
+	pci_read_config_dword(sonypi_device.dev, SONYPI_G10A, &v);
+	v = (v & 0xFFFF0000) | ((u32)sonypi_device.ioport1);
+	pci_write_config_dword(sonypi_device.dev, SONYPI_G10A, v);
+
+	pci_read_config_dword(sonypi_device.dev, SONYPI_G10A, &v);
+	v = (v & 0xFFF0FFFF) | 
+	    (((u32)sonypi_device.ioport1 ^ sonypi_device.ioport2) << 16);
+	pci_write_config_dword(sonypi_device.dev, SONYPI_G10A, v);
+
+	v = inl(SONYPI_IRQ_PORT);
+	v &= ~(((u32)0x3) << SONYPI_IRQ_SHIFT);
+	v |= (((u32)sonypi_device.bits) << SONYPI_IRQ_SHIFT);
+	outl(v, SONYPI_IRQ_PORT);
+
+	pci_read_config_dword(sonypi_device.dev, SONYPI_G10A, &v);
+	v = (v & 0xFF1FFFFF) | 0x00C00000;
+	pci_write_config_dword(sonypi_device.dev, SONYPI_G10A, v);
+}
+
+/* Disables the device - this comes from the AML code in the ACPI bios */
+static void __devexit sonypi_dis(void) {
+	u32 v;
+
+	pci_read_config_dword(sonypi_device.dev, SONYPI_G10A, &v);
+	v = v & 0xFF3FFFFF;
+	pci_write_config_dword(sonypi_device.dev, SONYPI_G10A, v);
+
+	v = inl(SONYPI_IRQ_PORT);
+	v |= (0x3 << SONYPI_IRQ_SHIFT);
+	outl(v, SONYPI_IRQ_PORT);
+}
+
+static u8 sonypi_call1(u8 dev) {
+	u8 v1, v2;
+
+	while (inb_p(sonypi_device.ioport2) & 2)
+		wait_ms(1);
+	outb(dev, sonypi_device.ioport2);
+	v1 = inb_p(sonypi_device.ioport2);
+	v2 = inb_p(sonypi_device.ioport1);
+	return v2;
+}
+
+static u8 sonypi_call2(u8 dev, u8 fn) {
+	u8 v1;
+
+	while (inb_p(sonypi_device.ioport2) & 2)
+		wait_ms(1);
+	outb(dev, sonypi_device.ioport2);
+
+	while (inb_p(sonypi_device.ioport2) & 2)
+		wait_ms(1);
+	outb(fn, sonypi_device.ioport1);
+
+	v1 = inb_p(sonypi_device.ioport1);
+	return v1;
+}
+
+static u8 sonypi_call3(u8 dev, u8 fn, u8 v) {
+	u8 v1;
+
+	while (inb_p(sonypi_device.ioport2) & 2)
+		wait_ms(1);
+	outb(dev, sonypi_device.ioport2);
+
+	while (inb_p(sonypi_device.ioport2) & 2)
+		wait_ms(1);
+	outb(fn, sonypi_device.ioport1);
+
+	while (inb_p(sonypi_device.ioport2) & 2)
+		wait_ms(1);
+	outb(v, sonypi_device.ioport1);
+
+	v1 = inb_p(sonypi_device.ioport1);
+	return v1;
+}
+
+static u8 sonypi_read(u8 fn) {
+	u8 v1, v2;
+	int n = 100;
+
+	while (n--) {
+		v1 = sonypi_call2(0x8f, fn);
+		v2 = sonypi_call2(0x8f, fn);
+		if (v1 == v2 && v1 != 0xff)
+			return v1;
+	}
+	return 0xff;
+}
+
+/* Set brightness, hue etc */
+static void sonypi_set(u8 fn, u8 v) {
+	int n = 100;
+	
+	while (n--)
+		if (sonypi_call3(0x90, fn, v) == 0) 
+			break;
+}
+
+/* Tests if the camera is ready */
+static int sonypi_camera_ready(void) {
+	u8 v;
+
+	v = sonypi_call2(0x8f, SONYPI_CAMERA_STATUS);
+	return (v != 0xff && (v & SONYPI_CAMERA_STATUS_READY));
+}
+
+/* Turns the camera off */
+static void sonypi_camera_off(void) {
+
+	if (!sonypi_device.camera_power)
+		return;
+
+	sonypi_call2(0x91, 0); 
+	sonypi_device.camera_power = 0;
+}
+
+/* Turns the camera on */
+static void sonypi_camera_on(void) {
+	int i, j;
+
+	if (sonypi_device.camera_power)
+		return;
+
+	for (j = 5; j > 0; j--) {
+
+		while (sonypi_call2(0x91, 0x1) != 0) 
+			wait_ms(1);
+		sonypi_call1(0x93);
+
+		for (i = 400; i > 0; i--) {
+			if (sonypi_camera_ready())
+				break;
+			wait_ms(1);
+		}
+		if (i != 0)
+			break;
+	}
+	
+	if (j == 0) {
+		printk(KERN_WARNING "sonypi: failed to power on camera\n");
+		return;
+	}
+
+	sonypi_set(0x10, 0x5a);
+	sonypi_device.camera_power = 1;
+}
+
+/* Interrupt handler: some event is available */
+void sonypi_irq(int irq, void *dev_id, struct pt_regs *regs) {
+	u8 v1, v2, event = 0;
+	int i;
+
+	v1 = inb_p(sonypi_device.ioport1);
+	v2 = inb_p(sonypi_device.ioport2) & 0xf0;
+
+	switch (v2) {
+		case SONYPI_JOGGER_EV:
+			for (i = 0; sonypi_joggerev[i].event; i++)
+				if (sonypi_joggerev[i].data == v1) {
+					event = sonypi_joggerev[i].event;
+					break;
+				}
+			break;
+		case SONYPI_CAPTURE_EV:
+			for (i = 0; sonypi_captureev[i].event; i++)
+				if (sonypi_captureev[i].data == v1) {
+					event = sonypi_captureev[i].event;
+					break;
+				}
+			break;
+		case SONYPI_FNKEY_EV:
+			for (i = 0; sonypi_fnkeyev[i].event; i++)
+				if (sonypi_fnkeyev[i].data == v1) {
+					event = sonypi_fnkeyev[i].event;
+					break;
+				}
+			break;
+		case SONYPI_BLUETOOTH_EV:
+			for (i = 0; sonypi_blueev[i].event; i++)
+				if (sonypi_blueev[i].data == v1) {
+					event = sonypi_blueev[i].event;
+					break;
+				}
+			break;
+		case 0x0c:
+		case 0x04:
+		case 0xff:
+			/* the answer event from the write reqest to ioport? */
+			return;
+	}
+	if (event)
+		sonypi_pushq(event);
+	else if (verbose)
+		printk(KERN_WARNING 
+		       "sonypi: unknown event port1=0x%x,port2=0x%x\n",v1,v2);
+}
+
+/* External camera command (exported to the motion eye v4l driver */
+u8 sonypi_camera_command(int command, u8 value) {
+	u8 ret = 0;
+
+	down(&sonypi_device.lock);
+	switch(command) {
+		case SONYPI_COMMAND_GETCAMERA:
+			ret = sonypi_camera_ready();
+			break;
+		case SONYPI_COMMAND_SETCAMERA:
+			if (value)
+				sonypi_camera_on();
+			else
+				sonypi_camera_off();
+			break;
+		case SONYPI_COMMAND_GETCAMERABRIGHTNESS:
+			ret = sonypi_read(SONYPI_CAMERA_BRIGHTNESS);
+			break;
+		case SONYPI_COMMAND_SETCAMERABRIGHTNESS:
+			sonypi_set(SONYPI_CAMERA_BRIGHTNESS, value);
+			break;
+		case SONYPI_COMMAND_GETCAMERACONTRAST:
+			ret = sonypi_read(SONYPI_CAMERA_CONTRAST);
+			break;
+		case SONYPI_COMMAND_SETCAMERACONTRAST:
+			sonypi_set(SONYPI_CAMERA_CONTRAST, value);
+			break;
+		case SONYPI_COMMAND_GETCAMERAHUE:
+			ret = sonypi_read(SONYPI_CAMERA_HUE);
+			break;
+		case SONYPI_COMMAND_SETCAMERAHUE:
+			sonypi_set(SONYPI_CAMERA_HUE, value);
+			break;
+		case SONYPI_COMMAND_GETCAMERACOLOR:
+			ret = sonypi_read(SONYPI_CAMERA_COLOR);
+			break;
+		case SONYPI_COMMAND_SETCAMERACOLOR:
+			sonypi_set(SONYPI_CAMERA_COLOR, value);
+			break;
+		case SONYPI_COMMAND_GETCAMERASHARPNESS:
+			ret = sonypi_read(SONYPI_CAMERA_SHARPNESS);
+			break;
+		case SONYPI_COMMAND_SETCAMERASHARPNESS:
+			sonypi_set(SONYPI_CAMERA_SHARPNESS, value);
+			break;
+		case SONYPI_COMMAND_GETCAMERAPICTURE:
+			ret = sonypi_read(SONYPI_CAMERA_PICTURE);
+			break;
+		case SONYPI_COMMAND_SETCAMERAPICTURE:
+			sonypi_set(SONYPI_CAMERA_PICTURE, value);
+			break;
+		case SONYPI_COMMAND_GETCAMERAAGC:
+			ret = sonypi_read(SONYPI_CAMERA_AGC);
+			break;
+		case SONYPI_COMMAND_SETCAMERAAGC:
+			sonypi_set(SONYPI_CAMERA_AGC, value);
+			break;
+		case SONYPI_COMMAND_GETCAMERADIRECTION:
+			ret = sonypi_read(SONYPI_CAMERA_STATUS);
+			ret &= SONYPI_DIRECTION_BACKWARDS;
+			break;
+		case SONYPI_COMMAND_GETCAMERAROMVERSION:
+			ret = sonypi_read(SONYPI_CAMERA_ROMVERSION);
+			break;
+		case SONYPI_COMMAND_GETCAMERAREVISION:
+			ret = sonypi_read(SONYPI_CAMERA_REVISION);
+			break;
+	}
+	up(&sonypi_device.lock);
+	return ret;
+}
+
+static int sonypi_misc_fasync(int fd, struct file *filp, int on) {
+	int retval;
+
+	retval = fasync_helper(fd, filp, on, &sonypi_device.queue.fasync);
+	if (retval < 0)
+		return retval;
+	return 0;
+}
+
+static int sonypi_misc_release(struct inode * inode, struct file * file) {
+	sonypi_misc_fasync(-1, file, 0);
+	down(&sonypi_device.lock);
+	sonypi_device.open_count--;
+	up(&sonypi_device.lock);
+	return 0;
+}
+
+static int sonypi_misc_open(struct inode * inode, struct file * file) {
+	down(&sonypi_device.lock);
+	if (sonypi_device.open_count)
+		goto out;
+	sonypi_device.open_count++;
+	/* Flush input queue */
+	sonypi_initq();
+out:
+	up(&sonypi_device.lock);
+	return 0;
+}
+
+static ssize_t sonypi_misc_read(struct file * file, char * buf, 
+		                size_t count, loff_t *pos) {
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t i = count;
+	unsigned char c;
+
+	if (sonypi_emptyq()) {
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		add_wait_queue(&sonypi_device.queue.proc_list, &wait);
+repeat:
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (sonypi_emptyq() && !signal_pending(current)) {
+			schedule();
+			goto repeat;
+		}
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&sonypi_device.queue.proc_list, &wait);
+	}
+	while (i > 0 && !sonypi_emptyq()) {
+		c = sonypi_pullq();
+		put_user(c, buf++);
+		i--;
+        }
+	if (count - i) {
+		file->f_dentry->d_inode->i_atime = CURRENT_TIME;
+		return count-i;
+	}
+	if (signal_pending(current))
+		return -ERESTARTSYS;
+	return 0;
+}
+
+static unsigned int sonypi_misc_poll(struct file *file, poll_table * wait) {
+	poll_wait(file, &sonypi_device.queue.proc_list, wait);
+	if (!sonypi_emptyq())
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static struct file_operations sonypi_misc_fops = {
+	owner:		THIS_MODULE,
+	read:		sonypi_misc_read,
+	poll:		sonypi_misc_poll,
+	open:		sonypi_misc_open,
+	release:	sonypi_misc_release,
+	fasync: 	sonypi_misc_fasync,
+};
+
+struct miscdevice sonypi_misc_device = {
+	-1, "sonypi", &sonypi_misc_fops
+};
+
+static int __devinit sonypi_probe(struct pci_dev *pcidev, 
+		                  const struct pci_device_id *ent) {
+	int i, ret;
+
+	if (sonypi_device.dev) {
+		printk(KERN_ERR "sonypi: only one device allowed!\n"),
+		ret = -EBUSY;
+		goto out1;
+	}
+	sonypi_device.dev = pcidev;
+	sonypi_initq();
+	init_MUTEX(&sonypi_device.lock);
+	
+	if (pci_enable_device(pcidev)) {
+		printk(KERN_ERR "sonypi: pci_enable_device failed\n");
+		ret = -EIO;
+		goto out1;
+	}
+
+	sonypi_misc_device.minor = (minor == -1) ? 
+		MISC_DYNAMIC_MINOR : minor;
+	if ((ret = misc_register(&sonypi_misc_device))) {
+		printk(KERN_ERR "sonypi: misc_register failed\n");
+		goto out1;
+	}
+
+	for (i = 0; sonypi_ioport_list[i].port1; i++) {
+		if (request_region(sonypi_ioport_list[i].port1, 8, 
+				   "Sony Programable I/O Device")) {
+			/* get the ioport */
+			sonypi_device.ioport1 = sonypi_ioport_list[i].port1;
+			sonypi_device.ioport2 = sonypi_ioport_list[i].port2;
+			break;
+		}
+	}
+	if (!sonypi_device.ioport1) {
+		printk(KERN_ERR "sonypi: request_region failed\n");
+		ret = -ENODEV;
+		goto out2;
+	}
+
+	for (i = 0; sonypi_irq_list[i].irq; i++) {
+		if (!request_irq(sonypi_irq_list[i].irq, sonypi_irq, 
+				 SA_INTERRUPT, "sonypi", sonypi_irq)) {
+			sonypi_device.irq = sonypi_irq_list[i].irq;
+			sonypi_device.bits = sonypi_irq_list[i].bits;
+			break;
+		}
+	}
+	if (!sonypi_device.irq ) {
+		printk(KERN_ERR "sonypi: request_irq failed\n");
+		ret = -ENODEV;
+		goto out3;
+	}
+
+	sonypi_srs();
+	sonypi_call1(0x82);
+	sonypi_call2(0x81, 0xff);
+	sonypi_call1(0x92); 
+
+	printk(KERN_INFO "sonypi: Sony Programmable I/O Controller Driver v%d.%d.\n",
+	       SONYPI_DRIVER_MAJORVERSION,
+	       SONYPI_DRIVER_MINORVERSION);
+	printk(KERN_INFO "sonypi: enabled at irq=%d, port1=0x%x, port2=0x%x\n",
+	       sonypi_device.irq, 
+	       sonypi_device.ioport1, sonypi_device.ioport2);
+	if (minor == -1)
+		printk(KERN_INFO "sonypi: device allocated minor is %d\n",
+		       sonypi_misc_device.minor);
+
+	return 0;
+
+out3:
+	release_region(sonypi_device.ioport1, 8);
+out2:
+	misc_deregister(&sonypi_misc_device);
+out1:
+	return ret;
+}
+
+static void __devexit sonypi_remove(struct pci_dev *pcidev) {
+	sonypi_set(SONYPI_CAMERA_PICTURE, SONYPI_CAMERA_MUTE_MASK);
+	sonypi_call2(0x81, 0); /* make sure we don't get any more events */
+	sonypi_camera_off();
+	sonypi_dis();
+	free_irq(sonypi_device.irq, sonypi_irq);
+	release_region(sonypi_device.ioport1, 8);
+	misc_deregister(&sonypi_misc_device);
+	printk(KERN_INFO "sonypi: removed.\n");
+}
+
+static struct pci_device_id sonypi_id_tbl[] __devinitdata = {
+	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB_3, 
+	  PCI_ANY_ID, PCI_ANY_ID, 0,0,0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(pci, sonypi_id_tbl);
+
+static struct pci_driver sonypi_driver = {
+	name:		"sonypi",
+	id_table:	sonypi_id_tbl,
+	probe:		sonypi_probe,
+	remove:		sonypi_remove,
+};
+
+static int __init sonypi_init_module(void) {
+	return pci_module_init(&sonypi_driver);
+}
+
+static void __exit sonypi_cleanup_module(void) {
+	pci_unregister_driver(&sonypi_driver);
+}
+
+/* Module entry points */
+module_init(sonypi_init_module);
+module_exit(sonypi_cleanup_module);
+
+MODULE_AUTHOR("Stelian Pop <stelian.pop@fr.alcove.com>");
+MODULE_DESCRIPTION("Sony Programmable I/O Control Device driver");
+
+MODULE_PARM(minor,"i");
+MODULE_PARM_DESC(minor, "minor number of the misc device, default is -1 (automatic)");
+MODULE_PARM(verbose,"i");
+MODULE_PARM_DESC(verbose, "be verbose, default is 0 (no)");
+
+EXPORT_SYMBOL(sonypi_camera_command);
diff -uNr --exclude-from=dontdiff linux-2.4.5.orig/drivers/char/sonypi.h linux-2.4.5/drivers/char/sonypi.h
--- linux-2.4.5.orig/drivers/char/sonypi.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.5/drivers/char/sonypi.h	Mon Jun  4 11:10:24 2001
@@ -0,0 +1,202 @@
+/* 
+ * Sony Programmable I/O Control Device driver for VAIO
+ *
+ * Copyright (C) 2001 Stelian Pop <stelian.pop@fr.alcove.com>, Alcôve
+ *
+ * Copyright (C) 2001 Junichi Morita <jun1m@mars.dti.ne.jp>
+ *
+ * Copyright (C) 2000 Takaya Kinjo <t-kinjo@tc4.so-net.ne.jp>
+ *
+ * Copyright (C) 2000 Andrew Tridgell <tridge@valinux.com>
+ *
+ * Earlier work by Werner Almesberger, Paul `Rusty' Russell and Paul Mackerras.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef _SONYPI_PRIV_H_ 
+#define _SONYPI_PRIV_H_
+
+#ifdef __KERNEL__
+
+#define SONYPI_DRIVER_MAJORVERSION	1
+#define SONYPI_DRIVER_MINORVERSION	0
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include "linux/sonypi.h"
+
+#define SONYPI_IRQ_PORT		0x8034
+#define SONYPI_IRQ_SHIFT	22
+
+#define SONYPI_BASE		0x50
+
+#define SONYPI_G10A		(SONYPI_BASE+0x14)
+
+/* The set of possible ioports */
+static struct sonypi_ioport_list {
+	u16	port1;
+	u16	port2;
+} sonypi_ioport_list[] = {
+	{ 0x10c0, 0x10c4 },	/* looks like the default on C1Vx */
+	{ 0x1080, 0x1084 },
+	{ 0x1090, 0x1094 },
+	{ 0x10a0, 0x10a4 },
+	{ 0x10b0, 0x10b4 },
+	{ 0x0, 0x0 }
+};
+
+/* The set of possible interrupts */
+static struct sonypi_irq_list {
+	u16	irq;
+	u16	bits;
+} sonypi_irq_list[] = {
+	{ 11, 0x2 },	/* IRQ 11, GO22=0,GO23=1 in AML */
+	{ 10, 0x1 },	/* IRQ 10, GO22=1,GO23=0 in AML */
+	{ 05, 0x0 },	/* IRQ 05, GO22=0,GO23=0 in AML */
+	{ 00, 0x3 }	/* no IRQ, GO22=1,GO23=1 in AML */
+};
+
+#define SONYPI_CAMERA_BRIGHTNESS		0
+#define SONYPI_CAMERA_CONTRAST			1
+#define SONYPI_CAMERA_HUE			2
+#define SONYPI_CAMERA_COLOR			3
+#define SONYPI_CAMERA_SHARPNESS			4
+
+#define SONYPI_CAMERA_PICTURE			5
+#define SONYPI_CAMERA_EXPOSURE_MASK		0xC
+#define SONYPI_CAMERA_WHITE_BALANCE_MASK	0x3
+#define SONYPI_CAMERA_PICTURE_MODE_MASK		0x30
+#define SONYPI_CAMERA_MUTE_MASK			0x40
+
+/* the rest don't need a loop until not 0xff */
+#define SONYPI_CAMERA_AGC			6
+#define SONYPI_CAMERA_AGC_MASK			0x30
+#define SONYPI_CAMERA_SHUTTER_MASK 		0x7
+
+#define SONYPI_CAMERA_SHUTDOWN_REQUEST		7
+#define SONYPI_CAMERA_CONTROL			0x10
+
+#define SONYPI_CAMERA_STATUS 			7
+#define SONYPI_CAMERA_STATUS_READY 		0x2
+#define SONYPI_CAMERA_STATUS_POSITION		0x4
+
+#define SONYPI_DIRECTION_BACKWARDS 		0x4
+
+#define SONYPI_CAMERA_REVISION 			8
+#define SONYPI_CAMERA_ROMVERSION 		9
+
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+
+static inline void wait_ms(unsigned int ms) {
+	if (!in_interrupt()) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1 + ms * HZ / 1000);
+	}
+	else
+		mdelay(ms);
+}
+
+/* key press event data (ioport2) */
+#define SONYPI_JOGGER_EV	0x10
+#define SONYPI_CAPTURE_EV	0x60
+#define SONYPI_FNKEY_EV		0x20
+#define SONYPI_BLUETOOTH_EV	0x55
+
+struct sonypi_event {
+	u8	data;
+	u8	event;
+};
+
+/* The set of possible jogger events  */
+static struct sonypi_event sonypi_joggerev[] = {
+	{ 0x1f, SONYPI_EVENT_JOGDIAL_UP },
+	{ 0x01, SONYPI_EVENT_JOGDIAL_DOWN },
+	{ 0x5f, SONYPI_EVENT_JOGDIAL_UP_PRESSED },
+	{ 0x41, SONYPI_EVENT_JOGDIAL_DOWN_PRESSED },
+	{ 0x40, SONYPI_EVENT_JOGDIAL_PRESSED },
+	{ 0x00, SONYPI_EVENT_JOGDIAL_RELEASED },
+	{ 0x00, 0x00 }
+};
+
+/* The set of possible capture button events */
+static struct sonypi_event sonypi_captureev[] = {
+	{ 0x05, SONYPI_EVENT_CAPTURE_PARTIALPRESSED },
+	{ 0x07, SONYPI_EVENT_CAPTURE_PRESSED },
+	{ 0x01, SONYPI_EVENT_CAPTURE_PARTIALRELEASED },
+	{ 0x00, SONYPI_EVENT_CAPTURE_RELEASED },
+	{ 0x00, 0x00 }
+};
+
+/* The set of possible fnkeys events */
+static struct sonypi_event sonypi_fnkeyev[] = {
+	{ 0x10, SONYPI_EVENT_FNKEY_ESC },
+	{ 0x11, SONYPI_EVENT_FNKEY_F1 },
+	{ 0x12, SONYPI_EVENT_FNKEY_F2 },
+	{ 0x13, SONYPI_EVENT_FNKEY_F3 },
+	{ 0x14, SONYPI_EVENT_FNKEY_F4 },
+	{ 0x15, SONYPI_EVENT_FNKEY_F5 },
+	{ 0x16, SONYPI_EVENT_FNKEY_F6 },
+	{ 0x17, SONYPI_EVENT_FNKEY_F7 },
+	{ 0x18, SONYPI_EVENT_FNKEY_F8 },
+	{ 0x19, SONYPI_EVENT_FNKEY_F9 },
+	{ 0x1a, SONYPI_EVENT_FNKEY_F10 },
+	{ 0x1b, SONYPI_EVENT_FNKEY_F11 },
+	{ 0x1c, SONYPI_EVENT_FNKEY_F12 },
+	{ 0x21, SONYPI_EVENT_FNKEY_1 },
+	{ 0x22, SONYPI_EVENT_FNKEY_2 },
+	{ 0x31, SONYPI_EVENT_FNKEY_D },
+	{ 0x32, SONYPI_EVENT_FNKEY_E },
+	{ 0x33, SONYPI_EVENT_FNKEY_F },
+	{ 0x34, SONYPI_EVENT_FNKEY_S },
+	{ 0x35, SONYPI_EVENT_FNKEY_B },
+	{ 0x00, 0x00 }
+};
+
+/* The set of possible bluetooth events */
+static struct sonypi_event sonypi_blueev[] = {
+	{ 0x38, SONYPI_EVENT_BLUETOOTH_PRESSED },
+	{ 0x39, SONYPI_EVENT_BLUETOOTH_RELEASED },
+	{ 0x00, 0x00 }
+};
+
+#define SONYPI_BUF_SIZE	128
+struct sonypi_queue {
+	unsigned long head;
+	unsigned long tail;
+	unsigned long len;
+	spinlock_t s_lock;
+	wait_queue_head_t proc_list;
+	struct fasync_struct *fasync;
+	unsigned char buf[SONYPI_BUF_SIZE];
+};
+
+struct sonypi_device {
+	struct pci_dev *dev;
+	u16 irq;
+	u16 bits;
+	u16 ioport1;
+	u16 ioport2;
+	int camera_power;
+	struct semaphore lock;
+	struct sonypi_queue queue;
+	int open_count;
+};
+
+#endif /* __KERNEL__ */
+
+#endif /* _SONYPI_PRIV_H_ */
diff -uNr --exclude-from=dontdiff linux-2.4.5.orig/include/linux/sonypi.h linux-2.4.5/include/linux/sonypi.h
--- linux-2.4.5.orig/include/linux/sonypi.h	Thu Jan  1 01:00:00 1970
+++ linux-2.4.5/include/linux/sonypi.h	Sun Jun  3 15:34:28 2001
@@ -0,0 +1,98 @@
+/* 
+ * Sony Programmable I/O Control Device driver for VAIO
+ *
+ * Copyright (C) 2001 Stelian Pop <stelian.pop@fr.alcove.com>, Alcôve
+ *
+ * Copyright (C) 2001 Junichi Morita <jun1m@mars.dti.ne.jp>
+ *
+ * Copyright (C) 2000 Takaya Kinjo <t-kinjo@tc4.so-net.ne.jp>
+ *
+ * Copyright (C) 2000 Andrew Tridgell <tridge@valinux.com>
+ *
+ * Earlier work by Werner Almesberger, Paul `Rusty' Russell and Paul Mackerras.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef _SONYPI_H_ 
+#define _SONYPI_H_
+
+/* events the user application reading /dev/sonypi can use */
+
+#define SONYPI_EVENT_JOGDIAL_DOWN		 1
+#define SONYPI_EVENT_JOGDIAL_UP			 2
+#define SONYPI_EVENT_JOGDIAL_DOWN_PRESSED	 3
+#define SONYPI_EVENT_JOGDIAL_UP_PRESSED		 4
+#define SONYPI_EVENT_JOGDIAL_PRESSED		 5
+#define SONYPI_EVENT_JOGDIAL_RELEASED		 6
+#define SONYPI_EVENT_CAPTURE_PRESSED		 7
+#define SONYPI_EVENT_CAPTURE_RELEASED		 8
+#define SONYPI_EVENT_CAPTURE_PARTIALPRESSED	 9
+#define SONYPI_EVENT_CAPTURE_PARTIALRELEASED	10
+#define SONYPI_EVENT_FNKEY_ESC			11
+#define SONYPI_EVENT_FNKEY_F1			12
+#define SONYPI_EVENT_FNKEY_F2			13
+#define SONYPI_EVENT_FNKEY_F3			14
+#define SONYPI_EVENT_FNKEY_F4			15
+#define SONYPI_EVENT_FNKEY_F5			16
+#define SONYPI_EVENT_FNKEY_F6			17
+#define SONYPI_EVENT_FNKEY_F7			18
+#define SONYPI_EVENT_FNKEY_F8			19
+#define SONYPI_EVENT_FNKEY_F9			20
+#define SONYPI_EVENT_FNKEY_F10			21
+#define SONYPI_EVENT_FNKEY_F11			22
+#define SONYPI_EVENT_FNKEY_F12			23
+#define SONYPI_EVENT_FNKEY_1			24
+#define SONYPI_EVENT_FNKEY_2			25
+#define SONYPI_EVENT_FNKEY_D			26
+#define SONYPI_EVENT_FNKEY_E			27
+#define SONYPI_EVENT_FNKEY_F			28
+#define SONYPI_EVENT_FNKEY_S			29
+#define SONYPI_EVENT_FNKEY_B			30
+#define SONYPI_EVENT_BLUETOOTH_PRESSED		31
+#define SONYPI_EVENT_BLUETOOTH_RELEASED		32
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+
+/* used only for communication between v4l and sonypi */
+
+#define SONYPI_COMMAND_GETCAMERA		 1
+#define SONYPI_COMMAND_SETCAMERA		 2
+#define SONYPI_COMMAND_GETCAMERABRIGHTNESS	 3
+#define SONYPI_COMMAND_SETCAMERABRIGHTNESS	 4
+#define SONYPI_COMMAND_GETCAMERACONTRAST	 5
+#define SONYPI_COMMAND_SETCAMERACONTRAST	 6
+#define SONYPI_COMMAND_GETCAMERAHUE		 7
+#define SONYPI_COMMAND_SETCAMERAHUE		 8
+#define SONYPI_COMMAND_GETCAMERACOLOR		 9
+#define SONYPI_COMMAND_SETCAMERACOLOR		10
+#define SONYPI_COMMAND_GETCAMERASHARPNESS	11
+#define SONYPI_COMMAND_SETCAMERASHARPNESS	12
+#define SONYPI_COMMAND_GETCAMERAPICTURE		13
+#define SONYPI_COMMAND_SETCAMERAPICTURE		14
+#define SONYPI_COMMAND_GETCAMERAAGC		15
+#define SONYPI_COMMAND_SETCAMERAAGC		16
+#define SONYPI_COMMAND_GETCAMERADIRECTION	17
+#define SONYPI_COMMAND_GETCAMERAROMVERSION	18
+#define SONYPI_COMMAND_GETCAMERAREVISION	19
+
+u8 sonypi_camera_command(int command, u8 value);
+
+#endif /* __KERNEL__ */
+
+#endif /* _SONYPI_H_ */

-- 
Stelian Pop <stelian.pop@fr.alcove.com>
|------------- Ingénieur Informatique Libre --------------|
| Alcôve - http://www.alcove.com - Tel: +33 1 49 22 68 00 |
|----------- Alcôve, l'informatique est libre ------------|
