Return-Path: <linux-kernel-owner@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id <S129847AbRAGRtV>; Sun, 7 Jan 2001 12:49:21 -0500
Received: (majordomo@vger.kernel.org) by vger.kernel.org
	id <S130069AbRAGRtM>; Sun, 7 Jan 2001 12:49:12 -0500
Received: from mail.asahi-net.or.jp ([202.224.39.39]:62530 "HELO
	mail.asahi-net.or.jp") by vger.kernel.org with SMTP
	id <S129847AbRAGRs7>; Sun, 7 Jan 2001 12:48:59 -0500
Date: Mon, 08 Jan 2001 02:46:51 +0900
Message-ID: <87ae93l0fo.wl@strawberry.hibi-local.net>
From: HIBINO Kei <ex8k-hbn@asahi-net.or.jp>
To: linux-kernel@vger.kernel.org, alan@lxorguk.ukuu.org.uk
Subject: [PATCH] Atomic lock
User-Agent: Wanderlust/2.5.4 (Smooth) SEMI/1.14.3 (Ushinoya) FLIM/1.14.2 (Yagi-Nishiguchi) APEL/10.3 Emacs/20.7 (i386-debian-linux-gnu) MULE/4.1 (AOI)
MIME-Version: 1.0 (generated by SEMI 1.14.3 - "Ushinoya")
Content-Type: text/plain; charset=US-ASCII
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org


I think atomic lock is needed for SMP code.

diff -ur linux-2.2.19pre6/drivers/block/ll_rw_blk.c linux-2.2.19pre6+lockfix/drivers/block/ll_rw_blk.c
--- linux-2.2.19pre6/drivers/block/ll_rw_blk.c	Mon Dec 11 09:49:41 2000
+++ linux-2.2.19pre6+lockfix/drivers/block/ll_rw_blk.c	Mon Jan  8 02:40:37 2001
@@ -578,11 +578,9 @@
 	count = bh->b_size >> 9;
 	sector = bh->b_rsector;
 
-	/* Uhhuh.. Nasty dead-lock possible here.. */
-	if (buffer_locked(bh))
+	if(test_and_set_bit(BH_Lock, &bh->b_state)) { /* Does atomic lock resolv problems? */
 		return;
-	/* Maybe the above fixes it, and maybe it doesn't boot. Life is interesting */
-	lock_buffer(bh);
+	}
 
 	if (blk_size[major]) {
 		unsigned long maxsector = (blk_size[major][MINOR(bh->b_rdev)] << 1) + 1;
diff -ur linux-2.2.19pre6/drivers/block/md.c linux-2.2.19pre6+lockfix/drivers/block/md.c
--- linux-2.2.19pre6/drivers/block/md.c	Tue Sep  5 02:39:16 2000
+++ linux-2.2.19pre6+lockfix/drivers/block/md.c	Mon Jan  8 02:41:19 2001
@@ -778,9 +778,9 @@
 int md_make_request (int minor, int rw, struct buffer_head * bh)
 {
 	if (md_dev [minor].pers->make_request) {
-		if (buffer_locked(bh))
+		if(test_and_set_bit(BH_Lock, &bh->b_state)) { /* atomic lock */
 			return 0;
-		set_bit(BH_Lock, &bh->b_state);
+		}
 		if (rw == WRITE || rw == WRITEA) {
 			if (!buffer_dirty(bh)) {
 				bh->b_end_io(bh, test_bit(BH_Uptodate, &bh->b_state));
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
Please read the FAQ at http://www.tux.org/lkml/
