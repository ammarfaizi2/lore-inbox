Return-Path: <linux-kernel-owner@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id <S263539AbREYFVB>; Fri, 25 May 2001 01:21:01 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org
	id <S263540AbREYFUv>; Fri, 25 May 2001 01:20:51 -0400
Received: from deliverator.sgi.com ([204.94.214.10]:54790 "EHLO
	deliverator.sgi.com") by vger.kernel.org with ESMTP
	id <S263539AbREYFUi>; Fri, 25 May 2001 01:20:38 -0400
X-Mailer: exmh version 2.1.1 10/15/1999
From: Keith Owens <kaos@ocs.com.au>
To: Andi Kleen <ak@suse.de>
cc: Andreas Dilger <adilger@turbolinux.com>, linux-kernel@vger.kernel.org
Subject: Re: [CHECKER] large stack variables (>=1K) in 2.4.4 and 2.4.4-ac8 
In-Reply-To: Your message of "Fri, 25 May 2001 01:33:03 +0200."
             <20010525013303.A21810@gruyere.muc.suse.de> 
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Date: Fri, 25 May 2001 15:20:20 +1000
Message-ID: <23182.990768020@kao2.melbourne.sgi.com>
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

On Fri, 25 May 2001 01:33:03 +0200, 
Andi Kleen <ak@suse.de> wrote:
>On Thu, May 24, 2001 at 05:08:40PM -0600, Andreas Dilger wrote:
>> I'm curious about this stack checker.  Does it check for a single
>> stack allocation >= 1024 bytes, or does it also check for several
>> individual, smaller allocations which total >= 1024 bytes inside
>> a single function?  That would be equally useful.
>
>At one time someone had a script to grep objdump -S vmlinux for the
>stack allocations generated by gcc and check them.

ftp://ftp.ocs.com.au/pub/kernel.stack.gz.  ix86 specific, probably gcc
specific and it only picks up code that you compile.  The Stanford
checker is much better.

>> On a side note, does anyone know if the kernel does checking if the
>> stack overflowed at any time?
>
>You normally get a silent hang or worse a stack fault exception 
>(which linux/x86 without kdb cannot recover from) which gives you instant 
>reboot.

You cannot recover from a kernel stack overflow even with kdb.  The
exception handler and kdb use the stack that just overflowed.

