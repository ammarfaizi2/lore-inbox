Return-Path: <linux-kernel-owner+willy=40w.ods.org@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S269747AbTG1OOB (ORCPT <rfc822;willy@w.ods.org>);
	Mon, 28 Jul 2003 10:14:01 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S270065AbTG1OOB
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Mon, 28 Jul 2003 10:14:01 -0400
Received: from i235086.ppp.asahi-net.or.jp ([61.125.235.86]:41208 "EHLO
	mitou.y-sato.ddo.jp") by vger.kernel.org with ESMTP id S269747AbTG1OET
	(ORCPT <rfc822;linux-kernel@vger.kernel.org>);
	Mon, 28 Jul 2003 10:04:19 -0400
Date: Mon, 28 Jul 2003 23:18:51 +0900
Message-ID: <m2oezeag50.wl%ysato@users.sourceforge.jp>
From: Yoshinori Sato <ysato@users.sourceforge.jp>
To: Linus Torvalds <torvalds@osdl.org>
Cc: linux kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: [PATCH] linux-2.6.0-test2 h8300 archtecure support update (4/6)
User-Agent: Wanderlust/2.11.3 (Wonderwall) SEMI/1.14.5 (Awara-Onsen)
 FLIM/1.14.5 (Demachiyanagi) APEL/10.6 Emacs/21.3 (i386-pc-linux-gnu)
 MULE/5.0 (SAKAKI)
MIME-Version: 1.0 (generated by SEMI 1.14.5 - "Awara-Onsen")
Content-Type: text/plain; charset=US-ASCII
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

includes

used common header files
build error and warning fix
add include/asm-h8300/local.h and include/asm-h8300/sections.h

-- 
Yoshinori Sato
<ysato@users.sourceforge.jp>

diff -Nru linux-2.6.0-test2/include/asm-h8300/aki3068net/ne.h linux-2.6.0-test2-h8300/include/asm-h8300/aki3068net/ne.h
--- linux-2.6.0-test2/include/asm-h8300/aki3068net/ne.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/aki3068net/ne.h	2003-07-19 21:41:33.000000000 +0900
@@ -1,6 +1,9 @@
 /* AE-3068 (aka. aki3068net) RTL8019AS Config */
 
-#define NE2000_ADDR		CONFIG_NE_BASE
+#ifndef __H8300_AKI3068NET_NE__
+#define __H8300_AKI3068NET_NE__
+
+#define NE2000_ADDR		0x200000
 #define NE2000_IRQ              5
 #define NE2000_IRQ_VECTOR	(12 + NE2000_IRQ)
 #define	NE2000_BYTE		volatile unsigned short
@@ -21,3 +24,5 @@
 	wordlength = 1;                  \
         outb_p(0x48, ioaddr + EN0_DCFG); \
 } while(0)
+
+#endif
diff -Nru linux-2.6.0-test2/include/asm-h8300/aki3068net/timer_rate.h linux-2.6.0-test2-h8300/include/asm-h8300/aki3068net/timer_rate.h
--- linux-2.6.0-test2/include/asm-h8300/aki3068net/timer_rate.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/aki3068net/timer_rate.h	2003-07-20 01:19:25.000000000 +0900
@@ -0,0 +1,9 @@
+#ifndef __H8300_AKI3068NET_TIMER_RATE__
+#define __H8300_AKI3068NET_TIMER_RATE__
+
+#include <linux/config.h>
+
+#define H8300_TIMER_COUNT_DATA CONFIG_CPU_CLOCK*10/8192
+#define H8300_TIMER_FREQ CONFIG_CPU_CLOCK*1000/8192
+
+#endif
diff -Nru linux-2.6.0-test2/include/asm-h8300/atomic.h linux-2.6.0-test2-h8300/include/asm-h8300/atomic.h
--- linux-2.6.0-test2/include/asm-h8300/atomic.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/atomic.h	2003-07-19 21:41:33.000000000 +0900
@@ -71,6 +71,7 @@
 	return ret == 0;
 }
 
+#if defined(__H8300H__)
 static __inline__ void atomic_clear_mask(unsigned long mask, unsigned long *v)
 {
 	__asm__ __volatile__("stc ccr,r2l\n\t"
@@ -94,6 +95,32 @@
 	                     "ldc r2l,ccr" 
                              : "=m" (*v) : "ir" (mask) :"er0","er1","er2");
 }
+#endif
+#if defined(__H8300S__)
+static __inline__ void atomic_clear_mask(unsigned long mask, unsigned long *v)
+{
+	__asm__ __volatile__("stc exr,r2l\n\t"
+	                     "orc #0x07,exr\n\t"
+	                     "mov.l %0,er0\n\t"
+	                     "mov.l %1,er1\n\t"
+	                     "and.l er1,er0\n\t"
+	                     "mov.l er0,%0\n\t"
+	                     "ldc r2l,exr" 
+                             : "=m" (*v) : "ir" (~(mask)) :"er0","er1","er2");
+}
+
+static __inline__ void atomic_set_mask(unsigned long mask, unsigned long *v)
+{
+	__asm__ __volatile__("stc exr,r2l\n\t"
+	                     "orc #0x07,exr\n\t"
+	                     "mov.l %0,er0\n\t"
+	                     "mov.l %1,er1\n\t"
+	                     "or.l er1,er0\n\t"
+	                     "mov.l er0,%0\n\t"
+	                     "ldc r2l,exr" 
+                             : "=m" (*v) : "ir" (mask) :"er0","er1","er2");
+}
+#endif
 
 /* Atomic operations are already serializing */
 #define smp_mb__before_atomic_dec()    barrier()
@@ -101,7 +128,4 @@
 #define smp_mb__before_atomic_inc()    barrier()
 #define smp_mb__after_atomic_inc() barrier()
 
-#define atomic_sub_and_test(i,v) (atomic_sub_return((i), (v)) == 0)
-#define atomic_dec_and_test(v) (atomic_sub_return(1, (v)) == 0)
-
 #endif /* __ARCH_H8300_ATOMIC __ */
diff -Nru linux-2.6.0-test2/include/asm-h8300/bitops.h linux-2.6.0-test2-h8300/include/asm-h8300/bitops.h
--- linux-2.6.0-test2/include/asm-h8300/bitops.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/bitops.h	2003-07-28 12:40:18.000000000 +0900
@@ -10,6 +10,7 @@
 #include <linux/config.h>
 #include <linux/compiler.h>
 #include <asm/byteorder.h>	/* swab32 */
+#include <asm/system.h>
 
 #ifdef __KERNEL__
 /*
@@ -17,48 +18,33 @@
  */
 
 /*
- * The __ functions are not atomic
- */
-
-extern void set_bit(int nr, volatile unsigned long* addr);
-extern void clear_bit(int nr, volatile unsigned long* addr);
-extern void change_bit(int nr, volatile unsigned long* addr);
-extern int test_and_set_bit(int nr, volatile unsigned long* addr);
-extern int __test_and_set_bit(int nr, volatile unsigned long* addr);
-extern int test_and_clear_bit(int nr, volatile unsigned long* addr);
-extern int __test_and_clear_bit(int nr, volatile unsigned long* addr);
-extern int test_and_change_bit(int nr, volatile unsigned long* addr);
-extern int __test_and_change_bit(int nr, volatile unsigned long* addr);
-extern int __constant_test_bit(int nr, const volatile unsigned long* addr);
-extern int __test_bit(int nr, volatile unsigned long* addr);
-extern int find_first_zero_bit(void * addr, unsigned size);
-extern int find_next_zero_bit (void * addr, int size, int offset);
-
-/*
  * ffz = Find First Zero in word. Undefined if no zero exists,
  * so code should check against ~0UL first..
  */
-extern __inline__ unsigned long ffz(unsigned long word)
+static __inline__ unsigned long ffz(unsigned long word)
 {
-	unsigned long result;
+	register unsigned long result asm("er0");
+	register unsigned long _word asm("er1");
 
+	_word = word;
 	__asm__("sub.l %0,%0\n\t"
 		"dec.l #1,%0\n"
 		"1:\n\t"
 		"shlr.l %1\n\t"
 		"adds #1,%0\n\t"
 		"bcs 1b"
-		: "=r" (result) : "r" (word));
+		: "=r" (result) : "r" (_word));
 	return result;
 }
 
-extern __inline__ void set_bit(int nr, volatile unsigned long* addr)
+static __inline__ void set_bit(int nr, volatile unsigned long* addr)
 {
 	unsigned char *a = (unsigned char *) addr;
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %0,er0\n\t"
-		"bset r0l,@%1"
-		::"r"(nr & 7),"r"(a):"er0","er1");
+	__asm__("mov.l %1,er0\n\t"
+		"mov.l %0,er1\n\t"
+		"bset r0l,@er1"
+		:"=m"(a):"g"(nr & 7):"er0","er1","memory");
 }
 /* Bigendian is complexed... */
 
@@ -70,175 +56,239 @@
 #define smp_mb__before_clear_bit()	barrier()
 #define smp_mb__after_clear_bit()	barrier()
 
-extern __inline__ void clear_bit(int nr, volatile unsigned long* addr)
+static __inline__ void clear_bit(int nr, volatile unsigned long* addr)
 {
 	unsigned char *a = (unsigned char *) addr;
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %0,er0\n\t"
-		"bclr r0l,@%1"
-		::"r"(nr & 7),"r"(a):"er0");
+	__asm__("mov.l %1,er0\n\t"
+		"mov.l %0,er1\n\t"
+		"bclr r0l,@er1"
+		:"=m"(a):"g"(nr & 7):"er0","er1","memory");
 }
 
 #define __clear_bit(nr, addr) clear_bit(nr, addr)
 
-extern __inline__ void change_bit(int nr, volatile unsigned long* addr)
+static __inline__ void change_bit(int nr, volatile unsigned long* addr)
 {
 	unsigned char *a = (unsigned char *) addr;
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %0,er0\n\t"
-		"bnot r0l,@%1"
-		::"r"(nr & 7),"r"(a):"er0");
+	__asm__("mov.l %1,er0\n\t"
+		"mov.l %0,er1\n\t"
+		"bnot r0l,@er1"
+		:"=m"(a):"g"(nr & 7):"er0","er1","memory");
 }
 
 #define __change_bit(nr, addr) change_bit(nr, addr)
 
-extern __inline__ int test_and_set_bit(int nr, volatile unsigned long* addr)
+#if defined(__H8300H__)
+static __inline__ int test_and_set_bit(int nr, volatile unsigned long* addr)
 {
 	int retval;
 	unsigned char *a;
 	a = (unsigned char *) addr;
 
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %1,er0\n\t"
+	__asm__("mov.l %2,er0\n\t"
 		"stc ccr,r0h\n\t"
 		"orc #0x80,ccr\n\t"
-		"btst r0l,@%2\n\t"
-		"bset r0l,@%2\n\t"
+		"mov.b %1,r1l\n\t"
+		"btst r0l,r1l\n\t"
+		"bset r0l,r1l\n\t"
 		"stc ccr,r0l\n\t"
+		"mov.b r1l,%1\n\t"
 		"ldc r0h,ccr\n\t"
-		"btst #2,r0l\n\t"
-		"bne 1f\n\t"
 		"sub.l %0,%0\n\t"
-		"inc.l #1,%0\n"
-		"bra 2f\n"
-		"1:\n\t"
-		"sub.l %0,%0\n"
-		"2:"
-		: "=r"(retval) :"r"(nr & 7),"r"(a):"er0");
+		"bild #2,r0l\n\t"
+		"rotxl.l %0"
+		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","er1","memory");
 	return retval;
 }
+#endif
+#if defined(__H8300S__)
+static __inline__ int test_and_set_bit(int nr, volatile unsigned long* addr)
+{
+	int retval;
+	unsigned char *a;
+	a = (unsigned char *) addr;
 
-extern __inline__ int __test_and_set_bit(int nr, volatile unsigned long* addr)
+	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
+	__asm__("mov.l %2,er0\n\t"
+		"stc exr,r0h\n\t"
+		"orc #0x07,exr\n\t"
+		"mov.b %1,r1l\n\t"
+		"btst r0l,r1l\n\t"
+		"bset r0l,r1l\n\t"
+		"stc ccr,r0l\n\t"
+		"mov.b r1l,%1\n\t"
+		"ldc r0h,exr\n\t"
+		"sub.l %0,%0\n\t"
+		"bild #2,r0l\n\t"
+		"rotxl.l %0"
+		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","er1","memory");
+	return retval;
+}
+#endif
+
+static __inline__ int __test_and_set_bit(int nr, volatile unsigned long* addr)
 {
 	int retval;
 	unsigned char *a = (unsigned char *) addr;
 
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %1,er0\n\t"
-		"btst r0l,@%2\n\t"
-		"bset r0l,@%2\n\t"
-		"beq 1f\n\t"
+	__asm__("mov.l %2,er0\n\t"
+		"mov.b %1,r0h\n\t"
+		"btst r0l,r0h\n\t"
+		"bset r0l,r0h\n\t"
+		"stc ccr,r0l\n\t"
+		"mov.b r0h,%1\n\t"
 		"sub.l %0,%0\n\t"
-		"inc.l #1,%0\n"
-		"bra 2f\n"
-		"1:\n\t"
-		"sub.l %0,%0\n"
-		"2:"
-		: "=r"(retval) :"r"(nr & 7),"r"(a):"er0");
+		"bild #2,r0l\n\t"
+		"rotxl.l %0"
+		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","memory");
 	return retval;
 }
 
-extern __inline__ int test_and_clear_bit(int nr, volatile unsigned long* addr)
+#if defined(__H8300H__)
+static __inline__ int test_and_clear_bit(int nr, volatile unsigned long* addr)
 {
 	int retval;
 	unsigned char *a = (unsigned char *) addr;
 
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %1,er0\n\t"
+	__asm__("mov.l %2,er0\n\t"
 		"stc ccr,r0h\n\t"
 		"orc #0x80,ccr\n\t"
-		"btst r0l,@%2\n\t"
-		"bclr r0l,@%2\n\t"
+		"mov.b %1,r1l\n\t"
+		"btst r0l,r1l\n\t"
+		"bclr r0l,r1l\n\t"
 		"stc ccr,r0l\n\t"
+		"mov.b r1l,%1\n\t"
 		"ldc r0h,ccr\n\t"
-		"btst #2,r0l\n\t"
-		"bne 1f\n\t"
 		"sub.l %0,%0\n\t"
-		"inc.l #1,%0\n"
-		"bra 2f\n"
-		"1:\n\t"
-		"sub.l %0,%0\n"
-		"2:"
-		: "=r"(retval) :"r"(nr & 7),"r"(a):"er0");
+		"bild #2,r0l\n\t"
+		"rotxl.l %0"
+		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","er1","memory");
 	return retval;
 }
+#endif
+#if defined(__H8300S__)
+static __inline__ int test_and_clear_bit(int nr, volatile unsigned long* addr)
+{
+	int retval;
+	unsigned char *a = (unsigned char *) addr;
 
-extern __inline__ int __test_and_clear_bit(int nr, volatile unsigned long* addr)
+	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
+	__asm__("mov.l %2,er0\n\t"
+		"stc exr,r0h\n\t"
+		"orc #0x07,exr\n\t"
+		"mov.b %1,r1l\n\t"
+		"btst r0l,r1l\n\t"
+		"bclr r0l,r1l\n\t"
+		"stc ccr,r0l\n\t"
+		"mov.b r1l,%1\n\t"
+		"ldc r0h,exr\n\t"
+		"sub.l %0,%0\n\t"
+		"bild #2,r0l\n\t"
+		"rotxl.l %0"
+		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","er1","memory");
+	return retval;
+}
+#endif
+
+static __inline__ int __test_and_clear_bit(int nr, volatile unsigned long* addr)
 {
 	int retval;
 	unsigned char *a = (unsigned char *) addr;
 
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %1,er0\n\t"
-		"btst r0l,@%2\n\t"
-		"bclr r0l,@%2\n\t"
-		"beq 1f\n\t"
+	__asm__("mov.l %2,er0\n\t"
+		"mov.b %1,r0h\n\t"
+		"btst r0l,r0h\n\t"
+		"bclr r0l,r0h\n\t"
+		"stc ccr,r0l\n\t"
+		"mov.b r0h,%1\n\t"
 		"sub.l %0,%0\n\t"
-		"inc.l #1,%0\n"
-		"bra 2f\n"
-		"1:\n\t"
-		"sub.l %0,%0\n"
-		"2:"
-		: "=r"(retval) :"r"(nr & 7),"r"(a):"er0");
+		"bild #2,r0l\n\t"
+		"rotxl.l %0"
+		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","memory");
 	return retval;
 }
 
-extern __inline__ int test_and_change_bit(int nr, volatile unsigned long* addr)
+#if defined(__H8300H__)
+static __inline__ int test_and_change_bit(int nr, volatile unsigned long* addr)
 {
 	int retval;
 	unsigned char *a = (unsigned char *) addr;
 
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %1,er0\n\t"
+	__asm__("mov.l %2,er0\n\t"
 		"stc ccr,r0h\n\t"
 		"orc #0x80,ccr\n\t"
-		"btst r0l,@%2\n\t"
-		"bnot r0l,@%2\n\t"
+		"mov.b %1,r1l\n\t"
+		"btst r0l,r1l\n\t"
+		"bnot r0l,r1l\n\t"
 		"stc ccr,r0l\n\t"
+		"mov.b r1l,%1\n\t"
 		"ldc r0h,ccr\n\t"
-		"btst #2,r0l\n\t"
-		"bne 1f\n\t"
 		"sub.l %0,%0\n\t"
-		"inc.l #1,%0\n"
-		"bra 2f\n"
-		"1:\n\t"
-		"sub.l %0,%0\n"
-		"2:"
-		: "=r"(retval) :"r"(nr & 7),"r"(a):"er0");
+		"bild #2,r0l\n\t"
+		"rotxl.l %0"
+		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","er1","memory");
 	return retval;
 }
+#endif
+#if defined(__H8300S__)
+static __inline__ int test_and_change_bit(int nr, volatile unsigned long* addr)
+{
+	int retval;
+	unsigned char *a = (unsigned char *) addr;
+
+	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
+	__asm__("mov.l %2,er0\n\t"
+		"stc exr,r0h\n\t"
+		"orc #0x07,exr\n\t"
+		"mov.b %1,r1l\n\t"
+		"btst r0l,r1l\n\t"
+		"bnot r0l,r1l\n\t"
+		"stc ccr,r0l\n\t"
+		"mov.b r1l,%1\n\t"
+		"ldc r0h,exr\n\t"
+		"sub.l %0,%0\n\t"
+		"bild #2,r0l\n\t"
+		"rotxl.l %0"
+		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","er1","memory");
+	return retval;
+}
+#endif
 
-extern __inline__ int __test_and_change_bit(int nr, volatile unsigned long* addr)
+static __inline__ int __test_and_change_bit(int nr, volatile unsigned long* addr)
 {
 	int retval;
 	unsigned char *a = (unsigned char *) addr;
 
 	a += ((nr >> 3) & ~3) + (3 - ((nr >> 3) & 3));
-	__asm__("mov.l %1,er0\n\t"
-		"btst r0l,@%2\n\t"
-		"bnot r0l,@%2\n\t"
-		"beq 1f\n\t"
+	__asm__("mov.l %2,er0\n\t"
+		"mov.b %1,r0h\n\t"
+		"btst r0l,r0h\n\t"
+		"bnot r0l,r0h\n\t"
+		"stc ccr,r0l\n\t"
+		"mov.b r0h,%1\n\t"
 		"sub.l %0,%0\n\t"
-		"inc.l #1,%0\n"
-		"bra 2f\n"
-		"1:\n\t"
-		"sub.l %0,%0\n"
-		"2:"
-		: "=r"(retval) :"r"(nr & 7),"r"(a):"er0");
+		"bild #2,r0l\n\t"
+		"rotxl.l %0"
+		: "=r"(retval),"=m"(*a) :"g"(nr & 7):"er0","memory");
 	return retval;
 }
 
 /*
  * This routine doesn't need to be atomic.
  */
-extern __inline__ int __constant_test_bit(int nr, const volatile unsigned long* addr)
+static __inline__ int __constant_test_bit(int nr, const volatile unsigned long* addr)
 {
-	return ((1UL << (nr & 7)) & 
-               (((const volatile unsigned char *) addr)
-               [((nr >> 3) & ~3) + 3 - ((nr >> 3) & 3)])) != 0;
+	return ((1UL << (nr & 31)) & (((const volatile unsigned int *) addr)[nr >> 5])) != 0;
 }
 
-extern __inline__ int __test_bit(int nr, volatile unsigned long* addr)
+static __inline__ int __test_bit(int nr, const unsigned long* addr)
 {
 	int retval;
 	unsigned char *a = (unsigned char *) addr;
@@ -253,7 +303,7 @@
 		"1:\n\t"
 		"sub.l %0,%0\n"
 		"2:"
-		: "=r"(retval) :"r"(nr & 7),"r"(a):"er0");
+		: "=r"(retval) :"g"(nr & 7),"r"(a):"er0");
 	return retval;
 }
 
@@ -266,7 +316,7 @@
 #define find_first_zero_bit(addr, size) \
         find_next_zero_bit((addr), (size), 0)
 
-extern __inline__ int find_next_zero_bit (void * addr, int size, int offset)
+static __inline__ int find_next_zero_bit (void * addr, int size, int offset)
 {
 	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
 	unsigned long result = offset & ~31UL;
@@ -302,18 +352,19 @@
 	return result + ffz(tmp);
 }
 
-extern __inline__ unsigned long ffs(unsigned long word)
+static __inline__ unsigned long ffs(unsigned long word)
 {
-	unsigned long result;
+	register unsigned long result asm("er0");
+	register unsigned long _word asm("er1");
 
-	__asm__("sub.l er0,er0\n\t"
-		"dec.l #1,er0\n"
+	_word = word;
+	__asm__("sub.l %0,%0\n\t"
+		"dec.l #1,%0\n"
 		"1:\n\t"
 		"shlr.l %1\n\t"
-		"adds #1,er0\n\t"
-		"bcc 1b\n\t"
-		"mov.l er0,%0"
-		: "=r" (result) : "r"(word) : "er0");
+		"adds #1,%0\n\t"
+		"bcc 1b"
+		: "=r" (result) : "r"(_word));
 	return result;
 }
 
@@ -352,62 +403,50 @@
 #define hweight16(x) generic_hweight16(x)
 #define hweight8(x) generic_hweight8(x)
 
-extern __inline__ int ext2_set_bit(int nr, volatile void *addr)
+static __inline__ int ext2_set_bit(int nr, volatile void * addr)
 {
-	unsigned char *a = (unsigned char *) addr;
-	register unsigned short r __asm__("er0");
-	a += nr >> 3;
-	__asm__("mov.l %1,er0\n\t"
-		"sub.w e0,e0\n\t"
-		"btst r0l,@%2\n\t"
-		"bset r0l,@%2\n\t"
-		"beq 1f\n\t"
-		"inc.w #1,e0\n"
-		"1:\n\t"
-		"mov.w e0,r0\n\t"
-		"sub.w e0,e0"
-		:"=r"(r):"r"(nr & 7),"r"(a));
-	return r;
+	int		mask, retval;
+	unsigned long	flags;
+	volatile unsigned char	*ADDR = (unsigned char *) addr;
+
+	ADDR += nr >> 3;
+	mask = 1 << (nr & 0x07);
+	local_irq_save(flags);
+	retval = (mask & *ADDR) != 0;
+	*ADDR |= mask;
+	local_irq_restore(flags);
+	return retval;
 }
 
-extern __inline__ int ext2_clear_bit(int nr, volatile void *addr)
+static __inline__ int ext2_clear_bit(int nr, volatile void * addr)
 {
-	unsigned char *a = (unsigned char *) addr;
-	register unsigned short r __asm__("er0");
-	a += nr >> 3;
-	__asm__("mov.l %1,er0\n\t"
-		"sub.w e0,e0\n\t"
-		"btst r0l,@%2\n\t"
-		"bclr r0l,@%2\n\t"
-		"beq 1f\n\t"
-		"inc.w #1,e0\n"
-		"1:\n\t"
-		"mov.w e0,r0\n\t"
-		"sub.w e0,e0"
-		:"=r"(r):"r"(nr & 7),"r"(a));
-	return r;
+	int		mask, retval;
+	unsigned long	flags;
+	volatile unsigned char	*ADDR = (unsigned char *) addr;
+
+	ADDR += nr >> 3;
+	mask = 1 << (nr & 0x07);
+	local_irq_save(flags);
+	retval = (mask & *ADDR) != 0;
+	*ADDR &= ~mask;
+	local_irq_restore(flags);
+	return retval;
 }
 
-extern __inline__ int ext2_test_bit(int nr, volatile void *addr)
+static __inline__ int ext2_test_bit(int nr, const volatile void * addr)
 {
-	unsigned char *a = (unsigned char *) addr;
-	int ret;
-	a += nr >> 3;
-	__asm__("mov.l %1,er0\n\t"
-		"sub.l %0,%0\n\t"
-		"btst r0l,@%2\n\t"
-		"beq 1f\n\t"
-		"inc.l #1,%0\n"
-		"1:"
-		: "=r"(ret) :"r"(nr & 7),"r"(a):"er0","er1");
-	return ret;
-}
+	int			mask;
+	const volatile unsigned char	*ADDR = (const unsigned char *) addr;
 
+	ADDR += nr >> 3;
+	mask = 1 << (nr & 0x07);
+	return ((mask & *ADDR) != 0);
+}
 
 #define ext2_find_first_zero_bit(addr, size) \
         ext2_find_next_zero_bit((addr), (size), 0)
 
-extern __inline__ unsigned long ext2_find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
+static __inline__ unsigned long ext2_find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
 {
 	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
 	unsigned long result = offset & ~31UL;
diff -Nru linux-2.6.0-test2/include/asm-h8300/checksum.h linux-2.6.0-test2-h8300/include/asm-h8300/checksum.h
--- linux-2.6.0-test2/include/asm-h8300/checksum.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/checksum.h	2003-07-19 21:41:33.000000000 +0900
@@ -49,15 +49,15 @@
 static inline unsigned int csum_fold(unsigned int sum)
 {
 	__asm__("mov.l %0,er0\n\t"
-	        "sub.w r1,r1\n\t"
 		"add.w e0,r0\n\t"
-		"addx #0,r1l\n\t"
-		"add.w r1,r0\n\t"
+		"xor.w e0,e0\n\t"
+		"rotxl.w e0\n\t"
+		"add.w e0,r0\n\t"
 		"sub.w e0,e0\n\t"
 		"mov.l er0,%0"
 		: "=r"(sum)
 		: "0"(sum)
-		: "er0","er1");
+		: "er0");
 	return ~sum;
 }
 
diff -Nru linux-2.6.0-test2/include/asm-h8300/edosk2674/timer_rate.h linux-2.6.0-test2-h8300/include/asm-h8300/edosk2674/timer_rate.h
--- linux-2.6.0-test2/include/asm-h8300/edosk2674/timer_rate.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/edosk2674/timer_rate.h	2003-07-20 01:18:09.000000000 +0900
@@ -0,0 +1,4 @@
+#include <linux/config.h>
+
+#define H8300_TIMER_COUNT_DATA CONFIG_CPU_CLOCK*10/8192
+#define H8300_TIMER_FREQ CONFIG_CPU_CLOCK*1000/8192
diff -Nru linux-2.6.0-test2/include/asm-h8300/errno.h linux-2.6.0-test2-h8300/include/asm-h8300/errno.h
--- linux-2.6.0-test2/include/asm-h8300/errno.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/errno.h	2003-07-14 15:17:52.000000000 +0900
@@ -1,132 +1,6 @@
 #ifndef _H8300_ERRNO_H
 #define _H8300_ERRNO_H
 
-#define	EPERM		 1	/* Operation not permitted */
-#define	ENOENT		 2	/* No such file or directory */
-#define	ESRCH		 3	/* No such process */
-#define	EINTR		 4	/* Interrupted system call */
-#define	EIO		 5	/* I/O error */
-#define	ENXIO		 6	/* No such device or address */
-#define	E2BIG		 7	/* Arg list too long */
-#define	ENOEXEC		 8	/* Exec format error */
-#define	EBADF		 9	/* Bad file number */
-#define	ECHILD		10	/* No child processes */
-#define	EAGAIN		11	/* Try again */
-#define	ENOMEM		12	/* Out of memory */
-#define	EACCES		13	/* Permission denied */
-#define	EFAULT		14	/* Bad address */
-#define	ENOTBLK		15	/* Block device required */
-#define	EBUSY		16	/* Device or resource busy */
-#define	EEXIST		17	/* File exists */
-#define	EXDEV		18	/* Cross-device link */
-#define	ENODEV		19	/* No such device */
-#define	ENOTDIR		20	/* Not a directory */
-#define	EISDIR		21	/* Is a directory */
-#define	EINVAL		22	/* Invalid argument */
-#define	ENFILE		23	/* File table overflow */
-#define	EMFILE		24	/* Too many open files */
-#define	ENOTTY		25	/* Not a typewriter */
-#define	ETXTBSY		26	/* Text file busy */
-#define	EFBIG		27	/* File too large */
-#define	ENOSPC		28	/* No space left on device */
-#define	ESPIPE		29	/* Illegal seek */
-#define	EROFS		30	/* Read-only file system */
-#define	EMLINK		31	/* Too many links */
-#define	EPIPE		32	/* Broken pipe */
-#define	EDOM		33	/* Math argument out of domain of func */
-#define	ERANGE		34	/* Math result not representable */
-#define	EDEADLK		35	/* Resource deadlock would occur */
-#define	ENAMETOOLONG	36	/* File name too long */
-#define	ENOLCK		37	/* No record locks available */
-#define	ENOSYS		38	/* Function not implemented */
-#define	ENOTEMPTY	39	/* Directory not empty */
-#define	ELOOP		40	/* Too many symbolic links encountered */
-#define	EWOULDBLOCK	EAGAIN	/* Operation would block */
-#define	ENOMSG		42	/* No message of desired type */
-#define	EIDRM		43	/* Identifier removed */
-#define	ECHRNG		44	/* Channel number out of range */
-#define	EL2NSYNC	45	/* Level 2 not synchronized */
-#define	EL3HLT		46	/* Level 3 halted */
-#define	EL3RST		47	/* Level 3 reset */
-#define	ELNRNG		48	/* Link number out of range */
-#define	EUNATCH		49	/* Protocol driver not attached */
-#define	ENOCSI		50	/* No CSI structure available */
-#define	EL2HLT		51	/* Level 2 halted */
-#define	EBADE		52	/* Invalid exchange */
-#define	EBADR		53	/* Invalid request descriptor */
-#define	EXFULL		54	/* Exchange full */
-#define	ENOANO		55	/* No anode */
-#define	EBADRQC		56	/* Invalid request code */
-#define	EBADSLT		57	/* Invalid slot */
-
-#define	EDEADLOCK	EDEADLK
-
-#define	EBFONT		59	/* Bad font file format */
-#define	ENOSTR		60	/* Device not a stream */
-#define	ENODATA		61	/* No data available */
-#define	ETIME		62	/* Timer expired */
-#define	ENOSR		63	/* Out of streams resources */
-#define	ENONET		64	/* Machine is not on the network */
-#define	ENOPKG		65	/* Package not installed */
-#define	EREMOTE		66	/* Object is remote */
-#define	ENOLINK		67	/* Link has been severed */
-#define	EADV		68	/* Advertise error */
-#define	ESRMNT		69	/* Srmount error */
-#define	ECOMM		70	/* Communication error on send */
-#define	EPROTO		71	/* Protocol error */
-#define	EMULTIHOP	72	/* Multihop attempted */
-#define	EDOTDOT		73	/* RFS specific error */
-#define	EBADMSG		74	/* Not a data message */
-#define	EOVERFLOW	75	/* Value too large for defined data type */
-#define	ENOTUNIQ	76	/* Name not unique on network */
-#define	EBADFD		77	/* File descriptor in bad state */
-#define	EREMCHG		78	/* Remote address changed */
-#define	ELIBACC		79	/* Can not access a needed shared library */
-#define	ELIBBAD		80	/* Accessing a corrupted shared library */
-#define	ELIBSCN		81	/* .lib section in a.out corrupted */
-#define	ELIBMAX		82	/* Attempting to link in too many shared libraries */
-#define	ELIBEXEC	83	/* Cannot exec a shared library directly */
-#define	EILSEQ		84	/* Illegal byte sequence */
-#define	ERESTART	85	/* Interrupted system call should be restarted */
-#define	ESTRPIPE	86	/* Streams pipe error */
-#define	EUSERS		87	/* Too many users */
-#define	ENOTSOCK	88	/* Socket operation on non-socket */
-#define	EDESTADDRREQ	89	/* Destination address required */
-#define	EMSGSIZE	90	/* Message too long */
-#define	EPROTOTYPE	91	/* Protocol wrong type for socket */
-#define	ENOPROTOOPT	92	/* Protocol not available */
-#define	EPROTONOSUPPORT	93	/* Protocol not supported */
-#define	ESOCKTNOSUPPORT	94	/* Socket type not supported */
-#define	EOPNOTSUPP	95	/* Operation not supported on transport endpoint */
-#define	EPFNOSUPPORT	96	/* Protocol family not supported */
-#define	EAFNOSUPPORT	97	/* Address family not supported by protocol */
-#define	EADDRINUSE	98	/* Address already in use */
-#define	EADDRNOTAVAIL	99	/* Cannot assign requested address */
-#define	ENETDOWN	100	/* Network is down */
-#define	ENETUNREACH	101	/* Network is unreachable */
-#define	ENETRESET	102	/* Network dropped connection because of reset */
-#define	ECONNABORTED	103	/* Software caused connection abort */
-#define	ECONNRESET	104	/* Connection reset by peer */
-#define	ENOBUFS		105	/* No buffer space available */
-#define	EISCONN		106	/* Transport endpoint is already connected */
-#define	ENOTCONN	107	/* Transport endpoint is not connected */
-#define	ESHUTDOWN	108	/* Cannot send after transport endpoint shutdown */
-#define	ETOOMANYREFS	109	/* Too many references: cannot splice */
-#define	ETIMEDOUT	110	/* Connection timed out */
-#define	ECONNREFUSED	111	/* Connection refused */
-#define	EHOSTDOWN	112	/* Host is down */
-#define	EHOSTUNREACH	113	/* No route to host */
-#define	EALREADY	114	/* Operation already in progress */
-#define	EINPROGRESS	115	/* Operation now in progress */
-#define	ESTALE		116	/* Stale NFS file handle */
-#define	EUCLEAN		117	/* Structure needs cleaning */
-#define	ENOTNAM		118	/* Not a XENIX named type file */
-#define	ENAVAIL		119	/* No XENIX semaphores available */
-#define	EISNAM		120	/* Is a named type file */
-#define	EREMOTEIO	121	/* Remote I/O error */
-#define	EDQUOT		122	/* Quota exceeded */
-
-#define	ENOMEDIUM	123	/* No medium found */
-#define	EMEDIUMTYPE	124	/* Wrong medium type */
+#include <asm-generic/errno.h>
 
 #endif /* _H8300_ERRNO_H */
diff -Nru linux-2.6.0-test2/include/asm-h8300/generic/timer_rate.h linux-2.6.0-test2-h8300/include/asm-h8300/generic/timer_rate.h
--- linux-2.6.0-test2/include/asm-h8300/generic/timer_rate.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/generic/timer_rate.h	2003-07-19 21:41:33.000000000 +0900
@@ -1,6 +1,6 @@
 #include <linux/config.h>
 
-#if defined(CONFIG_H83007) || defined(CONFIG_H83068)
+#if defined(CONFIG_H83007) || defined(CONFIG_H83068) || defined(CONFIG_H8S2678)
 #define H8300_TIMER_COUNT_DATA CONFIG_CPU_CLOCK*10/8192
 #define H8300_TIMER_FREQ CONFIG_CPU_CLOCK*1000/8192
 #endif
@@ -9,3 +9,7 @@
 #define H8300_TIMER_COUNT_DATA  CONFIG_CPU_CLOCK*10/8
 #define H8300_TIMER_FREQ CONFIG_CPU_CLOCK*1000/8
 #endif
+
+#if !defined(H8300_TIMER_COUNT_DATA)
+#error illigal configuration
+#endif
diff -Nru linux-2.6.0-test2/include/asm-h8300/gpio.h linux-2.6.0-test2-h8300/include/asm-h8300/gpio.h
--- linux-2.6.0-test2/include/asm-h8300/gpio.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/gpio.h	2003-07-19 21:41:33.000000000 +0900
@@ -7,11 +7,17 @@
 #define H8300_GPIO_P4 3
 #define H8300_GPIO_P5 4
 #define H8300_GPIO_P6 5
-/*#define H8300_GPIO_P7 6*/
+#define H8300_GPIO_P7 6
 #define H8300_GPIO_P8 7
 #define H8300_GPIO_P9 8
 #define H8300_GPIO_PA 9
 #define H8300_GPIO_PB 10
+#define H8300_GPIO_PC 11
+#define H8300_GPIO_PD 12
+#define H8300_GPIO_PE 13
+#define H8300_GPIO_PF 14
+#define H8300_GPIO_PG 15
+#define H8300_GPIO_PH 16
 
 #define H8300_GPIO_B7 0x80
 #define H8300_GPIO_B6 0x40
@@ -32,10 +38,10 @@
         h8300_free_gpio(port, bits)
 
 #define H8300_GPIO_DDR(port, bit, dir) \
-        h8300_set_gpio_dir(((port) << 8) | bit, dir)
+        h8300_set_gpio_dir(((port) << 8) | (bit), dir)
 
 #define H8300_GPIO_GETDIR(port, bit) \
-        h8300_get_gpio_dir(((port) << 8) | bit)
+        h8300_get_gpio_dir(((port) << 8) | (bit))
 
 extern int h8300_reserved_gpio(int port, int bits);
 extern int h8300_free_gpio(int port, int bits);
diff -Nru linux-2.6.0-test2/include/asm-h8300/h8max/ne.h linux-2.6.0-test2-h8300/include/asm-h8300/h8max/ne.h
--- linux-2.6.0-test2/include/asm-h8300/h8max/ne.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/h8max/ne.h	2003-07-19 21:41:33.000000000 +0900
@@ -1,5 +1,8 @@
 /* H8MAX RTL8019AS Config */
 
+#ifndef __H8300_H8MAX_NE__
+#define __H8300_H8MAX_NE__
+
 #define NE2000_ADDR		0x800600
 #define NE2000_IRQ              4
 #define NE2000_IRQ_VECTOR	(12 + NE2000_IRQ)
@@ -33,6 +36,14 @@
 # undef insw
 #endif
 #define insw(a,p,l)             h8max_insw((a) - NE2000_ADDR,(unsigned short *)p,l)
+#if defined(outsb)
+# undef outsb
+#endif
+#define outsb(a,p,l)            h8max_outsb((a) - NE2000_ADDR,(unsigned char *)p,l)
+#if defined(insb)
+# undef insb
+#endif
+#define insb(a,p,l)             h8max_insb((a) - NE2000_ADDR,(unsigned char *)p,l)
 
 #define H8300_INIT_NE()                  \
 do {                                     \
@@ -69,3 +80,18 @@
 	}
 }
 
+static inline void h8max_outsb(unsigned char a,unsigned char *p,unsigned long l)
+{
+	for (; l != 0; --l, p++) {
+		*(unsigned short *)(NE2000_ADDR + (a << 1)) = *p;
+	}
+}
+
+static inline void h8max_insb(unsigned char a,unsigned char *p,unsigned long l)
+{
+	for (; l != 0; --l, p++) {
+		*p = *((unsigned char *)(NE2000_ADDR + (a << 1))+1);
+	}
+}
+
+#endif
diff -Nru linux-2.6.0-test2/include/asm-h8300/h8max/timer_rate.h linux-2.6.0-test2-h8300/include/asm-h8300/h8max/timer_rate.h
--- linux-2.6.0-test2/include/asm-h8300/h8max/timer_rate.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/h8max/timer_rate.h	2003-07-20 01:19:25.000000000 +0900
@@ -0,0 +1,10 @@
+#ifndef __H8300_H8MAX_TIMER_RATE__
+#define __H8300_H8MAX_TIMER_RATE__
+
+#include <linux/config.h>
+
+#define H8300_TIMER_COUNT_DATA CONFIG_CPU_CLOCK*10/8192
+#define H8300_TIMER_FREQ CONFIG_CPU_CLOCK*1000/8192
+
+#endif
+
diff -Nru linux-2.6.0-test2/include/asm-h8300/io.h linux-2.6.0-test2-h8300/include/asm-h8300/io.h
--- linux-2.6.0-test2/include/asm-h8300/io.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/io.h	2003-07-14 15:17:52.000000000 +0900
@@ -41,15 +41,15 @@
 }
 
 #define readb(addr) \
-    ({ unsigned char __v = (*(volatile unsigned char *) (addr)); __v; })
+    ({ unsigned char __v = (*(volatile unsigned char *) (addr & 0x00ffffff)); __v; })
 #define readw(addr) \
-    ({ unsigned short __v = (*(volatile unsigned short *) (addr)); __v; })
+    ({ unsigned short __v = (*(volatile unsigned short *) (addr & 0x00ffffff)); __v; })
 #define readl(addr) \
-    ({ unsigned int __v = (*(volatile unsigned int *) (addr)); __v; })
+    ({ unsigned int __v = (*(volatile unsigned int *) (addr & 0x00ffffff)); __v; })
 
-#define writeb(b,addr) (void)((*(volatile unsigned char *) (addr)) = (b))
-#define writew(b,addr) (void)((*(volatile unsigned short *) (addr)) = (b))
-#define writel(b,addr) (void)((*(volatile unsigned int *) (addr)) = (b))
+#define writeb(b,addr) (void)((*(volatile unsigned char *) (addr & 0x00ffffff)) = (b))
+#define writew(b,addr) (void)((*(volatile unsigned short *) (addr & 0x00ffffff)) = (b))
+#define writel(b,addr) (void)((*(volatile unsigned int *) (addr & 0x00ffffff)) = (b))
 
 /*
  * The following are some defines we need for MTD with our
@@ -146,7 +146,7 @@
 #define insw(a,b,l) io_insw(a,b,l)
 #define insl(a,b,l) io_insl(a,b,l)
 
-#define IO_SPACE_LIMIT 0xffff
+#define IO_SPACE_LIMIT 0xffffff
 
 
 /* Values for nocacheflag and cmode */
diff -Nru linux-2.6.0-test2/include/asm-h8300/irq.h linux-2.6.0-test2-h8300/include/asm-h8300/irq.h
--- linux-2.6.0-test2/include/asm-h8300/irq.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/irq.h	2003-07-14 15:17:52.000000000 +0900
@@ -1,17 +1,14 @@
 #ifndef _H8300_IRQ_H_
 #define _H8300_IRQ_H_
 
-#define SYS_IRQS 64
-
-#define NR_IRQS 64
-
 #include <asm/ptrace.h>
 
-/*
- * "Generic" interrupt sources
- */
-
-#define IRQ_SCHED_TIMER	(40)    /* interrupt source for scheduling timer */
+#if defined(CONFIG_CPU_H8300H)
+#define NR_IRQS 64
+#endif
+#if defined(CONFIG_CPU_H8S)
+#define NR_IRQS 128
+#endif
 
 static __inline__ int irq_canonicalize(int irq)
 {
@@ -21,32 +18,6 @@
 extern void enable_irq(unsigned int);
 extern void disable_irq(unsigned int);
 
-extern int sys_request_irq(unsigned int, 
-	void (*)(int, void *, struct pt_regs *), 
-	unsigned long, const char *, void *);
-extern void sys_free_irq(unsigned int, void *);
-
-typedef struct irq_node {
-	void		(*handler)(int, void *, struct pt_regs *);
-	unsigned long	flags;
-	void		*dev_id;
-	const char	*devname;
-	struct irq_node *next;
-} irq_node_t;
-
-/*
- * This structure has only 4 elements for speed reasons
- */
-typedef struct irq_handler {
-	void		(*handler)(int, void *, struct pt_regs *);
-	unsigned long	flags;
-	void		*dev_id;
-	const char	*devname;
-} irq_handler_t;
-
-/* count of spurious interrupts */
-extern volatile unsigned int num_spurious;
-
 /*
  * Some drivers want these entry points
  */
diff -Nru linux-2.6.0-test2/include/asm-h8300/local.h linux-2.6.0-test2-h8300/include/asm-h8300/local.h
--- linux-2.6.0-test2/include/asm-h8300/local.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/local.h	2003-07-28 12:40:18.000000000 +0900
@@ -0,0 +1,6 @@
+#ifndef _H8300_LOCAL_H_
+#define _H8300_LOCAL_H_
+
+#include <asm-generic/local.h>
+
+#endif
diff -Nru linux-2.6.0-test2/include/asm-h8300/pgtable.h linux-2.6.0-test2-h8300/include/asm-h8300/pgtable.h
--- linux-2.6.0-test2/include/asm-h8300/pgtable.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/pgtable.h	2003-07-19 22:32:18.000000000 +0900
@@ -15,6 +15,9 @@
 #define pgd_clear(pgdp)
 #define kern_addr_valid(addr)	(1)
 #define	pmd_offset(a, b)	((void *)0)
+#define pmd_none(pmd)           (1)
+#define pgd_offset_k(adrdress)  ((pgd_t *)0)
+#define pte_offset_kernel(dir, address) ((pte_t *)0)
 
 #define PAGE_NONE		__pgprot(0)    /* these mean nothing to NO_MM */
 #define PAGE_SHARED		__pgprot(0)    /* these mean nothing to NO_MM */
@@ -31,6 +34,8 @@
 #define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
 #define __swp_entry_to_pte(x)	((pte_t) { (x).val })
 
+static inline int pte_file(pte_t pte) { return 0; }
+
 /*
  * ZERO_PAGE is a global shared page that is always zero: used
  * for zero-mapped memory areas etc..
@@ -49,4 +54,18 @@
 #define pgtable_cache_init()   do { } while (0)
 #define io_remap_page_range	remap_page_range
 
+/*
+ * All 32bit addresses are effectively valid for vmalloc...
+ * Sort of meaningless for non-VM targets.
+ */
+#define	VMALLOC_START	0
+#define	VMALLOC_END	0xffffffff
+
+/*
+ * All 32bit addresses are effectively valid for vmalloc...
+ * Sort of meaningless for non-VM targets.
+ */
+#define	VMALLOC_START	0
+#define	VMALLOC_END	0xffffffff
+
 #endif /* _H8300_PGTABLE_H */
diff -Nru linux-2.6.0-test2/include/asm-h8300/processor.h linux-2.6.0-test2-h8300/include/asm-h8300/processor.h
--- linux-2.6.0-test2/include/asm-h8300/processor.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/processor.h	2003-07-19 21:41:33.000000000 +0900
@@ -52,17 +52,16 @@
 #define MCA_bus 0
 
 struct thread_struct {
-	unsigned long  ksp;		/* kernel stack pointer */
-	unsigned long  usp;		/* user stack pointer */
-	unsigned short ccr;		/* saved status register */
-	unsigned long  esp0;            /* points to SR of stack frame */
-	unsigned long  vfork_ret;
-	unsigned long  debugreg[8];     /* debug info */
-} __attribute__((aligned(2),packed));
+	unsigned long ksp;		/* kernel stack pointer */
+	unsigned long usp;		/* user stack pointer */
+	unsigned long ccr;		/* saved status register */
+	unsigned long esp0;             /* points to SR of stack frame */
+	unsigned long debugreg[8];      /* debug info */
+};
 
 #define INIT_THREAD  { \
 	sizeof(init_stack) + (unsigned long) init_stack, 0, \
-	PS_S,  0, 0, \
+	PS_S, \
 }
 
 /*
@@ -71,13 +70,25 @@
  * pass the data segment into user programs if it exists,
  * it can't hurt anything as far as I can tell
  */
+#if defined(__H8300S__)
 #define start_thread(_regs, _pc, _usp)			        \
 do {							        \
+	set_fs(USER_DS);           /* reads from user space */  \
+  	(_regs)->pc = (_pc);				        \
+	(_regs)->ccr &= ~0x10;	   /* clear kernel flag */      \
+} while(0)
+#endif
+#if defined(__H8300S__)
+#define start_thread(_regs, _pc, _usp)			        \
+do {							        \
+	set_fs(USER_DS);           /* reads from user space */  \
 	(_regs)->pc = (_pc);				        \
-	(_regs)->ccr &= ~0x10;				        \
-        *((unsigned long *)(_usp)-1) = _pc;                     \
-	wrusp((unsigned long)(_usp) - sizeof(unsigned long)*3);	\
+	(_regs)->ccr &= ~0x10;	   /* clear kernel flag */      \
+	(_regs)->exr = 0x78;       /* enable all interrupts */  \
+	/* 14 = space for retaddr(4), vector(4), er0(4) and ext(2) on stack */ \
+	wrusp(((unsigned long)(_usp)) - 14);                    \
 } while(0)
+#endif
 
 /* Forward declaration, a strange C thing */
 struct task_struct;
diff -Nru linux-2.6.0-test2/include/asm-h8300/ptrace.h linux-2.6.0-test2-h8300/include/asm-h8300/ptrace.h
--- linux-2.6.0-test2/include/asm-h8300/ptrace.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/ptrace.h	2003-07-14 15:17:52.000000000 +0900
@@ -19,6 +19,10 @@
    stack during a system call. */
 
 struct pt_regs {
+	long     retpc;
+	long     er4;
+	long     er5;
+	long     er6;
 	long     er3;
 	long     er2;
 	long     er1;
@@ -26,20 +30,12 @@
 	unsigned short ccr;
 	long     er0;
 	long     vector;
+#if defined(CONFIG_CPU_H8S)
+	unsigned short exr;
+#endif
 	unsigned long  pc;
 } __attribute__((aligned(2),packed));
 
-/*
- * This is the extended stack used by signal handlers and the context
- * switcher: it's pushed after the normal "struct pt_regs".
- */
-struct switch_stack {
-	unsigned long  er6;
-	unsigned long  er5;
-	unsigned long  er4;
-	unsigned long  retpc;
-};
-
 #define PTRACE_GETREGS            12
 #define PTRACE_SETREGS            13
 
diff -Nru linux-2.6.0-test2/include/asm-h8300/regs306x.h linux-2.6.0-test2-h8300/include/asm-h8300/regs306x.h
--- linux-2.6.0-test2/include/asm-h8300/regs306x.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/regs306x.h	2003-07-19 21:41:33.000000000 +0900
@@ -6,7 +6,7 @@
 
 #if defined(__KERNEL__)
 
-#define DASTCR *(volatile unsigned char *)0xFEE01A
+#define DASTCR 0xFEE01A
 #define DADR0  0xFEE09C
 #define DADR1  0xFEE09D
 #define DACR   0xFEE09E
diff -Nru linux-2.6.0-test2/include/asm-h8300/sections.h linux-2.6.0-test2-h8300/include/asm-h8300/sections.h
--- linux-2.6.0-test2/include/asm-h8300/sections.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/sections.h	2003-07-28 12:40:18.000000000 +0900
@@ -0,0 +1,6 @@
+#ifndef _H8300_SECTIONS_H_
+#define _H8300_SECTIONS_H_
+
+#include <asm-generic/sections.h>
+
+#endif
diff -Nru linux-2.6.0-test2/include/asm-h8300/semaphore.h linux-2.6.0-test2-h8300/include/asm-h8300/semaphore.h
--- linux-2.6.0-test2/include/asm-h8300/semaphore.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/semaphore.h	2003-07-28 12:40:18.000000000 +0900
@@ -51,7 +51,7 @@
 #define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name,1)
 #define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
 
-extern inline void sema_init (struct semaphore *sem, int val)
+static inline void sema_init (struct semaphore *sem, int val)
 {
 	*sem = (struct semaphore)__SEMAPHORE_INITIALIZER(*sem, val);
 }
@@ -83,92 +83,187 @@
  * "down_failed" is a special asm handler that calls the C
  * routine that actually waits. See arch/m68k/lib/semaphore.S
  */
-extern inline void down(struct semaphore * sem)
+#if defined(__H8300H__)
+static inline void down(struct semaphore * sem)
 {
+	register atomic_t *count asm("er0");
+
 #if WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
 #endif
 
+	count = &(sem->count);
 	__asm__ __volatile__(
-		"stc ccr,r4l\n\t"
+		"stc ccr,r3l\n\t"
 		"orc #0x80,ccr\n\t"
-		"mov.l @%0, er0\n\t"
-		"dec.l #1,er0\n\t"
-		"mov.l er0,@%0\n\t"
+		"mov.l @%1, er1\n\t"
+		"dec.l #1,er1\n\t"
+		"mov.l er1,@%1\n\t"
 		"bpl 1f\n\t"
-		"ldc r4l,ccr\n\t"
-		"mov.l %0,er0\n\t"
-		"jsr @___down\n"
+		"ldc r3l,ccr\n\t"
+		"jsr @___down\n\t"
+		"bra 2f\n"
 		"1:\n\t"
-		"ldc r4l,ccr"
-		: /* no outputs */
-		: "r" (&(sem->count))
-		: "cc", "er0", "er1", "er2", "er3", "er4", "memory");
+		"ldc r3l,ccr\n"
+		"2:"
+		: "=m"(sem->count)
+		: "g" (count)
+		: "cc", "er1", "er2", "er3", "er4", "memory");
+}
+#endif
+#if defined(__H8300S__)
+static inline void down(struct semaphore * sem)
+{
+	register atomic_t *count asm("er0");
+
+#if WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+
+	count = &(sem->count);
+	__asm__ __volatile__(
+		"stc exr,r3l\n\t"
+		"orc #0x07,exr\n\t"
+		"mov.l @%1, er1\n\t"
+		"dec.l #1,er1\n\t"
+		"mov.l er1,@%1\n\t"
+		"ldc r3l,exr\n\t"
+		"bpl 1f\n\t"
+		"jsr @___down\n"
+		"1:"
+		: "=m"(sem->count)
+		: "r" (count)
+		: "cc", "er1", "er2", "er3", "memory");
 }
+#endif
 
-extern inline int down_interruptible(struct semaphore * sem)
+#if defined(__H8300H__)
+static inline int down_interruptible(struct semaphore * sem)
 {
-	register int ret __asm__("er0");
+	register atomic_t *count asm("er0");
 
 #if WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
 #endif
 
+	count = &(sem->count);
 	__asm__ __volatile__(
-		"stc ccr,r1l\n\t"
+		"stc ccr,r3l\n\t"
 		"orc #0x80,ccr\n\t"
-		"mov.l @%1, er2\n\t"
+		"mov.l @%2, er2\n\t"
 		"dec.l #1,er2\n\t"
-		"mov.l er2,@%1\n\t"
+		"mov.l er2,@%2\n\t"
 		"bpl 1f\n\t"
-		"ldc r1l,ccr\n\t"
-		"mov.l %1,er0\n\t"
+		"ldc r3l,ccr\n\t"
 		"jsr @___down_interruptible\n\t"
 		"bra 2f\n"
 		"1:\n\t"
-		"ldc r1l,ccr\n\t"
+		"ldc r3l,ccr\n\t"
+		"sub.l %0,%0\n"
+		"2:"
+		: "=r" (count),"=m"(sem->count)
+		: "r" (count)
+		: "cc", "er1", "er2", "er3", "memory");
+	return (int)count;
+}
+#endif
+#if defined(__H8300S__)
+static inline int down_interruptible(struct semaphore * sem)
+{
+	register atomic_t *count asm("er0");
+
+#if WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+
+	count = &(sem->count);
+	__asm__ __volatile__(
+		"stc exr,r3l\n\t"
+		"orc #0x07,exr\n\t"
+		"mov.l @%2, er2\n\t"
+		"dec.l #1,er2\n\t"
+		"mov.l er2,@%2\n\t"
+		"ldc r3l,exr\n\t"
+		"bmi 1f\n\t"
 		"sub.l %0,%0\n\t"
-		"2:\n\t"
-		: "=r" (ret)
-		: "r" (&(sem->count))
+		"bra 2f\n"
+		"1:\n\t"
+		"jsr @___down_interruptible\n"
+		"2:"
+		: "=r" (count),"=m"(sem->count)
+		: "r" (count)
 		: "cc", "er1", "er2", "er3", "memory");
-	return ret;
+	return (int)count;
 }
+#endif
 
-extern inline int down_trylock(struct semaphore * sem)
+#if defined(__H8300H__)
+static inline int down_trylock(struct semaphore * sem)
 {
-	register int result;
+	register atomic_t *count asm("er0");
 
 #if WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
 #endif
 
+	count = &(sem->count);
 	__asm__ __volatile__(
-		"stc ccr,r4l\n\t"
+		"stc ccr,r3l\n\t"
 		"orc #0x80,ccr\n\t"
-		"mov.l @%1,er0\n\t"
-		"dec.l #1,er0\n\t"
-		"mov.l er0,@%1\n\t"
+		"mov.l @%2,er2\n\t"
+		"dec.l #1,er2\n\t"
+		"mov.l er2,@%2\n\t"
 		"bpl 1f\n\t"
-		"ldc r4l,ccr\n\t"
+		"ldc r3l,ccr\n\t"
 		"jmp @3f\n"
 		"1:\n\t"
-		"ldc r4l,ccr\n\t"
+		"ldc r3l,ccr\n\t"
 		"sub.l %0,%0\n"
-		"2:\n"
-		".section .text.lock,\"ax\"\n"
-		".align 2\n"
+		LOCK_SECTION_START(".align 2\n\t")
 		"3:\n\t"
-		"mov.l %1,er0\n\t"
-		"jsr @___down_trylock\n"
-		"mov.l er0,%0\n\t"
-		"jmp @2b\n\t"
-		".previous"
-		: "=r" (result)
-		: "r" (&(sem->count))
-		: "cc", "er0","er4", "memory");
-	return result;
+		"jsr @___down_trylock\n\t"
+		"jmp @2f\n\t"
+		LOCK_SECTION_END
+		"2:"
+		: "=r" (count),"=m"(sem->count)
+		: "r" (count)
+		: "cc", "er2", "er3", "memory");
+	return (int)count;
 }
+#endif
+#if defined(__H8300S__)
+static inline int down_trylock(struct semaphore * sem)
+{
+	register atomic_t *count asm("er0");
+
+#if WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+
+	count = &(sem->count);
+	__asm__ __volatile__(
+		"stc exr,r3l\n\t"
+		"orc #0x07,exr\n\t"
+		"mov.l @%2,er2\n\t"
+		"dec.l #1,er2\n\t"
+		"mov.l er2,@%2\n\t"
+		"ldc r3l,exr\n\t"
+		"bpl 1f\n\t"
+		"jmp @3f\n"
+		"1:\n\t"
+		"sub.l %0,%0\n\t"
+		LOCK_SECTION_START(".align 2\n\t")
+		"3:\n\t"
+		"jsr @___down_trylock\n\t"
+		"jmp @2f\n\t"
+		LOCK_SECTION_END
+		"2:\n\t"
+		: "=r" (count),"=m"(sem->count)
+		: "r" (count)
+		: "cc", "er1", "er2", "er3", "memory");
+	return (int)count;
+}
+#endif
 
 /*
  * Note! This is subtle. We jump to wake people up only if
@@ -176,30 +271,60 @@
  * The default case (no contention) will result in NO
  * jumps for both down() and up().
  */
-extern inline void up(struct semaphore * sem)
+#if defined(__H8300H__)
+static inline void up(struct semaphore * sem)
 {
+	register atomic_t *count asm("er0");
+
 #if WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
 #endif
 
+	count = &(sem->count);
 	__asm__ __volatile__(
-		"stc ccr,r4l\n\t"
+		"stc ccr,r3l\n\t"
 		"orc #0x80,ccr\n\t"
-		"mov.l @%0,er0\n\t"
-		"inc.l #1,er0\n\t"
-		"mov.l er0,@%0\n\t"
-		"bmi 1f\n\t"
-		"bne 2f\n\t"
-		"1:\n\t"
-		"ldc r4l,ccr\n\t"
-		"mov.l %0,er0\n\t"
+		"mov.l @%1,er1\n\t"
+		"inc.l #1,er1\n\t"
+		"mov.l er1,@%1\n\t"
+		"ldc r3l,ccr\n\t"
+		"sub.l er2,er2\n\t"
+		"cmp.l er2,er1\n\t"
+		"bgt 1f\n\t"
 		"jsr @___up\n"
-		"2:\n\t"
-                "ldc r4l,ccr"
-		: /* no outputs */
-		: "r" (&(sem->count))
-		: "cc", "er0", "er4", "memory");
+		"1:"
+		: "=m"(sem->count)
+		: "r" (count)
+		: "cc", "er1", "er2", "er3", "memory");
 }
+#endif
+#if defined(__H8300S__)
+static inline void up(struct semaphore * sem)
+{
+	register atomic_t *count asm("er0");
+
+#if WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+
+	count = &(sem->count);
+	__asm__ __volatile__(
+		"stc exr,r3l\n\t"
+		"orc #0x07,exr\n\t"
+		"mov.l @%1,er1\n\t"
+		"inc.l #1,er1\n\t"
+		"mov.l er1,@%1\n\t"
+		"ldc r3l,exr\n\t"
+		"sub.l er2,er2\n\t"
+		"cmp.l er2,er1\n\t"
+		"bgt 1f\n\t"
+		"jsr @___up\n"
+		"1:"
+		: "=m"(sem->count)
+		: "r" (count)
+		: "cc", "er1", "er2", "er3", "memory");
+}
+#endif
 
 #endif /* __ASSEMBLY__ */
 
diff -Nru linux-2.6.0-test2/include/asm-h8300/system.h linux-2.6.0-test2-h8300/include/asm-h8300/system.h
--- linux-2.6.0-test2/include/asm-h8300/system.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/system.h	2003-07-19 21:41:33.000000000 +0900
@@ -36,17 +36,20 @@
  * H8/300 Porting 2002/09/04 Yoshinori Sato
  */
 asmlinkage void resume(void);
-#define switch_to(prev,next,last) { \
-  void *_last;								        \
-  __asm__ __volatile__(								\
-  			"mov.l	%1, er0\n\t"					\
-			"mov.l	%2, er1\n\t"					\
-			"jsr @_resume"                                          \
-		       : "=r" (_last)						\
-		       : "r" (&(prev->thread)),				        \
-			 "r" (&(next->thread))				        \
-		       : "cc", "er0", "er1", "er2", "er3");	                \
-  (last) = _last; 								\
+#define switch_to(prev,next,last) {                         \
+  void *_last;						    \
+  __asm__ __volatile__(					    \
+  			"mov.l	%1, er0\n\t"		    \
+			"mov.l	%2, er1\n\t"		    \
+                        "mov.l  %3, er2\n\t"                \
+			"jsr @_resume\n\t"                  \
+                        "mov.l  er2,%0\n\t"                 \
+		       : "=r" (_last)			    \
+		       : "r" (&(prev->thread)),		    \
+			 "r" (&(next->thread)),		    \
+                         "g" (prev)                         \
+		       : "cc", "er0", "er1", "er2", "er3"); \
+  (last) = _last; 					    \
 }
 
 #if defined(__H8300H__)
@@ -54,17 +57,25 @@
 #define __cli() asm volatile ("orc  #0x80,ccr")
 
 #define __save_flags(x) \
-       asm volatile ("sub.l er0,er0\n\tstc ccr,r0l\n\tmov.l er0,%0":"=r" (x) : : "er0")
+       asm volatile ("stc ccr,r0l\n\tmov.l er0,%0":"=r" (x) : : "er0")
 
 #define __restore_flags(x) \
        asm volatile ("mov.l %0,er0\n\tldc r0l,ccr": :"r" (x) : "er0")
+
+#define	irqs_disabled()			\
+({					\
+	unsigned long flags;		\
+	__save_flags(flags);	        \
+	((flags & 0x80) == 0x80);	\
+})
+
 #endif
 #if defined(__H8300S__)
 #define __sti() asm volatile ("andc #0xf8,exr")
 #define __cli() asm volatile ("orc  #0x07,exr")
 
 #define __save_flags(x) \
-       asm volatile ("sub.l er0,er0\n\tstc exr,r0l\n\tmov.l er0,%0":"=r" (x) : : "er0")
+       asm volatile ("stc exr,r0l\n\tmov.l er0,%0":"=r" (x) : : "er0")
 
 #define __restore_flags(x) \
        asm volatile ("mov.l %0,er0\n\tldc r0l,exr": :"r" (x) : "er0")
@@ -73,22 +84,22 @@
 #define	irqs_disabled()			\
 ({					\
 	unsigned long flags;		\
-	__save_flags(flags);	\
-	((flags & 0x80) == 0x80);	\
+	__save_flags(flags);	        \
+	((flags & 0x07) == 0x07);	\
 })
 
 #define iret() __asm__ __volatile__ ("rte": : :"memory", "sp", "cc")
 
 /* For spinlocks etc */
-#define local_irq_disable()	asm volatile ("orc  #0x80,ccr")
-#define local_irq_enable()      asm volatile ("andc #0x7f,ccr")
+#define local_irq_disable()	__cli()
+#define local_irq_enable()      __sti()
 #define local_irq_save(x)	({ __save_flags(x); local_irq_disable(); })
 #define local_irq_restore(x)	__restore_flags(x)
 #define local_save_flags(x)     __save_flags(x)
 
 /*
  * Force strict CPU ordering.
- * Not really required on m68k...
+ * Not really required on H8...
  */
 #define nop()  asm volatile ("nop"::)
 #define mb()   asm volatile (""   : : :"memory")
diff -Nru linux-2.6.0-test2/include/asm-h8300/target_time.h linux-2.6.0-test2-h8300/include/asm-h8300/target_time.h
--- linux-2.6.0-test2/include/asm-h8300/target_time.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/target_time.h	2003-07-14 15:17:52.000000000 +0900
@@ -1,4 +1,4 @@
 extern int platform_timer_setup(void (*timer_int)(int, void *, struct pt_regs *));
 extern void platform_timer_eoi(void);
-extern void platfrom_gettod(unsigned int *year, unsigned int *mon, unsigned int *day, 
+extern void platform_gettod(unsigned int *year, unsigned int *mon, unsigned int *day, 
                             unsigned int *hour, unsigned int *min, unsigned int *sec);
diff -Nru linux-2.6.0-test2/include/asm-h8300/thread_info.h linux-2.6.0-test2-h8300/include/asm-h8300/thread_info.h
--- linux-2.6.0-test2/include/asm-h8300/thread_info.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/thread_info.h	2003-07-14 15:17:52.000000000 +0900
@@ -59,7 +59,7 @@
 		"mov.l	sp, %0 \n\t"
 		"and.l	%1, %0"
 		: "=&r"(ti)
-		: "r" (~(THREAD_SIZE-1))
+		: "g" (~(THREAD_SIZE-1))
 		);
 	return ti;
 }
diff -Nru linux-2.6.0-test2/include/asm-h8300/tlb.h linux-2.6.0-test2-h8300/include/asm-h8300/tlb.h
--- linux-2.6.0-test2/include/asm-h8300/tlb.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/tlb.h	2003-07-19 21:41:33.000000000 +0900
@@ -1 +1,23 @@
+/* 
+  include/asm-h8300/tlb.h 
+*/
+
+#ifndef __H8300_TLB_H__
+#define __H8300_TLB_H__
+
+#define tlb_flush(tlb)	do { } while(0)
+
+/* 
+  include/asm-h8300/tlb.h 
+*/
+
+#ifndef __H8300_TLB_H__
+#define __H8300_TLB_H__
+
+#define tlb_flush(tlb)	do { } while(0)
+
 #include <asm-generic/tlb.h>
+
+#endif
+
+#endif
diff -Nru linux-2.6.0-test2/include/asm-h8300/traps.h linux-2.6.0-test2-h8300/include/asm-h8300/traps.h
--- linux-2.6.0-test2/include/asm-h8300/traps.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/traps.h	2003-07-14 15:17:52.000000000 +0900
@@ -1,7 +1,7 @@
 /*
- *  linux/include/asm/traps.h
+ *  linux/include/asm-h8300/traps.h
  *
- *  Copyright (C) 1993        Hamish Macdonald
+ *  Copyright (C) 2003 Yoshinori Sato <ysato@users.sourceforge.jp>
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file COPYING in the main directory of this archive
@@ -11,197 +11,18 @@
 #ifndef _H8300_TRAPS_H
 #define _H8300_TRAPS_H
 
-#if 0
-#ifndef __ASSEMBLY__
-
-typedef void (*e_vector)(void);
-
-extern e_vector vectors[];
-
-#endif
-
-#define VEC_BUSERR  (2)
-#define VEC_ADDRERR (3)
-#define VEC_ILLEGAL (4)
-#define VEC_ZERODIV (5)
-#define VEC_CHK     (6)
-#define VEC_TRAP    (7)
-#define VEC_PRIV    (8)
-#define VEC_TRACE   (9)
-#define VEC_LINE10  (10)
-#define VEC_LINE11  (11)
-#define VEC_RESV1   (12)
-#define VEC_COPROC  (13)
-#define VEC_FORMAT  (14)
-#define VEC_UNINT   (15)
-#define VEC_SPUR    (24)
-#define VEC_INT1    (25)
-#define VEC_INT2    (26)
-#define VEC_INT3    (27)
-#define VEC_INT4    (28)
-#define VEC_INT5    (29)
-#define VEC_INT6    (30)
-#define VEC_INT7    (31)
-#define VEC_SYS     (32)
-#define VEC_TRAP1   (33)
-#define VEC_TRAP2   (34)
-#define VEC_TRAP3   (35)
-#define VEC_TRAP4   (36)
-#define VEC_TRAP5   (37)
-#define VEC_TRAP6   (38)
-#define VEC_TRAP7   (39)
-#define VEC_TRAP8   (40)
-#define VEC_TRAP9   (41)
-#define VEC_TRAP10  (42)
-#define VEC_TRAP11  (43)
-#define VEC_TRAP12  (44)
-#define VEC_TRAP13  (45)
-#define VEC_TRAP14  (46)
-#define VEC_TRAP15  (47)
-#define VEC_FPBRUC  (48)
-#define VEC_FPIR    (49)
-#define VEC_FPDIVZ  (50)
-#define VEC_FPUNDER (51)
-#define VEC_FPOE    (52)
-#define VEC_FPOVER  (53)
-#define VEC_FPNAN   (54)
-#define VEC_FPUNSUP (55)
-#define	VEC_UNIMPEA (60)
-#define	VEC_UNIMPII (61)
-#define VEC_USER    (64)
-
-#define VECOFF(vec) ((vec)<<2)
-
-#ifndef __ASSEMBLY__
-
-/* Status register bits */
-#define PS_T  (0x8000)
-#define PS_S  (0x2000)
-#define PS_M  (0x1000)
-#define PS_C  (0x0001)
-
-/* bits for 68020/68030 special status word */
-
-#define FC    (0x8000)
-#define FB    (0x4000)
-#define RC    (0x2000)
-#define RB    (0x1000)
-#define DF    (0x0100)
-#define RM    (0x0080)
-#define RW    (0x0040)
-#define SZ    (0x0030)
-#define DFC   (0x0007)
-
-/* bits for 68030 MMU status register (mmusr,psr) */
-
-#define MMU_B	     (0x8000)    /* bus error */
-#define MMU_L	     (0x4000)    /* limit violation */
-#define MMU_S	     (0x2000)    /* supervisor violation */
-#define MMU_WP	     (0x0800)    /* write-protected */
-#define MMU_I	     (0x0400)    /* invalid descriptor */
-#define MMU_M	     (0x0200)    /* ATC entry modified */
-#define MMU_T	     (0x0040)    /* transparent translation */
-#define MMU_NUM      (0x0007)    /* number of levels traversed */
-
-
-/* bits for 68040 special status word */
-#define CP_040	(0x8000)
-#define CU_040	(0x4000)
-#define CT_040	(0x2000)
-#define CM_040	(0x1000)
-#define MA_040	(0x0800)
-#define ATC_040 (0x0400)
-#define LK_040	(0x0200)
-#define RW_040	(0x0100)
-#define SIZ_040 (0x0060)
-#define TT_040	(0x0018)
-#define TM_040	(0x0007)
-
-/* bits for 68040 write back status word */
-#define WBV_040   (0x80)
-#define WBSIZ_040 (0x60)
-#define WBBYT_040 (0x20)
-#define WBWRD_040 (0x40)
-#define WBLNG_040 (0x00)
-#define WBTT_040  (0x18)
-#define WBTM_040  (0x07)
-
-/* bus access size codes */
-#define BA_SIZE_BYTE    (0x20)
-#define BA_SIZE_WORD    (0x40)
-#define BA_SIZE_LONG    (0x00)
-#define BA_SIZE_LINE    (0x60)
-
-/* bus access transfer type codes */
-#define BA_TT_MOVE16    (0x08)
-
-/* structure for stack frames */
-
-struct frame {
-    struct pt_regs ptregs;
-    union {
-	    struct {
-		    unsigned long  iaddr;    /* instruction address */
-	    } fmt2;
-	    struct {
-		    unsigned long  effaddr;  /* effective address */
-	    } fmt3;
-	    struct {
-		    unsigned long  effaddr;  /* effective address */
-		    unsigned long  pc;	     /* pc of faulted instr */
-	    } fmt4;
-	    struct {
-		    unsigned long  effaddr;  /* effective address */
-		    unsigned short ssw;      /* special status word */
-		    unsigned short wb3s;     /* write back 3 status */
-		    unsigned short wb2s;     /* write back 2 status */
-		    unsigned short wb1s;     /* write back 1 status */
-		    unsigned long  faddr;    /* fault address */
-		    unsigned long  wb3a;     /* write back 3 address */
-		    unsigned long  wb3d;     /* write back 3 data */
-		    unsigned long  wb2a;     /* write back 2 address */
-		    unsigned long  wb2d;     /* write back 2 data */
-		    unsigned long  wb1a;     /* write back 1 address */
-		    unsigned long  wb1dpd0;  /* write back 1 data/push data 0*/
-		    unsigned long  pd1;      /* push data 1*/
-		    unsigned long  pd2;      /* push data 2*/
-		    unsigned long  pd3;      /* push data 3*/
-	    } fmt7;
-	    struct {
-		    unsigned long  iaddr;    /* instruction address */
-		    unsigned short int1[4];  /* internal registers */
-	    } fmt9;
-	    struct {
-		    unsigned short int1;
-		    unsigned short ssw;      /* special status word */
-		    unsigned short isc;      /* instruction stage c */
-		    unsigned short isb;      /* instruction stage b */
-		    unsigned long  daddr;    /* data cycle fault address */
-		    unsigned short int2[2];
-		    unsigned long  dobuf;    /* data cycle output buffer */
-		    unsigned short int3[2];
-	    } fmta;
-	    struct {
-		    unsigned short int1;
-		    unsigned short ssw;     /* special status word */
-		    unsigned short isc;     /* instruction stage c */
-		    unsigned short isb;     /* instruction stage b */
-		    unsigned long  daddr;   /* data cycle fault address */
-		    unsigned short int2[2];
-		    unsigned long  dobuf;   /* data cycle output buffer */
-		    unsigned short int3[4];
-		    unsigned long  baddr;   /* stage B address */
-		    unsigned short int4[2];
-		    unsigned long  dibuf;   /* data cycle input buffer */
-		    unsigned short int5[3];
-		    unsigned	   ver : 4; /* stack frame version # */
-		    unsigned	   int6:12;
-		    unsigned short int7[18];
-	    } fmtb;
-    } un;
-};
-
-#endif /* __ASSEMBLY__ */
-#endif
+extern void system_call(void);
+extern void interrupt_entry(void);
+extern void trace_break(void);
+
+#define JMP_OP 0x5a000000
+#define JSR_OP 0x5e000000
+#define VECTOR(address) ((JMP_OP)|((unsigned long)address))
+#define REDIRECT(address) ((JSR_OP)|((unsigned long)address))
+
+#define TRAP0_VEC 8
+#define TRAP1_VEC 9
+#define TRAP2_VEC 10
+#define TRAP3_VEC 11
 
 #endif /* _H8300_TRAPS_H */
diff -Nru linux-2.6.0-test2/include/asm-h8300/types.h linux-2.6.0-test2-h8300/include/asm-h8300/types.h
--- linux-2.6.0-test2/include/asm-h8300/types.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/types.h	2003-07-19 22:32:18.000000000 +0900
@@ -1,6 +1,8 @@
 #ifndef _H8300_TYPES_H
 #define _H8300_TYPES_H
 
+#if !defined(__ASSEMBLY__)
+
 /*
  * This file is never included by application software unless
  * explicitly requested (e.g., via linux/types.h) in which case the
@@ -53,6 +55,11 @@
 
 typedef u32 dma_addr_t;
 
+#define HAVE_SECTOR_T
+typedef u64 sector_t;
+
 #endif /* __KERNEL__ */
 
+#endif /* __ASSEMBLY__ */
+
 #endif /* _H8300_TYPES_H */
diff -Nru linux-2.6.0-test2/include/asm-h8300/uaccess.h linux-2.6.0-test2-h8300/include/asm-h8300/uaccess.h
--- linux-2.6.0-test2/include/asm-h8300/uaccess.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/uaccess.h	2003-07-14 15:17:52.000000000 +0900
@@ -14,16 +14,17 @@
 #define VERIFY_WRITE	1
 
 /* We let the MMU do all checking */
-extern inline int access_ok(int type, const void * addr, unsigned long size)
+#define access_ok(type, addr, size) __access_ok((unsigned long)addr,size)
+static inline int __access_ok(unsigned long addr, unsigned long size)
 {
 #define	RANGE_CHECK_OK(addr, size, lower, upper) \
 	(((addr) >= (lower)) && (((addr) + (size)) < (upper)))
 
 	extern unsigned long _ramend;
-	return(RANGE_CHECK_OK((unsigned long) addr, size, 0L, (unsigned long)&_ramend));
+	return(RANGE_CHECK_OK(addr, size, 0L, (unsigned long)&_ramend));
 }
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void *addr, unsigned long size)
 {
 	return access_ok(type,addr,size)?0:-EFAULT;
 }
diff -Nru linux-2.6.0-test2/include/asm-h8300/unistd.h linux-2.6.0-test2-h8300/include/asm-h8300/unistd.h
--- linux-2.6.0-test2/include/asm-h8300/unistd.h	2003-07-14 15:01:26.000000000 +0900
+++ linux-2.6.0-test2-h8300/include/asm-h8300/unistd.h	2003-07-14 15:17:52.000000000 +0900
@@ -405,8 +405,39 @@
 			  "g" ((long)b),					\
 			  "g" ((long)c),					\
 			  "g" ((long)d),					\
-			  "g" ((long)e)						\
-			: "cc", "er1", "er2", "er3", "er4");			\
+			  "m" ((long)e)						\
+			: "cc", "er1", "er2", "er3", "er4", "er5");		\
+  if ((unsigned long)(__res) >= (unsigned long)(-125)) {		       	\
+    errno = -__res;								\
+    __res = -1;									\
+  }										\
+  return (type)__res;								\
+}
+		
+#define _syscall6(type, name, atype, a, btype, b, ctype, c, dtype, d,           \
+                              etype, e, ftype, f)	                        \
+type name(atype a, btype b, ctype c, dtype d, etype e, ftype f)			\
+{										\
+  register long __res __asm__("er0");						\
+  __asm__ __volatile__ ("mov.l	er6,@-sp\n\t"					\
+                        "mov.l	%7, er6\n\t"					\
+                        "mov.l	%6, er5\n\t"					\
+			"mov.l	%5, er4\n\t"					\
+			"mov.l	%4, er3\n\t"					\
+			"mov.l	%3, er2\n\t"					\
+  			"mov.l	%2, er1\n\t"					\
+			"mov.l	%1, er0\n\t"					\
+  			"trapa	#0\n\t"						\
+  			"mov.l	@sp+,er6"					\
+			: "=r" (__res)						\
+			: "ir" (__NR_##name),					\
+			  "g" ((long)a),					\
+			  "g" ((long)b),					\
+			  "g" ((long)c),					\
+			  "g" ((long)d),					\
+			  "m" ((long)e),					\
+			  "m" ((long)e)						\
+			: "cc", "er1", "er2", "er3", "er4", "er5");		\
   if ((unsigned long)(__res) >= (unsigned long)(-125)) {		       	\
     errno = -__res;								\
     __res = -1;									\
