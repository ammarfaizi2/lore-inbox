Return-Path: <linux-kernel-owner+willy=40w.ods.org-S265375AbVBFIBY@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S265375AbVBFIBY (ORCPT <rfc822;willy@w.ods.org>);
	Sun, 6 Feb 2005 03:01:24 -0500
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S271861AbVBFIBX
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Sun, 6 Feb 2005 03:01:23 -0500
Received: from smtp808.mail.sc5.yahoo.com ([66.163.168.187]:12664 "HELO
	smtp808.mail.sc5.yahoo.com") by vger.kernel.org with SMTP
	id S271877AbVBFIAS (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
	Sun, 6 Feb 2005 03:00:18 -0500
From: Dmitry Torokhov <dtor_core@ameritech.net>
To: Greg KH <greg@kroah.com>
Subject: [PATCH] hotplug: automatically load proper serio drivers
Date: Sun, 6 Feb 2005 03:00:17 -0500
User-Agent: KMail/1.7.2
Cc: Linux Kernel <linux-kernel@vger.kernel.org>,
       Vojtech Pawlik <vojtech@suse.de>, Rusty Russell <rusty@rustcorp.com.au>
MIME-Version: 1.0
Content-Type: Multipart/Mixed;
  boundary="Boundary-00=_S6cBCWMXSviaiNk"
Message-Id: <200502060300.18274.dtor_core@ameritech.net>
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

--Boundary-00=_S6cBCWMXSviaiNk
Content-Type: text/plain;
  charset="us-ascii"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hi Greg,

I have added ID matching, MODULE_DEVICE_TABLE and hotplug to serio
subsystem; now that Vojtech pulled changes into his tree please consider
adding these 2 scripts to the hotplug package so drivers for new serio
ports could be loaded automatically.

Thanks!

-- 
Dmitry

--Boundary-00=_S6cBCWMXSviaiNk
Content-Type: application/x-shellscript;
  name="serio.agent"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
	filename="serio.agent"

#!/bin/sh
#
# serio-specific hotplug policy agent.
#
# This should handle 2.6.* serio port hotplugging.
# with a consistent framework for adding device and driver specific
# treatments.
#
# Kernel serio params are:
#
#	ACTION=%s [add or remove]
#	SERIO_TYPE=%02x
#	SERIO_PROTO=%02x
#	SERIO_ID=%02X
#	SERIO_EXTRA=%02x
#
# HISTORY:
#	23-Jan-2005	Initial version by Dmitry Torokhov <dtor@mail.ru>

cd /etc/hotplug
. ./hotplug.functions

# DEBUG=yes export DEBUG

# generated by modutils
MAP_CURRENT=$MODULE_DIR/modules.seriomap

# accumulates list of modules we may care about
DRIVERS=

if [ "$ACTION" = "" ]; then
    mesg Bad serio agent invocation
    exit 1
fi

#
# Each modules.seriomap format line corresponds to one entry in a
# MODULE_DEVICE_TABLE(serio,...) declaration in a kernel file.
#
# Think of it as a database column with up to three "match specs"
# to associate kernel modules with particular devices or classes
# of device.  The match specs provide a reasonably good filtering
# mechanism, but some driver probe() routines need to provide
# extra filtering.
#

serio_convert_vars ()
{
    serio_id_type=$((0x$SERIO_TYPE))
    serio_id_extra=$((0x$SERIO_EXTRA))
    serio_id_id=$((0x$SERIO_ID))
    serio_id_proto=$((0x$SERIO_PROTO))
}

SERIO_ANY=$((0xff))

#
# stdin is "modules.seriomap" syntax
# on return, all matching modules were added to $DRIVERS
#
serio_map_modules ()
{
    local module ignored

    # comment line lists (current) serio_device_id field names
    read ignored

    # look at each pci_device_id entry
    # collect one match in $DRIVERS
    while read module type extra id proto ignored
    do
	# comments are lines that start with "#" ...
	# be careful, they still get parsed by bash!
	case "$module" in
	\#*) continue ;;
	esac

	# convert the fields from hex to dec
	type=$(($type));
	extra=$(($extra))
	id=$(($id));
	proto=$(($proto))

	: check match for $module

	: type $type $serio_id_type
	if [ $type -ne $SERIO_ANY -a $type -ne $serio_id_type ]; then
	    continue
	fi
	: extra $extra $serio_id_extra
	if [ $extra -ne $SERIO_ANY -a $extra -ne $serio_id_extra ]; then
	    continue
	fi
	: id $id $serio_id_id
	if [ $id -ne $SERIO_ANY -a $id -ne $serio_id_id ]; then
	    continue
	fi
	: protocol $proto $pci_id_proto
	if [ $proto -ne $SERIO_ANY -a $proto -ne $serio_id_proto ]; then
	    continue
	fi

	DRIVERS="$module $DRIVERS"
	debug_mesg serio.agent $DRIVRES
	: drivers $DRIVERS
    done
}


#
# What to do with this PCI hotplug event?
#
case $ACTION in

add)
    serio_convert_vars

    LABEL="SERIO port 0x$SERIO_TYPE/0x$SERIO_PROTO/0x$SERIO_ID/0x$SERIO_EXTRA"

    if [ -r $MAP_CURRENT ]; then
    	load_drivers serio $MAP_CURRENT "$LABEL"
    fi

    if [ "$DRIVERS" = "" ]; then
	debug_mesg "... no modules for $LABEL"
	exit 2
    fi
    ;;

remove)
    : nothing so far

    ;;

*)
    debug_mesg SERIO $ACTION event not supported
    exit 1
    ;;

esac

--Boundary-00=_S6cBCWMXSviaiNk
Content-Type: application/x-shellscript;
  name="serio.rc"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
	filename="serio.rc"

#!/bin/sh
# vim: syntax=sh
#
# serio.rc	mostly to recover lost boot-time serio hotplug events
#

PATH=/sbin:/bin:/usr/sbin:/usr/bin

cd /etc/hotplug
. ./hotplug.functions

serio_boot_events ()
{
    # make sure serio.agent will run
    ACTION=add
    SERIO_TYPE=0
    SERIO_PROTO=0
    SERIO_ID=0
    SERIO_EXTRA=0
    export ACTION SERIO_TYPE SERIO_PROTO SERIO_ID SERIO_EXTRA

    if [ -d /sys/bus/serio/devices/ ]; then
	for SERIO_DEVICE in /sys/bus/serio/devices/*; do
	    SERIO_TYPE=`cat $SERIO_DEVICE/id_type`
	    SERIO_PROTO=`cat $SERIO_DEVICE/id_proto`
	    SERIO_ID=`cat $SERIO_DEVICE/id_id`
	    SERIO_EXTRA=`cat $SERIO_DEVICE/id_extra`
	    /sbin/hotplug serio
	done
    fi

    return 0
}

# See how we were called.
case "$1" in
  start)
	serio_boot_events
        ;;
  stop)
	# echo $"serio stop -- ignored"
        ;;
  status)
	echo $"SERIO Status for kernel: "  `uname -srm`
	echo ''

	DEV_COUNT=0
	if [ -d /sys/bus/serio/devices/ ]; then
	    DEV_COUNT=`ls /sys/bus/serio/devices/ | wc -l`
	fi
	DRV_COUNT=0
	if [ -d /sys/bus/serio/devices/ ]; then
	    DRV_COUNT=`ls /sys/bus/serio/drivers/ | wc -l`
	fi
	echo $"$DEV_COUNT ports registered; $DRV_COUNT drivers loaded"
	echo ''
	;;
  restart)
	# always invoke by absolute path, else PATH=$PATH:
	$0 stop && $0 start
	;;
  *)
        echo $"Usage: $0 {start|stop|status|restart}"
        exit 1
esac

--Boundary-00=_S6cBCWMXSviaiNk--
