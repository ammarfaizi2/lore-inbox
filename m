Return-Path: <linux-kernel-owner+willy=40w.ods.org@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S263554AbUDFAlA (ORCPT <rfc822;willy@w.ods.org>);
	Mon, 5 Apr 2004 20:41:00 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S263558AbUDFAk7
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Mon, 5 Apr 2004 20:40:59 -0400
Received: from tomts22.bellnexxia.net ([209.226.175.184]:38623 "EHLO
	tomts22-srv.bellnexxia.net") by vger.kernel.org with ESMTP
	id S263554AbUDFAk4 (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
	Mon, 5 Apr 2004 20:40:56 -0400
From: "Kevin B. Hendricks" <kevin.hendricks@sympatico.ca>
To: linux-kernel@vger.kernel.org
Subject: Re: Catching SIGSEGV with signal() in 2.6
Date: Mon, 5 Apr 2004 20:40:54 -0400
User-Agent: KMail/1.5
Cc: bero@arklinux.org
MIME-Version: 1.0
Content-Type: text/plain;
  charset="us-ascii"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline
Message-Id: <200404052040.54301.kevin.hendricks@sympatico.ca>
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

Hi,

Just in case this helps,  this is a simplified testcase of the OpenOffice.org 
code in question that always worked under 2.4 kernels on multiple 
architectures but fails on 2.6.X kernels on those same multiple platforms.

For some reason, the segfault generated by trying to write to address 0 can 
not be properly caught anymore (or at least it appears that way to me).

Hope this helps.

Kevin

[kbhend@base1 solar]$ cat testcase.c
#include <stdio.h>
#include <signal.h>
#include <setjmp.h>

typedef int (*TestFunc)( void* );
static jmp_buf check_env;
static int bSignal;

void SignalHdl( int sig )
{
  bSignal = 1;
  longjmp( check_env, sig );
}

int check( TestFunc func, void* p )
{
  int result;
  bSignal = 0;
  if ( !setjmp( check_env ) )
  {
        signal( SIGSEGV,        SignalHdl );
        signal( SIGBUS,         SignalHdl );
        result = func( p );
        signal( SIGSEGV,        SIG_DFL );
        signal( SIGBUS,         SIG_DFL );
  }
  if ( bSignal )
        return -1;
  else
        return 0;
}

int GetAtAddress( void* p )
{
  return *((char*)p);
}

int SetAtAddress( void* p )
{
  return *((char*)p)    = 0;
}

int CheckGetAccess( void* p )
{
  int b;
  b = -1 != check( (TestFunc)GetAtAddress, p );
  return b;
}

int CheckSetAccess( void* p )
{
  int b;
  b = -1 != check( (TestFunc)SetAtAddress, p );
  return b;
}

void InfoMemoryAccess( char* p )
{
  if ( CheckGetAccess( p ) )
    printf( "can read address %p\n", p );
  else
    printf( "can not read address %p\n", p );

  if ( CheckSetAccess( p ) )
    printf( "can write address %p\n", p );
  else
    printf( "can not write address %p\n", p );
}

int
main( int argc, char* argv[] )
{
  {
        char* p = NULL;
        InfoMemoryAccess( p );
        p = (char*)&p;
        InfoMemoryAccess( p );
  }
  exit( 0 );
}


