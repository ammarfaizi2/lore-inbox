Return-Path: <linux-kernel-owner+willy=40w.ods.org@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S263082AbTJJRte (ORCPT <rfc822;willy@w.ods.org>);
	Fri, 10 Oct 2003 13:49:34 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S263087AbTJJRte
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Fri, 10 Oct 2003 13:49:34 -0400
Received: from pub237.cambridge.redhat.com ([213.86.99.237]:62183 "EHLO
	warthog.warthog") by vger.kernel.org with ESMTP id S263082AbTJJRtc
	(ORCPT <rfc822;linux-kernel@vger.kernel.org>);
	Fri, 10 Oct 2003 13:49:32 -0400
From: David Howells <dhowells@redhat.com>
To: gcc@gcc.gnu.org
cc: linux-kernel@vger.kernel.org
Subject: using void variables as linker-script symbol refs
User-Agent: EMH/1.14.1 SEMI/1.14.4 (Hosorogi) FLIM/1.14.4
 (=?ISO-8859-4?Q?Kashiharajing=FE-mae?=) APEL/10.4 Emacs/21.2
 (i386-redhat-linux-gnu) MULE/5.0 (SAKAKI)
MIME-Version: 1.0 (generated by SEMI 1.14.4 - "Hosorogi")
Content-Type: text/plain; charset=US-ASCII
Date: Fri, 10 Oct 2003 18:49:28 +0100
Message-ID: <15494.1065808168@redhat.com>
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org


I've got a situation in which I'd like to use something like the following to
refer to constants defined in the linker script:

	extern const void _stext, _etext;

	#define __kernel_size ((unsigned long)&_etext - (unsigned long)&_stext)

Rather than:

	extern int _stext, _etext;

Or:

	extern int _stext[], _etext[];

Or:

	struct __not_really_a_struct;
	struct __not_really_a_struct _stext, _etext;

This has a couple of advantages:

 (1) You can't accidentally read/set such variables directly.

 (2) GCC doesn't assume they can be referenced by register-relative means, if
     the CPU has a special data pointer (such as a small-data pointer).

Any thoughts? Or is this just a straight forward shooting offence?

David
