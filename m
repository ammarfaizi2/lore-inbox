Return-Path: <linux-kernel-owner+willy=40w.ods.org@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S263611AbUDFEIs (ORCPT <rfc822;willy@w.ods.org>);
	Tue, 6 Apr 2004 00:08:48 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S263608AbUDFEIs
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Tue, 6 Apr 2004 00:08:48 -0400
Received: from cpe-24-221-190-179.ca.sprintbbd.net ([24.221.190.179]:48348
	"EHLO myware.akkadia.org") by vger.kernel.org with ESMTP
	id S263611AbUDFEIq (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
	Tue, 6 Apr 2004 00:08:46 -0400
Message-ID: <40722D42.90406@redhat.com>
Date: Mon, 05 Apr 2004 21:08:34 -0700
From: Ulrich Drepper <drepper@redhat.com>
Organization: Red Hat, Inc.
User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.7b) Gecko/20040405
X-Accept-Language: en-us, en
MIME-Version: 1.0
To: "Kevin B. Hendricks" <kevin.hendricks@sympatico.ca>
CC: linux-kernel@vger.kernel.org
Subject: Re: Catching SIGSEGV with signal() in 2.6
References: <200404052040.54301.kevin.hendricks@sympatico.ca> <4072101F.3010603@redhat.com> <200404052301.28021.kevin.hendricks@sympatico.ca>
In-Reply-To: <200404052301.28021.kevin.hendricks@sympatico.ca>
X-Enigmail-Version: 0.83.5.0
X-Enigmail-Supports: pgp-inline, pgp-mime
Content-Type: multipart/mixed;
 boundary="------------000903050605010004020908"
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

This is a multi-part message in MIME format.
--------------000903050605010004020908
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Kevin B. Hendricks wrote:

> So the code has been wrong since the beginning and we were just "lucky" it 
> worked in all pre-2.6 kernels?

The old code depended on undefined behavior.


> 1. before the next use of the handler we use signal again to properly set the 
> signal handler (and the set of masked signals).

Where do you set the signal mask?  That's the point.  You don't.  This
means jumping from the signal handler causes the signal to remain
blocked.  And then


~~~~
If any of the SIGFPE, SIGILL, SIGSEGV, or SIGBUS signals are generated
while they are blocked, the result is undefined, unless the signal was
generated by the kill() function, the sigqueue() function, or the
raise() function.
~~~~

(see pthread_sigmask in POSIX) comes into play.

The second SIGSEGV signal is created with the signal blocked and since
it's neither of the functions mentioned in the text below which creates
the signal anything can happen.  The old kernel queued the signal, the
new kernel terminates the process which is much better IMO.  Try the
attached program to see why.  Also note, the 2.4 behavior is
inconsistent.  If no handler is installed the process is terminated,
regardless of the signal being masked.

-- 
➧ Ulrich Drepper ➧ Red Hat, Inc. ➧ 444 Castro St ➧ Mountain View, CA ❖

--------------000903050605010004020908
Content-Type: text/x-csrc;
 name="minsig.c"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="minsig.c"

#include <signal.h>
int *p;
void
sh (int sig)
{
}
int
main(void)
{
  sigset_t s;
  sigemptyset (&s);
  sigaddset (&s, SIGSEGV);
  sigprocmask (SIG_BLOCK, &s, 0);
  signal(SIGSEGV, sh);
  return *p;
}

--------------000903050605010004020908--
