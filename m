Return-Path: <linux-kernel-owner+willy=40w.ods.org@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id <S261836AbSJZCs1>; Fri, 25 Oct 2002 22:48:27 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org
	id <S261839AbSJZCs0>; Fri, 25 Oct 2002 22:48:26 -0400
Received: from gateway.cinet.co.jp ([210.166.75.129]:11873 "EHLO
	precia.cinet.co.jp") by vger.kernel.org with ESMTP
	id <S261836AbSJZCsJ>; Fri, 25 Oct 2002 22:48:09 -0400
Date: Sat, 26 Oct 2002 11:54:17 +0900
From: Osamu Tomita <tomita@cinet.co.jp>
To: Takashi Iwai <tiwai@suse.de>
Cc: LKML <linux-kernel@vger.kernel.org>
Subject: Re: [PATCHSET 22/25] add support for PC-9800 architecture (sound alsa)
Message-ID: <20021026115417.A1424@precia.cinet.co.jp>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.2.5.1i
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

This is part 22/25 of patchset for add support NEC PC-9800 architecture,
against 2.5.44.

Thanks Alan cox and Takashi Iwai.
I rewite this patch.

Summary:
 ALSA sound driver related modules.
  - add MPU-401 UART driver for PC-9800.
  - add hardware specific initialization.

diffstat:
 include/sound/mpu401.h             |   13 
 include/sound/pc9801_118_magic.h   |  411 ++++++++++++++++++++++++
 include/sound/sound_pc9800.h       |   23 +
 sound/drivers/Config.in            |    4 
 sound/drivers/mpu401/Makefile      |    9 
 sound/drivers/mpu401/mpu401.c      |    8 
 sound/drivers/mpu401/mpu401_pc98.c |  615 +++++++++++++++++++++++++++++++++++++
 sound/drivers/opl3/opl3_lib.c      |   29 +
 sound/isa/cs423x/cs4231.c          |    7 
 sound/isa/cs423x/cs4231_lib.c      |   74 ++++
 sound/isa/cs423x/cs4236.c          |    7 
 11 files changed, 1196 insertions(+), 4 deletions(-)

patch:
diff -urN linux/sound/drivers/Config.in linux98/sound/drivers/Config.in
--- linux/sound/drivers/Config.in	Sat Oct 19 13:02:31 2002
+++ linux98/sound/drivers/Config.in	Sat Oct 26 10:11:20 2002
@@ -8,5 +8,9 @@
 dep_tristate 'MOTU MidiTimePiece AV multiport MIDI' CONFIG_SND_MTPAV $CONFIG_SND
 dep_tristate 'UART16550 - MIDI only driver' CONFIG_SND_SERIAL_U16550 $CONFIG_SND
 dep_tristate 'Generic MPU-401 UART driver' CONFIG_SND_MPU401 $CONFIG_SND
+dep_tristate 'NEC PC-9801 MPU-401 UART driver' CONFIG_SND_MPU98 $CONFIG_SND
+if [ "$CONFIG_SND_MPU98" != "n" ]; then
+   bool      '  Roland MPU-PC98II support' CONFIG_MPU_PC98II
+fi
 
 endmenu
diff -urN linux/sound/drivers/mpu401/Makefile linux98/sound/drivers/mpu401/Makefile
--- linux/sound/drivers/mpu401/Makefile	Sat Oct 19 13:02:35 2002
+++ linux98/sound/drivers/mpu401/Makefile	Fri Oct 25 00:39:14 2002
@@ -3,21 +3,28 @@
 # Copyright (c) 2001 by Jaroslav Kysela <perex@suse.cz>
 #
 
-export-objs  := mpu401_uart.o
+export-objs  := mpu401_uart.o mpu401_pc98.o
 
 snd-mpu401-objs := mpu401.o
 snd-mpu401-uart-objs := mpu401_uart.o
+snd-mpu401-pc98-objs := mpu401_pc98.o
 
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_MPU401) += snd-mpu401.o snd-mpu401-uart.o
+obj-$(CONFIG_SND_MPU98) += snd-mpu401.o snd-mpu401-pc98.o
 obj-$(CONFIG_SND_ALS100) += snd-mpu401-uart.o
 obj-$(CONFIG_SND_AZT2320) += snd-mpu401-uart.o
 obj-$(CONFIG_SND_DT019X) += snd-mpu401-uart.o
 obj-$(CONFIG_SND_ES18XX) += snd-mpu401-uart.o
 obj-$(CONFIG_SND_OPL3SA2) += snd-mpu401-uart.o
 obj-$(CONFIG_SND_AD1816A) += snd-mpu401-uart.o
+ifneq ($(CONFIG_PC9800),y)
 obj-$(CONFIG_SND_CS4231) += snd-mpu401-uart.o
 obj-$(CONFIG_SND_CS4232) += snd-mpu401-uart.o
+else
+obj-$(CONFIG_SND_CS4231) += snd-mpu401-pc98.o
+obj-$(CONFIG_SND_CS4232) += snd-mpu401-pc98.o
+endif
 obj-$(CONFIG_SND_CS4236) += snd-mpu401-uart.o
 obj-$(CONFIG_SND_ES1688) += snd-mpu401-uart.o
 obj-$(CONFIG_SND_GUSEXTREME) += snd-mpu401-uart.o
diff -urN linux/sound/drivers/mpu401/mpu401.c linux98/sound/drivers/mpu401/mpu401.c
--- linux/sound/drivers/mpu401/mpu401.c	Sat Oct 19 13:02:26 2002
+++ linux98/sound/drivers/mpu401/mpu401.c	Sat Oct 26 10:53:11 2002
@@ -76,7 +76,13 @@
 	card = snd_card_new(snd_index[dev], snd_id[dev], THIS_MODULE, 0);
 	if (card == NULL)
 		return -ENOMEM;
-	if (snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
+
+#if defined(CONFIG_SND_MPU98) || defined(CONFIG_SND_MPU98_MODULE)
+#define SND_MPU401_UART_NEW snd_mpu401_pc98_new
+#else
+#define SND_MPU401_UART_NEW snd_mpu401_uart_new
+#endif
+	if (SND_MPU401_UART_NEW(card, 0, MPU401_HW_MPU401,
 				snd_port[dev], 0,
 				snd_irq[dev], snd_irq[dev] >= 0 ? SA_INTERRUPT : 0, NULL) < 0) {
 		printk(KERN_ERR "MPU401 not detected at 0x%lx\n", snd_port[dev]);
diff -urN linux/sound/drivers/mpu401/mpu401_pc98.c linux98/sound/drivers/mpu401/mpu401_pc98.c
--- linux/sound/drivers/mpu401/mpu401_pc98.c	Thu Jan  1 09:00:00 1970
+++ linux98/sound/drivers/mpu401/mpu401_pc98.c	Fri Oct 25 01:03:41 2002
@@ -0,0 +1,615 @@
+/*
+ *  Copyright (c) Osamu Tomita <tomita@cinet.co.jp>
+ *    Based on mpu401_uart.c written by Jaroslav Kysela <perex@suse.cz>
+ *  Routines for control of MPU-401 in UART mode
+ *
+ *  MPU-401 supports UART mode which is not capable generate transmit
+ *  interrupts thus output is done via polling. Also, if irq < 0, then
+ *  input is done also via polling. Do not expect good performance.
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <sound/core.h>
+#include <sound/mpu401.h>
+
+MODULE_AUTHOR("Osamu Tomita <tomita@cinet.co.jp>");
+MODULE_DESCRIPTION("MPU-401 control routines for PC-9801");
+MODULE_LICENSE("GPL");
+
+/* I/O ports */
+
+#ifndef CONFIG_MPU_PC98II
+#define MPU401C_98(mpu) ((mpu)->port + 1)
+#else
+#define MPU401C_98(mpu) ((mpu)->port + 2)
+#endif
+
+static void snd_mpu401_pc98_input_read(mpu401_t * mpu);
+static void snd_mpu401_pc98_output_write(mpu401_t * mpu);
+
+/*
+
+ */
+
+#define snd_mpu401_98_input_avail(mpu)	(!(inb(MPU401C_98(mpu)) & 0x80))
+#define snd_mpu401_98_output_ready(mpu)	(!(inb(MPU401C_98(mpu)) & 0x40))
+
+#define MPU401_98_RESET		0xff
+#define MPU401_98_ENTER_UART	0x3f
+#define MPU401_98_ACK		0xfe
+
+static void snd_mpu401_pc98_clear_rx(mpu401_t *mpu)
+{
+	int timeout = 100000;
+	for (; timeout > 0 && snd_mpu401_98_input_avail(mpu); timeout--)
+		inb(MPU401D(mpu));
+#ifdef CONFIG_SND_DEBUG
+	if (timeout <= 0)
+		snd_printk("cmd: clear rx timeout (status = 0x%x)\n", inb(MPU401C_98(mpu)));
+#endif
+}
+
+static void _snd_mpu401_pc98_interrupt(mpu401_t *mpu)
+{
+	if (test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))
+		snd_mpu401_pc98_input_read(mpu);
+	else
+		snd_mpu401_pc98_clear_rx(mpu);
+	/* ok. for better Tx performance try do some output when input is done */
+	if (test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode))
+		snd_mpu401_pc98_output_write(mpu);
+}
+
+void snd_mpu401_pc98_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	mpu401_t *mpu = snd_magic_cast(mpu401_t, dev_id, return);
+	
+	if (mpu == NULL)
+		return;
+	_snd_mpu401_pc98_interrupt(mpu);
+}
+
+static void snd_mpu401_pc98_timer(unsigned long data)
+{
+	unsigned long flags;
+	mpu401_t *mpu = snd_magic_cast(mpu401_t, (void *)data, return);
+
+	spin_lock_irqsave(&mpu->timer_lock, flags);
+	/*mpu->mode |= MPU401_MODE_TIMER;*/
+	mpu->timer.expires = 1 + jiffies;
+	add_timer(&mpu->timer);
+	spin_unlock_irqrestore(&mpu->timer_lock, flags);
+	if (mpu->rmidi)
+		_snd_mpu401_pc98_interrupt(mpu);
+}
+
+static void snd_mpu401_pc98_add_timer (mpu401_t *mpu, int input)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave (&mpu->timer_lock, flags);
+	if (mpu->timer_invoked == 0) {
+		mpu->timer.data = (unsigned long)mpu;
+		mpu->timer.function = snd_mpu401_pc98_timer;
+		mpu->timer.expires = 1 + jiffies;
+		add_timer(&mpu->timer);
+	} 
+	mpu->timer_invoked |= input ? MPU401_MODE_INPUT_TIMER : MPU401_MODE_OUTPUT_TIMER;
+	spin_unlock_irqrestore (&mpu->timer_lock, flags);
+}
+
+static void snd_mpu401_pc98_remove_timer (mpu401_t *mpu, int input)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave (&mpu->timer_lock, flags);
+	if (mpu->timer_invoked) {
+		mpu->timer_invoked &= input ? ~MPU401_MODE_INPUT_TIMER : ~MPU401_MODE_OUTPUT_TIMER;
+		if (! mpu->timer_invoked)
+			del_timer(&mpu->timer);
+	}
+	spin_unlock_irqrestore (&mpu->timer_lock, flags);
+}
+
+/*
+
+ */
+
+static void snd_mpu401_pc98_cmd(mpu401_t * mpu, unsigned char cmd, int ack)
+{
+	unsigned long flags;
+	int timeout, ok;
+
+	spin_lock_irqsave(&mpu->input_lock, flags);
+	if (mpu->hardware != MPU401_HW_TRID4DWAVE) {
+		outb(0x00, MPU401D(mpu));
+		/*snd_mpu401_pc98_clear_rx(mpu);*/
+	}
+	/* ok. standard MPU-401 initialization */
+	if (mpu->hardware != MPU401_HW_SB) {
+		for (timeout = 1000; timeout > 0 && !snd_mpu401_98_output_ready(mpu); timeout--)
+			udelay(10);
+#ifdef CONFIG_SND_DEBUG
+		if (!timeout)
+			snd_printk("cmd: tx timeout (status = 0x%x)\n", inb(MPU401C_98(mpu)));
+#endif
+	}
+	outb(cmd, MPU401C_98(mpu));
+	if (ack) {
+		ok = 0;
+		timeout = 10000;
+		while (!ok && timeout-- > 0) {
+			if (snd_mpu401_98_input_avail(mpu)) {
+				if (inb(MPU401D(mpu)) == MPU401_98_ACK)
+					ok = 1;
+			}
+		}
+		if (!ok && inb(MPU401D(mpu)) == MPU401_98_ACK)
+			ok = 1;
+	} else {
+		ok = 1;
+	}
+	spin_unlock_irqrestore(&mpu->input_lock, flags);
+	if (! ok)
+		snd_printk("cmd: 0x%x failed at 0x%lx (status = 0x%x, data = 0x%x)\n", cmd, mpu->port, inb(MPU401C_98(mpu)), inb(MPU401D(mpu)));
+	// snd_printk("cmd: 0x%x at 0x%lx (status = 0x%x, data = 0x%x)\n", cmd, mpu->port, inb(MPU401C_98(mpu)), inb(MPU401D(mpu)));
+}
+
+/*
+ * input/output open/close - protected by open_mutex in rawmidi.c
+ */
+static int snd_mpu401_pc98_input_open(snd_rawmidi_substream_t * substream)
+{
+	mpu401_t *mpu;
+	int err;
+
+	mpu = snd_magic_cast(mpu401_t, substream->rmidi->private_data, return -ENXIO);
+	if (mpu->open_input && (err = mpu->open_input(mpu)) < 0)
+		return err;
+	if (! test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode)) {
+		snd_mpu401_pc98_cmd(mpu, MPU401_98_RESET, 1);
+		snd_mpu401_pc98_cmd(mpu, MPU401_98_ENTER_UART, 1);
+	}
+	mpu->substream_input = substream;
+	set_bit(MPU401_MODE_BIT_INPUT, &mpu->mode);
+	return 0;
+}
+
+static int snd_mpu401_pc98_output_open(snd_rawmidi_substream_t * substream)
+{
+	mpu401_t *mpu;
+	int err;
+
+	mpu = snd_magic_cast(mpu401_t, substream->rmidi->private_data, return -ENXIO);
+	if (mpu->open_output && (err = mpu->open_output(mpu)) < 0)
+		return err;
+	if (! test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode)) {
+		snd_mpu401_pc98_cmd(mpu, MPU401_98_RESET, 1);
+		snd_mpu401_pc98_cmd(mpu, MPU401_98_ENTER_UART, 1);
+	}
+	mpu->substream_output = substream;
+	set_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode);
+	return 0;
+}
+
+static int snd_mpu401_pc98_input_close(snd_rawmidi_substream_t * substream)
+{
+	mpu401_t *mpu;
+
+	mpu = snd_magic_cast(mpu401_t, substream->rmidi->private_data, return -ENXIO);
+	clear_bit(MPU401_MODE_BIT_INPUT, &mpu->mode);
+	mpu->substream_input = NULL;
+	if (! test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode))
+		snd_mpu401_pc98_cmd(mpu, MPU401_98_RESET, 0);
+	if (mpu->close_input)
+		mpu->close_input(mpu);
+	return 0;
+}
+
+static int snd_mpu401_pc98_output_close(snd_rawmidi_substream_t * substream)
+{
+	mpu401_t *mpu;
+
+	mpu = snd_magic_cast(mpu401_t, substream->rmidi->private_data, return -ENXIO);
+	clear_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode);
+	mpu->substream_output = NULL;
+	if (! test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))
+		snd_mpu401_pc98_cmd(mpu, MPU401_98_RESET, 0);
+	if (mpu->close_output)
+		mpu->close_output(mpu);
+	return 0;
+}
+
+/*
+ * trigger input
+ */
+static void snd_mpu401_pc98_input_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	mpu401_t *mpu;
+	int max = 64;
+
+	mpu = snd_magic_cast(mpu401_t, substream->rmidi->private_data, return);
+	spin_lock_irqsave(&mpu->input_lock, flags);
+	if (up) {
+		if (! test_and_set_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode)) {
+			/* flush FIFO */
+			while (max-- > 0)
+				inb(MPU401D(mpu));
+		}
+		if (mpu->irq < 0)
+			snd_mpu401_pc98_add_timer(mpu, 1);
+	} else {
+		if (mpu->irq < 0)
+			snd_mpu401_pc98_remove_timer(mpu, 1);
+		clear_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode);
+	}
+	spin_unlock_irqrestore(&mpu->input_lock, flags);
+	if (up)
+		snd_mpu401_pc98_input_read(mpu);
+}
+
+static void snd_mpu401_pc98_input_read(mpu401_t * mpu)
+{
+	int max = 128;
+	unsigned char byte;
+
+	/* prevent double enter via event callback */
+	if (test_and_set_bit(MPU401_MODE_BIT_RX_LOOP, &mpu->mode))
+		return;
+	spin_lock(&mpu->input_lock);
+	while (max-- > 0) {
+		if (snd_mpu401_98_input_avail(mpu)) {
+			byte = inb(MPU401D(mpu));
+			if (test_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode)) {
+				spin_unlock(&mpu->input_lock);
+				snd_rawmidi_receive(mpu->substream_input, &byte, 1);
+				spin_lock(&mpu->input_lock);
+			}
+		} else {
+			break; /* input not available */
+		}
+	}
+	spin_unlock(&mpu->input_lock);
+	clear_bit(MPU401_MODE_BIT_RX_LOOP, &mpu->mode);
+}
+
+/*
+ *  Tx FIFO sizes:
+ *    CS4237B			- 16 bytes
+ *    AudioDrive ES1688         - 12 bytes
+ *    S3 SonicVibes             -  8 bytes
+ *    SoundBlaster AWE 64       -  2 bytes (ugly hardware)
+ */
+
+static void snd_mpu401_pc98_output_write(mpu401_t * mpu)
+{
+	unsigned char byte;
+	int max = 256, timeout;
+
+	if (!test_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode))
+		return;
+	/* prevent double enter */
+	if (test_and_set_bit(MPU401_MODE_BIT_TX_LOOP, &mpu->mode))
+		return;
+	do {
+		spin_lock(&mpu->output_lock);
+		if (snd_rawmidi_transmit_peek(mpu->substream_output, &byte, 1) == 1) {
+			for (timeout = 100; timeout > 0; timeout--) {
+				if (snd_mpu401_98_output_ready(mpu)) {
+					outb(byte, MPU401D(mpu));
+					snd_rawmidi_transmit_ack(mpu->substream_output, 1);
+					break;
+				}
+			}
+		} else {
+			snd_mpu401_pc98_remove_timer (mpu, 0);
+			max = 1; /* no other data - leave the tx loop */
+		}
+		spin_unlock(&mpu->output_lock);
+	} while (--max > 0);
+	clear_bit(MPU401_MODE_BIT_TX_LOOP, &mpu->mode);
+}
+
+static void snd_mpu401_pc98_output_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	mpu401_t *mpu;
+
+	mpu = snd_magic_cast(mpu401_t, substream->rmidi->private_data, return);
+	spin_lock_irqsave(&mpu->output_lock, flags);
+	if (up) {
+		set_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode);
+		snd_mpu401_pc98_add_timer(mpu, 0);
+	} else {
+		snd_mpu401_pc98_remove_timer(mpu, 0);
+		clear_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode);
+	}
+	spin_unlock_irqrestore(&mpu->output_lock, flags);
+	if (up)
+		snd_mpu401_pc98_output_write(mpu);
+}
+
+/*
+
+ */
+
+static snd_rawmidi_ops_t snd_mpu401_pc98_output =
+{
+	.open =		snd_mpu401_pc98_output_open,
+	.close =	snd_mpu401_pc98_output_close,
+	.trigger =	snd_mpu401_pc98_output_trigger,
+};
+
+static snd_rawmidi_ops_t snd_mpu401_pc98_input =
+{
+	.open =		snd_mpu401_pc98_input_open,
+	.close =	snd_mpu401_pc98_input_close,
+	.trigger =	snd_mpu401_pc98_input_trigger,
+};
+
+static void snd_mpu401_pc98_free(snd_rawmidi_t *rmidi)
+{
+	mpu401_t *mpu = snd_magic_cast(mpu401_t, rmidi->private_data, return);
+	if (mpu->irq_flags && mpu->irq >= 0)
+		free_irq(mpu->irq, (void *) mpu);
+	if (mpu->res) {
+		release_resource(mpu->res);
+		kfree_nocheck(mpu->res);
+	}
+	snd_magic_kfree(mpu);
+}
+
+int snd_mpu401_pc98_new(snd_card_t * card, int device,
+			unsigned short hardware,
+			unsigned long port, int integrated,
+			int irq, int irq_flags,
+			snd_rawmidi_t ** rrawmidi)
+{
+	mpu401_t *mpu;
+	snd_rawmidi_t *rmidi;
+	int err;
+
+	if (rrawmidi)
+		*rrawmidi = NULL;
+	if ((err = snd_rawmidi_new(card, "MPU-401U", device, 1, 1, &rmidi)) < 0)
+		return err;
+	mpu = snd_magic_kcalloc(mpu401_t, 0, GFP_KERNEL);
+	if (mpu == NULL) {
+		snd_device_free(card, rmidi);
+		return -ENOMEM;
+	}
+	rmidi->private_data = mpu;
+	rmidi->private_free = snd_mpu401_pc98_free;
+	spin_lock_init(&mpu->input_lock);
+	spin_lock_init(&mpu->output_lock);
+	spin_lock_init(&mpu->timer_lock);
+	mpu->hardware = hardware;
+	if (!integrated) {
+#ifndef CONFIG_MPU_PC98II
+		if ((mpu->res = request_region(port, 2, "MPU401 UART")) == NULL)
+#else
+		if ((mpu->res = request_region(port, 4, "MPU401 UART")) == NULL)
+#endif
+		{
+			snd_device_free(card, rmidi);
+			return -EBUSY;
+		}
+	}
+	mpu->port = port;
+	if (irq >= 0 && irq_flags) {
+		if (request_irq(irq, snd_mpu401_pc98_interrupt, irq_flags, "MPU401 UART", (void *) mpu)) {
+			snd_printk("unable to grab IRQ %d\n", irq);
+			snd_device_free(card, rmidi);
+			return -EBUSY;
+		}
+		mpu->irq = irq;
+		mpu->irq_flags = irq_flags;
+	}
+
+	{
+		#include <sound/pc9801_118_magic.h>
+		#define outp118(reg,data) outb((reg),0x148e);outb((data),0x148f)
+		#define WAIT118 outb(0x00,0x5f)
+		int	mpu_intr, count;
+#ifdef OOKUBO_ORIGINAL
+		int	err = 0;
+#endif /* OOKUBO_ORIGINAL */
+
+		switch (irq)
+		{
+			case 3:
+				mpu_intr = 3;
+				break;
+			case 5:
+				mpu_intr = 2;
+				break;
+			case 6:
+				mpu_intr = 1;
+				break;
+			case 10:
+				mpu_intr = 0;
+				break;
+			default:
+				snd_printk("Bad IRQ %d\n", irq);
+				snd_device_free(card, rmidi);
+				return -EBUSY;
+		}
+
+		outp118(0x21, mpu_intr);
+		WAIT118;
+		outb(0x00, 0x148e);
+		if (inb(0x148f) & 0x08)
+		{
+			snd_printk("No MIDI daughter board found\n");
+			goto skip118;
+		}
+
+		outp118(0x20, 0x00);
+		outp118(0x05, 0x04);
+		for (count = 0; count < 35000; count ++)
+			WAIT118;
+		outb(0x05, 0x148e);
+		for (count = 0; count < 65000; count ++)
+			if (inb(0x148f) == 0x04)
+				goto set_mode_118;
+		snd_printk("MIDI daughter board initalize failed at stage1\n\n");
+		snd_device_free(card, rmidi);
+		return -EBUSY;
+
+		set_mode_118:
+		outp118(0x05, 0x0c);
+		outb(0xaa, 0x485);
+		outb(0x99, 0x485);
+		outb(0x2a, 0x485);
+		for (count = 0; count < sizeof(Data0485_99); count ++)
+		{
+			outb(Data0485_99[count], 0x485);
+			WAIT118;
+		}
+
+		outb(0x00, 0x486);
+		outb(0xaa, 0x485);
+		outb(0x9e, 0x485);
+		outb(0x2a, 0x485);
+		for (count = 0; count < sizeof(Data0485_9E); count ++)
+			if (inb(0x485) != Data0485_9E[count])
+			{
+#ifdef OOKUBO_ORIGINAL
+				err = 1;
+#endif /* OOKUBO_ORIGINAL */
+				break;
+			}
+		outb(0x00, 0x486);
+		for (count = 0; count < 2000; count ++)
+			WAIT118;
+#ifdef OOKUBO_ORIGINAL
+		if (!err)
+		{
+			outb(0xaa, 0x485);
+			outb(0x36, 0x485);
+			outb(0x28, 0x485);
+			for (count = 0; count < sizeof(Data0485_36); count ++)
+				outb(Data0485_36[count], 0x485);
+			outb(0x00, 0x486);
+			for (count = 0; count < 1500; count ++)
+				WAIT118;
+			outp118(0x05, inb(0x148f) | 0x08);
+			outb(0xff, 0x148c);
+			outp118(0x05, inb(0x148f) & 0xf7);
+			for (count = 0; count < 1500; count ++)
+				WAIT118;
+		}
+#endif /* OOKUBO_ORIGINAL */
+
+		outb(0xaa, 0x485);
+		outb(0xa9, 0x485);
+		outb(0x21, 0x485);
+		for (count = 0; count < sizeof(Data0485_A9); count ++)
+		{
+			outb(Data0485_A9[count], 0x485);
+			WAIT118;
+		}
+
+		outb(0x00, 0x486);
+		outb(0xaa, 0x485);
+		outb(0x0c, 0x485);
+		outb(0x20, 0x485);
+		for (count = 0; count < sizeof(Data0485_0C); count ++)
+		{
+			outb(Data0485_0C[count], 0x485);
+			WAIT118;
+		}
+
+		outb(0x00, 0x486);
+		outb(0xaa, 0x485);
+		outb(0x66, 0x485);
+		outb(0x20, 0x485);
+		for (count = 0; count < sizeof(Data0485_66); count ++)
+		{
+			outb(Data0485_66[count], 0x485);
+			WAIT118;
+		}
+
+		outb(0x00, 0x486);
+		outb(0xaa, 0x485);
+		outb(0x60, 0x485);
+		outb(0x20, 0x485);
+		for (count = 0; count < sizeof(Data0485_60); count ++)
+		{
+			outb(Data0485_60[count], 0x485);
+			WAIT118;
+		}
+
+		outb(0x00, 0x486);
+		outp118(0x05, 0x04);
+		outp118(0x05, 0x00);
+		for (count = 0; count < 35000; count ++)
+			WAIT118;
+		outb(0x05, 0x148e);
+		for (count = 0; count < 65000; count ++)
+			if (inb(0x148f) == 0x00)
+				goto end_mode_118;
+		snd_printk("MIDI daughter board initalize failed at stage2\n\n");
+		snd_device_free(card, rmidi);
+		return -EBUSY;
+
+		end_mode_118:
+		outb(0x3f, 0x148d);
+		snd_printk("MIDI daughter board initalized\n");
+		skip118:
+	}
+
+	strcpy(rmidi->name, "MPU-401 (UART)");
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_mpu401_pc98_output);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_mpu401_pc98_input);
+	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |
+	                     SNDRV_RAWMIDI_INFO_INPUT |
+	                     SNDRV_RAWMIDI_INFO_DUPLEX;
+	mpu->rmidi = rmidi;
+	if (rrawmidi)
+		*rrawmidi = rmidi;
+	return 0;
+}
+
+EXPORT_SYMBOL(snd_mpu401_pc98_interrupt);
+EXPORT_SYMBOL(snd_mpu401_pc98_new);
+
+/*
+ *  INIT part
+ */
+
+static int __init alsa_mpu401_pc98_init(void)
+{
+	return 0;
+}
+
+static void __exit alsa_mpu401_pc98_exit(void)
+{
+}
+
+module_init(alsa_mpu401_pc98_init)
+module_exit(alsa_mpu401_pc98_exit)
diff -urN linux/sound/drivers/opl3/opl3_lib.c linux98/sound/drivers/opl3/opl3_lib.c
--- linux/sound/drivers/opl3/opl3_lib.c	Tue Oct  8 10:56:24 2002
+++ linux98/sound/drivers/opl3/opl3_lib.c	Tue Oct  8 11:01:42 2002
@@ -31,6 +31,10 @@
 #include <linux/ioport.h>
 #include <sound/minors.h>
 
+#ifdef CONFIG_PC9800
+#include <sound/sound_pc9800.h>
+#endif
+
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Hannu Savolainen 1993-1996, Rob Hooft");
 MODULE_DESCRIPTION("Routines for control of AdLib FM cards (OPL2/OPL3/OPL4 chips)");
 MODULE_LICENSE("GPL");
@@ -438,6 +442,31 @@
 			opl3->command = &snd_opl3_command;
 		}
 	}
+
+#ifdef CONFIG_PC9800
+	/* ??? */
+	outb(0x00, opl3->l_port + 6);
+	inb(opl3->l_port + 7);
+	/* Enable OPL-3 Function */
+	outb(inb(PC9800_SOUND_IO_ID) | 0x03, PC9800_SOUND_IO_ID);
+
+	/* Initialize? */
+	opl3->command(opl3, OPL3_RIGHT | 0x05, 0x05);
+	opl3->command(opl3, OPL3_RIGHT | 0x08, 0x04);
+	opl3->command(opl3, OPL3_RIGHT | 0x08, 0x00);
+	opl3->command(opl3, OPL3_LEFT | 0xf7, 0x00);
+	opl3->command(opl3, OPL3_LEFT | 0x04, 0x60);
+	opl3->command(opl3, OPL3_LEFT | 0x04, 0x80);
+	inb(opl3->l_port);
+
+	opl3->command(opl3, OPL3_LEFT | 0x02, 0xff);
+	opl3->command(opl3, OPL3_LEFT | 0x04, 0x21);
+	inb(opl3->l_port);
+
+	opl3->command(opl3, OPL3_LEFT | 0x04, 0x60);
+	opl3->command(opl3, OPL3_LEFT | 0x04, 0x80);
+#endif
+
 	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TEST, OPL3_ENABLE_WAVE_SELECT);
 	opl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION, 0x00);	/* Melodic mode */
 
diff -urN linux/sound/isa/cs423x/cs4231.c linux98/sound/isa/cs423x/cs4231.c
--- linux/sound/isa/cs423x/cs4231.c	Sat Oct 19 13:01:07 2002
+++ linux98/sound/isa/cs423x/cs4231.c	Fri Oct 25 01:23:56 2002
@@ -128,8 +128,13 @@
 		return err;
 	}
 
+#ifndef CONFIG_PC9800
+#define SND_MPU401_UART_NEW snd_mpu401_uart_new
+#else
+#define SND_MPU401_UART_NEW snd_mpu401_pc98_new
+#endif
 	if (snd_mpu_irq[dev] >= 0 && snd_mpu_irq[dev] != SNDRV_AUTO_IRQ) {
-		if (snd_mpu401_uart_new(card, 0, MPU401_HW_CS4232,
+		if (SND_MPU401_UART_NEW(card, 0, MPU401_HW_CS4232,
 					snd_mpu_port[dev], 0,
 					snd_mpu_irq[dev], SA_INTERRUPT,
 					NULL) < 0)
diff -urN linux/sound/isa/cs423x/cs4231_lib.c linux98/sound/isa/cs423x/cs4231_lib.c
--- linux/sound/isa/cs423x/cs4231_lib.c	Tue Oct  8 10:56:24 2002
+++ linux98/sound/isa/cs423x/cs4231_lib.c	Tue Oct  8 11:01:42 2002
@@ -37,6 +37,10 @@
 #include <sound/cs4231.h>
 #include <sound/pcm_params.h>
 
+#ifdef CONFIG_PC9800
+#include <sound/sound_pc9800.h>
+#endif
+
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
 MODULE_DESCRIPTION("Routines for control of CS4231(A)/CS4232/InterWave & compatible chips");
 MODULE_LICENSE("GPL");
@@ -1405,6 +1409,10 @@
 	};
 	cs4231_t *chip;
 	int err;
+#ifdef CONFIG_PC9800
+	int intr_bits, intr_bits2, dma_bits;
+	unsigned long flags;
+#endif
 
 	*rchip = NULL;
 	chip = snd_magic_kcalloc(cs4231_t, 0, GFP_KERNEL);
@@ -1436,6 +1444,13 @@
 		return -EBUSY;
 	}
 	chip->dma1 = dma1;
+#ifdef CONFIG_PC9800
+	if (dma2 > 3 || dma2 == 2) {
+		snd_cs4231_free(chip);
+		snd_printk("Bad DMA %d\n", dma2);
+		return -EBUSY;
+	}
+#endif
 	if (!(hwshare & CS4231_HWSHARE_DMA2) && dma1 != dma2 && dma2 >= 0 && request_dma(dma2, "CS4231 - 2")) {
 		snd_cs4231_free(chip);
 		return -EBUSY;
@@ -1456,6 +1471,65 @@
         memcpy(&chip->image, &snd_cs4231_original_image, sizeof(snd_cs4231_original_image));
 
 	/* global setup */
+
+#ifdef CONFIG_PC9800
+	switch (irq) {
+		case 3:
+			intr_bits = 0x08;
+			intr_bits2 = 0x03;
+			break;
+		case 5:
+			intr_bits = 0x10;
+			intr_bits2 = 0x08;
+			break;
+		case 10:
+			intr_bits = 0x18;
+			intr_bits2 = 0x02;
+			break;
+		case 12:
+			intr_bits = 0x20;
+			intr_bits2 = 0x00;
+			break;
+		default:
+			snd_cs4231_free(chip);
+			snd_printk("Bad IRQ %d\n", irq);
+			return -EBUSY;
+	}
+
+	switch (dma1) {
+		case 0:
+			dma_bits = 0x01;
+			break;
+		case 1:
+			dma_bits = 0x02;
+			break;
+		case 3:
+			dma_bits = 0x03;
+			break;
+		default:
+			snd_cs4231_free(chip);
+			snd_printk("Bad DMA %d\n", dma1);
+			return -EBUSY;
+	}
+
+	if (chip->single_dma != 1)
+		intr_bits |= 0x04;
+
+	if (PC9800_SOUND_ID() == PC9800_SOUND_ID_118) {
+		/* Set up CanBe control registers. */
+		snd_printk("Setting up CanBe Sound System\n");
+		spin_lock_irqsave(&chip->reg_lock, flags);
+		outb(inb(PC9800_SOUND_IO_ID) | 0x03, PC9800_SOUND_IO_ID);
+		outb(0x01, 0x0f4a);
+		outb(intr_bits2, 0x0f4b);
+	} else {
+		spin_lock_irqsave(&chip->reg_lock, flags);
+	}
+
+	outb(intr_bits | dma_bits, 0xf40);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+#endif /* CONFIG_PC9800 */
+
 	if (snd_cs4231_probe(chip) < 0) {
 		snd_cs4231_free(chip);
 		return -ENODEV;
diff -urN linux/sound/isa/cs423x/cs4236.c linux98/sound/isa/cs423x/cs4236.c
--- linux/sound/isa/cs423x/cs4236.c	Sat Oct 19 13:01:13 2002
+++ linux98/sound/isa/cs423x/cs4236.c	Fri Oct 25 01:24:03 2002
@@ -522,8 +522,13 @@
 		}
 	}
 
+#ifndef CONFIG_PC9800
+#define SND_MPU401_UART_NEW snd_mpu401_uart_new
+#else
+#define SND_MPU401_UART_NEW snd_mpu401_pc98_new
+#endif
 	if (snd_mpu_port[dev] != SNDRV_AUTO_PORT) {
-		if (snd_mpu401_uart_new(card, 0, MPU401_HW_CS4232,
+		if (SND_MPU401_UART_NEW(card, 0, MPU401_HW_CS4232,
 					snd_mpu_port[dev], 0,
 					snd_mpu_irq[dev],
 					snd_mpu_irq[dev] >= 0 ? SA_INTERRUPT : 0, NULL) < 0)
diff -urN linux/include/sound/mpu401.h linux98/include/sound/mpu401.h
--- linux/include/sound/mpu401.h	Sat Oct 19 13:02:29 2002
+++ linux98/include/sound/mpu401.h	Fri Oct 25 01:27:19 2002
@@ -96,6 +96,7 @@
 
  */
 
+#ifndef CONFIG_PC9800
 void snd_mpu401_uart_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 
 int snd_mpu401_uart_new(snd_card_t * card,
@@ -106,5 +107,17 @@
 			int irq,
 			int irq_flags,
 			snd_rawmidi_t ** rrawmidi);
+#else /* CONFIG_PC9800 */
+void snd_mpu401_pc98_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+
+int snd_mpu401_pc98_new(snd_card_t * card,
+			int device,
+			unsigned short hardware,
+			unsigned long port,
+			int integrated,
+			int irq,
+			int irq_flags,
+			snd_rawmidi_t ** rrawmidi);
+#endif /* !CONFIG_PC9800 */
 
 #endif /* __SOUND_MPU401_H */
diff -urN linux/include/sound/pc9801_118_magic.h linux98/include/sound/pc9801_118_magic.h
--- linux/include/sound/pc9801_118_magic.h	Thu Jan  1 09:00:00 1970
+++ linux98/include/sound/pc9801_118_magic.h	Sat Apr 27 13:01:29 2002
@@ -0,0 +1,411 @@
+		static unsigned char	Data0485_A9[] = {
+		0x12, 0x03, 0x90, 0xc2, 0x2a, 0x75, 0x1e, 0x20,
+		0xe4, 0x12, 0x2b, 0x9b, 0x22, 0xa9, 0x16, 0x77,
+		0x33, 0xe9, 0x04, 0x54, 0x03, 0x44, 0xa8, 0xf5,
+		0x16, 0xc2, 0x2f, 0x22, 0xa9, 0x16, 0x77, 0x42,
+		0xe9, 0x04, 0x54, 0x03, 0x44, 0xa8, 0xf9, 0x77,
+		0xf8, 0x04, 0x54, 0x03, 0x44, 0xa8, 0xf5, 0x16,
+		0xc2, 0x2f, 0x22, 0x90, 0x25, 0x9f, 0x30, 0x04,
+		0x05, 0xc2, 0x04, 0x12, 0x1f, 0x62, 0x30, 0x00,
+		0x05, 0xc2, 0x00, 0x12, 0x15, 0xe6, 0x30, 0x01,
+		0x05, 0xc2, 0x01, 0x12, 0x29, 0xaf, 0x30, 0x02,
+		0x05, 0xc2, 0x02, 0x12, 0x29, 0xaf, 0x30, 0x05,
+		0x05, 0xc2, 0x05, 0x12, 0x16, 0x65, 0x30, 0x06,
+		0x08, 0xc2, 0x06, 0x12, 0x16, 0xb1, 0x12, 0x29,
+		0xaf, 0x30, 0x07, 0x08, 0xc2, 0x07, 0x12, 0x16,
+		0xe9, 0x12, 0x29, 0xaf, 0x22, 0x20, 0x97, 0x09,
+		0x53, 0xa8, 0xfb, 0x12, 0x04, 0x2c, 0x43, 0xa8,
+		0x04, 0x22, 0x71, 0xb8, 0x71, 0xb8, 0x71, 0xb8,
+		0x22, 0x20, 0x4b, 0x04, 0x75, 0x4e, 0x02, 0x22,
+		0xe5, 0x35, 0x24, 0xff, 0xf5, 0x35, 0xe5, 0x36,
+		0x34, 0xff, 0xf5, 0x36, 0x75, 0x4e, 0x02, 0x22,
+		0x10, 0x19, 0x02, 0x80, 0x08, 0x78, 0x00, 0xe2,
+		0x78, 0x07, 0xf2, 0x61, 0x9b, 0x78, 0x11, 0xe2,
+		0xc0, 0x01, 0xc0, 0xf0, 0xc0, 0xd0, 0xc0, 0x02,
+		0x71, 0x14, 0xe5, 0x30, 0xb4, 0x01, 0x02, 0x61,
+		0x93, 0x43, 0x08, 0x40, 0x12, 0x2a, 0x53, 0x61,
+		0x93, 0x79, 0x03, 0xe3, 0xa2, 0xe2, 0x92, 0x26,
+		0xa2, 0xe3, 0x92, 0x27, 0x22, 0xad, 0x2b, 0xbd,
+		0x04, 0x07, 0xf5, 0x72, 0x78, 0x27, 0x02, 0x11,
+		0x76, 0x02, 0x11, 0x30, 0x00, 0x00, 0x00, 0x12,
+		0x28, 0xba, 0x79, 0x01, 0xe3, 0x75, 0x21, 0x3f,
+		0x75, 0x49, 0x11, 0x75, 0x4c, 0x11, 0x31, 0xdc,
+		0x75, 0x1a, 0x80, 0x51, 0x72, 0x75, 0x81, 0xe3,
+		0x12, 0x25, 0xc9, 0x43, 0xa8, 0x01, 0x00, 0x53,
+		0xa8, 0xfe, 0x10, 0x50, 0x02, 0x80, 0x03, 0x12,
+		0x1a, 0x8d, 0xd1, 0x28, 0x12, 0x03, 0xd9, 0xd1,
+		0xf2, 0x12, 0x2d, 0xf0, 0xb0, 0x11, 0x92, 0xe0,
+		0xa2, 0x2a, 0xa0, 0xb5, 0x82, 0xe0, 0x50, 0x03,
+		0x79, 0x0f, 0xe3, 0x71, 0xca, 0x51, 0x1e, 0x91,
+		0xe4, 0x53, 0xa8, 0xfb, 0x10, 0x10, 0x02, 0x80,
+		0x26, 0xc2, 0x8e, 0xd2, 0xab, 0xa2, 0x1c, 0x40,
+		0x13, 0xa2, 0x1d, 0x50, 0x0a, 0x43, 0x08, 0x40,
+		0x12, 0x1a, 0x01, 0xd1, 0xd7, 0x80, 0x0b, 0x12,
+		0x26, 0x04, 0x61, 0x08, 0x43, 0x08, 0x40, 0x12,
+		0x1a, 0x01, 0xd2, 0x1f, 0x12, 0x17, 0x7f, 0x43,
+		0xa8, 0x04, 0x51, 0x1e, 0x91, 0xe4, 0x12, 0x13,
+		0x34, 0x80, 0x98, 0xa2, 0x17, 0x72, 0x16, 0x72,
+		0x15, 0x72, 0x2d, 0x50, 0x06, 0xfa, 0x12, 0x13,
+		0x66, 0x80, 0x25, 0xc2, 0x13, 0x30, 0x28, 0x05,
+		0x12, 0x02, 0xbe, 0x80, 0x1b, 0xb4, 0x10, 0x12,
+		0x78, 0x00, 0xf2, 0xe5, 0x30, 0xb4, 0x01, 0x06,
+		0x12, 0x03, 0x90, 0xd2, 0x19, 0x22, 0x12, 0x00,
+		0xdd, 0x22, 0x75, 0x30, 0x00, 0x12, 0x00, 0xa1,
+		0x22, 0x00, 0x00, 0x75, 0x1e, 0x00, 0x74, 0x0c,
+		0x12, 0x2b, 0x9b, 0x74, 0x40, 0x79, 0x05, 0xf3,
+		0x74, 0x49, 0x12, 0x2b, 0x9b, 0x74, 0x04, 0x79,
+		0x05, 0xf3, 0x75, 0x15, 0x04, 0x74, 0x10, 0x12,
+		0x2b, 0x9b, 0x74, 0x00, 0x79, 0x05, 0xf3, 0x74,
+		0x17, 0x12, 0x2b, 0x9b, 0x74, 0x00, 0x79, 0x05,
+		0xf3, 0x74, 0x1a, 0x12, 0x2b, 0x9b, 0x74, 0x00,
+		0x79, 0x05, 0xf3, 0x74, 0x0a, 0x12, 0x2b, 0x9b,
+		0x74, 0x20, 0x79, 0x05, 0xf3, 0x79, 0xe0, 0x77,
+		0x20, 0x22, 0xd0, 0x02, 0xd0, 0xd0, 0xd0, 0xf0,
+		0xd0, 0x01, 0xe5, 0x5f, 0xd0, 0xa8, 0x22, 0x00,
+		0x00, 0x90, 0x25, 0x9f, 0x75, 0x26, 0xff, 0x75,
+		0x27, 0xff, 0x75, 0x28, 0x03, 0x75, 0x13, 0xff,
+		0x75, 0x1f, 0x00, 0x75, 0x14, 0xff, 0x22, 0x79,
+		0x06, 0xe5, 0x29, 0x60, 0x0b, 0xe3, 0x30, 0xe1,
+		0xf8, 0xe5, 0x4f, 0x64, 0x80, 0x79, 0x07, 0xf3,
+		0x22, 0x10, 0x4c, 0x01, 0x22, 0x30, 0x4b, 0x0a,
+		0xc2, 0x4b, 0xe5, 0x4d, 0x64, 0x80, 0xf5, 0x4f,
+		0x80, 0x1d, 0xe5, 0x15, 0xa2, 0xe0, 0x82, 0xe6,
+		0x40, 0x02, 0x80, 0x35, 0x30, 0x4a, 0x04, 0xb1,
+		0xe6, 0x80, 0x0c, 0x30, 0x49, 0x04, 0x51, 0x2b,
+		0x80, 0x05, 0x30, 0x48, 0x24, 0x91, 0x7e, 0x79,
+		0x06, 0xe3, 0x30, 0xe0, 0x1a, 0x79, 0x06, 0xf3,
+		0xe5, 0x4e, 0x24, 0xff, 0x50, 0x04, 0xf5, 0x4e,
+		0x80, 0x0d, 0x79, 0x0f, 0xf3, 0x20, 0x2a, 0x07,
+		0x12, 0x2b, 0x32, 0x75, 0x29, 0x00, 0x22, 0x91,
+		0x1b, 0x22, 0x79, 0x0f, 0xe3, 0xc0, 0xa8, 0x75,
+		0xa8, 0x00, 0x30, 0x2b, 0x03, 0xd0, 0xa8, 0x22,
+		0x79, 0x0e, 0xf3, 0xd0, 0xa8, 0x22, 0x8a, 0xf0,
+		0xe5, 0x50, 0x10, 0xf3, 0x10, 0x23, 0x23, 0x23,
+		0x25, 0xf0, 0x12, 0x2c, 0xb8, 0xa2, 0xe7, 0x92,
+		0xe4, 0xc2, 0xe7, 0x80, 0x08, 0x23, 0x23, 0x23,
+		0x25, 0xf0, 0x12, 0x2c, 0x19, 0x25, 0x4f, 0x20,
+		0xd2, 0x04, 0xf5, 0x4f, 0x80, 0x0a, 0x40, 0x05,
+		0x75, 0x4f, 0x7f, 0x80, 0x03, 0x75, 0x4f, 0xff,
+		0xea, 0x12, 0x2c, 0x3c, 0x25, 0x50, 0x20, 0xe7,
+		0x05, 0xb4, 0x03, 0x07, 0x80, 0x0c, 0x75, 0x50,
+		0x00, 0x80, 0x09, 0x40, 0x05, 0x75, 0x50, 0x03,
+		0x80, 0x02, 0xf5, 0x50, 0x22, 0xe5, 0x4d, 0xc4,
+		0x54, 0x0c, 0x03, 0x03, 0xfa, 0x91, 0xa9, 0x71,
+		0xb8, 0xe5, 0x4d, 0xc4, 0x54, 0x03, 0xfa, 0x91,
+		0xa9, 0x71, 0xb8, 0xe5, 0x4d, 0x54, 0x0c, 0x03,
+		0x03, 0xfa, 0x91, 0xa9, 0x71, 0xb8, 0xe5, 0x4d,
+		0x54, 0x03, 0xfa, 0x91, 0xa9, 0x71, 0xb8, 0x22,
+		0x8a, 0xf0, 0xe5, 0x50, 0x23, 0x23, 0x25, 0xf0,
+		0x12, 0x2b, 0xf6, 0x25, 0x4f, 0x20, 0xd2, 0x04,
+		0xf5, 0x4f, 0x80, 0x0a, 0x40, 0x05, 0x75, 0x4f,
+		0x7f, 0x80, 0x03, 0x75, 0x4f, 0xff, 0xea, 0x12,
+		0x2c, 0x40, 0x25, 0x50, 0x20, 0xe7, 0x05, 0xb4,
+		0x05, 0x07, 0x80, 0x0c, 0x75, 0x50, 0x00, 0x80,
+		0x09, 0x40, 0x05, 0x75, 0x50, 0x05, 0x80, 0x02,
+		0xf5, 0x50, 0x22, 0x30, 0x26, 0x03, 0x12, 0x1e,
+		0xf5, 0x30, 0x27, 0x03, 0x12, 0x1f, 0x37, 0x30,
+		0x25, 0x09, 0x12, 0x1f, 0x4e, 0x30, 0x23, 0x03,
+		0x12, 0x1f, 0x1e, 0x10, 0x22, 0x02, 0x80, 0x0a,
+		0xe5, 0x3b, 0xb4, 0xff, 0x02, 0xc2, 0x20, 0x12,
+		0x1e, 0x79, 0x22, 0x78, 0x11, 0xe2, 0x20, 0xe0,
+		0x07, 0xc0, 0x01, 0x12, 0x28, 0xba, 0xd0, 0x01,
+		0x78, 0x00, 0xf2, 0x61, 0x9b, 0x12, 0x2b, 0x32,
+		0x12, 0x17, 0x7f, 0x78, 0x00, 0xf2, 0xaa, 0x35,
+		0xab, 0x36, 0xea, 0x24, 0xff, 0xfa, 0xeb, 0x34,
+		0xff, 0xfb, 0x50, 0x03, 0xd2, 0x10, 0x22, 0x75,
+		0x37, 0x01, 0x75, 0x38, 0x00, 0x75, 0x39, 0x00,
+		0x12, 0x04, 0x04, 0xd2, 0x8e, 0x22, 0xa8, 0x2b,
+		0xb8, 0x00, 0x02, 0x80, 0x03, 0x02, 0x11, 0xbd,
+		0xf5, 0x74, 0x78, 0x2a, 0x12, 0x11, 0xec, 0xe5,
+		0x74, 0x78, 0x29, 0x12, 0x11, 0xec, 0x22, 0xfa,
+		0xe5, 0x2b, 0x60, 0x01, 0x22, 0xea, 0x78, 0x2b,
+		0xf5, 0x75, 0x12, 0x11, 0xec, 0x22, 0x74, 0x10,
+		0x12, 0x2b, 0x9b, 0x74, 0x20, 0x78, 0x05, 0xf2,
+		0x74, 0x09, 0x12, 0x17, 0x75, 0xe5, 0x15, 0x44,
+		0x80, 0x79, 0x05, 0xf3, 0xf5, 0x15, 0x12, 0x17,
+		0x7f, 0x22, 0x12, 0x03, 0x84, 0x79, 0x0f, 0xe3,
+		0x78, 0x00, 0xf2, 0x12, 0x2b, 0x28, 0xe5, 0x81,
+		0x24, 0xfc, 0xf5, 0x81, 0x61, 0x93, 0xd2, 0x07,
+		0x78, 0x11, 0xe2, 0x44, 0x11, 0xf5, 0x4c, 0xc2,
+		0x0f, 0x12, 0x29, 0xa3, 0x61, 0x93, 0x02, 0x1b,
+		0x77, 0x00, 0xe1, 0x81, 0xe1, 0x9a, 0xd2, 0x2c,
+		0xa1, 0x0c, 0x20, 0x20, 0x02, 0xd2, 0x26, 0x02,
+		0x1e, 0x35, 0x02, 0x1e, 0x61, 0x02, 0x1d, 0x8f,
+		0xc2, 0x8e, 0x75, 0xa8, 0x9e, 0x22, 0x41, 0x49,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x02, 0x29, 0x91, 0x00, 0x00, 0x00, 0xa1, 0xbb,
+		0xa1, 0xc3, 0x02, 0x1e, 0x6b, 0xe5, 0x4d, 0xc4,
+		0x54, 0x0f, 0xfa, 0x91, 0x2f, 0x71, 0xb8, 0xe5,
+		0x4d, 0x54, 0x0f, 0xfa, 0x91, 0x2f, 0x71, 0xb8,
+		0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa1, 0xc6,
+		0x02, 0x1d, 0x8f, 0xc2, 0x8e, 0xd2, 0xab, 0xc2,
+		0x10, 0x79, 0x0f, 0xf3, 0x22, 0x00, 0x02, 0x2a,
+		0x84, 0x00, 0xe1, 0xbc, 0xe1, 0xc8, 0x02, 0x1e,
+		0x27, 0x00, 0x78, 0x00, 0xf2, 0x78, 0x0b, 0xe2,
+		0xf4, 0xf5, 0x4d, 0xd2, 0x4c, 0x61, 0x9b, 0x30,
+		0xb5, 0x02, 0xc2, 0x11, 0x22, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x79, 0xbd, 0xf1, 0x3d, 0x83,
+		0x22, 0xdd, 0xbd, 0xbd, 0xbd, 0x61, 0xbd, 0x8d,
+		0x7a, 0xbd, 0xbd, 0xbd, 0xbd, 0x30, 0xbd, 0xbd,
+		0xbd, 0x55, 0xbd, 0xbd, 0xbd, 0x52, 0xbd, 0xb6,
+		0xb6, 0xbd, 0xbd, 0xbd, 0xbd, 0x00, 0xbd, 0xbd,
+		0xbd, 0xe8, 0xda, 0xbd, 0xbd, 0xcf, 0xb9, 0xbd,
+		0xc4, 0xf1, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd,
+		0xbd, 0x7b, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd,
+		0xbd, 0x70, 0x6a, 0x57, 0x47, 0x34, 0xbd, 0xbd,
+		0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0x29, 0xbd,
+		0xbd, 0xbd, 0xb6, 0xb6, 0xbd, 0xbd, 0xbd, 0xbd,
+		0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0x2e, 0x25,
+		0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xfe, 0xf5,
+		0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0x19, 0xbd,
+		0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0x21, 0x8f,
+		0x09, 0xbd, 0xf9, 0x86, 0xbd, 0xbd, 0xbd, 0xd7,
+		0xbd, 0xa9, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0x9b,
+		0xd1, 0x9d, 0xbd, 0xae, 0xbd, 0xbd, 0xbd, 0xcb,
+		0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd,
+		0xb6, 0xa5, 0xbd, 0xc5, 0xbd, 0xbd, 0xbd, 0xc3,
+		0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0x74, 0x10,
+		0x12, 0x2b, 0x9b, 0xe4, 0x78, 0x05, 0xf2, 0x74,
+		0x09, 0x12, 0x17, 0x75, 0xe5, 0x15, 0x54, 0x7f,
+		0x79, 0x05, 0xf3, 0xf5, 0x15, 0x12, 0x17, 0x7f,
+		0x22, 0x30, 0x51, 0x01, 0x22, 0x53, 0xa8, 0xfb,
+		0x12, 0x2d, 0xf0, 0x50, 0x22, 0x79, 0x03, 0xe3,
+		0x20, 0xe4, 0x1c, 0xaa, 0x35, 0xab, 0x36, 0xea,
+		0x24, 0xf0, 0xfa, 0xeb, 0x34, 0xff, 0xfb, 0x50,
+		0x0e, 0x10, 0x1f, 0x02, 0x80, 0x09, 0x20, 0x2a,
+		0x03, 0x12, 0x2b, 0x32, 0x12, 0x2d, 0xd6, 0x43,
+		0xa8, 0x04, 0x22, 0xa2, 0x1c, 0x72, 0x1d, 0x40,
+		0x07, 0x53, 0x08, 0xbf, 0x78, 0x00, 0xf2, 0x22,
+		0xb1, 0x1e, 0x22, 0x00, 0x79, 0x02, 0x12, 0x27,
+		0x3d, 0x02, 0x2d, 0x37, 0x14, 0x54, 0xf0, 0x60,
+		0x21, 0xe5, 0xf0, 0x24, 0xb6, 0xe5, 0xf0, 0x50,
+		0x16, 0x24, 0x8b, 0x50, 0x15, 0xe5, 0xf0, 0x24,
+		0x56, 0xe5, 0xf0, 0x50, 0x08, 0x24, 0x2f, 0x50,
+		0x09, 0xe5, 0xf0, 0x24, 0xd9, 0x24, 0xd5, 0x24,
+		0xf0, 0x22, 0x15, 0x81, 0x15, 0x81, 0xe9, 0x22,
+		0x78, 0x13, 0x74, 0x00, 0xf2, 0x75, 0x2e, 0x01,
+		0xd2, 0x6a, 0xc2, 0x69, 0xc2, 0x68, 0xc2, 0x6c,
+		0x90, 0x25, 0x9f, 0x75, 0xb8, 0x07, 0x41, 0xa4,
+		0xc0, 0x01, 0xc0, 0xf0, 0xc0, 0xd0, 0xc0, 0x02,
+		0xe5, 0x3d, 0x54, 0x7d, 0x03, 0x10, 0xe5, 0x05,
+		0x90, 0x28, 0x4b, 0x80, 0x03, 0x90, 0x2b, 0x7c,
+		0x73, 0xe5, 0x3d, 0x30, 0xe5, 0x07, 0x74, 0xfd,
+		0x78, 0x00, 0xf2, 0x61, 0x9b, 0x90, 0x1a, 0x97,
+		0x74, 0xb6, 0xc0, 0xe0, 0x74, 0x27, 0xc0, 0xe0,
+		0xc0, 0xa8, 0x02, 0x1b, 0xab, 0x90, 0x25, 0x9f,
+		0xd0, 0xa8, 0x22, 0x90, 0x27, 0xb6, 0xc0, 0x82,
+		0xc0, 0x83, 0xc0, 0xa8, 0x02, 0x1d, 0xa6, 0x90,
+		0x27, 0xb6, 0xc0, 0x82, 0xc0, 0x83, 0xc0, 0xa8,
+		0x02, 0x1e, 0x0a, 0xea, 0x24, 0xf0, 0xfa, 0xeb,
+		0x34, 0xff, 0xfb, 0x50, 0x2e, 0x20, 0x0b, 0x05,
+		0x85, 0x44, 0xe0, 0x80, 0x03, 0x75, 0xe0, 0x00,
+		0x30, 0xe1, 0x20, 0xe5, 0x35, 0x24, 0xff, 0xf5,
+		0x35, 0xe5, 0x36, 0x34, 0xff, 0xf5, 0x36, 0xc3,
+		0xe5, 0x36, 0x13, 0xf5, 0x36, 0xe5, 0x35, 0x13,
+		0xf5, 0x35, 0x75, 0x3a, 0x10, 0x12, 0x1a, 0x77,
+		0x02, 0x18, 0x77, 0x75, 0x3a, 0x00, 0x12, 0x1a,
+		0x77, 0x02, 0x18, 0x1b, 0x20, 0x4b, 0x04, 0x75,
+		0x4e, 0x03, 0x22, 0xe5, 0x35, 0x24, 0xff, 0xf5,
+		0x35, 0xe5, 0x36, 0x34, 0xff, 0xf5, 0x36, 0x75,
+		0x4e, 0x03, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x02, 0x2c,
+		0x70, 0xd2, 0x00, 0x78, 0x11, 0xe2, 0x44, 0x11,
+		0xf5, 0x3f, 0xc2, 0x08, 0x12, 0x29, 0xa3, 0x02,
+		0x23, 0x93, 0x21, 0x62, 0x61, 0x40, 0x01, 0x3a,
+		0x01, 0x73, 0x21, 0x76, 0x61, 0xa8, 0x21, 0x39,
+		0x21, 0x4a, 0x02, 0x2a, 0x7b, 0x79, 0x06, 0xf3,
+		0xc0, 0xd0, 0x12, 0x03, 0xd9, 0x78, 0x00, 0xf2,
+		0xd0, 0xd0, 0x22, 0x00, 0x00, 0x00, 0x00, 0x02,
+		0x2c, 0xb4, 0x78, 0x11, 0xe2, 0x44, 0x11, 0x54,
+		0x0f, 0xf8, 0xc4, 0x48, 0xd2, 0x05, 0xf5, 0x48,
+		0xc2, 0x0d, 0x31, 0xa3, 0x02, 0x23, 0x93, 0x20,
+		0x4b, 0x04, 0x75, 0x4e, 0x01, 0x22, 0xe5, 0x35,
+		0x24, 0xff, 0xf5, 0x35, 0xe5, 0x36, 0x34, 0xff,
+		0xf5, 0x36, 0x75, 0x4e, 0x01, 0x22, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x79, 0xd0, 0x77, 0x1b, 0x79, 0xd1, 0x77, 0x18,
+		0x79, 0xd2, 0x77, 0x77, 0x79, 0xd3, 0x77, 0x18,
+		0x22, 0x75, 0x29, 0x00, 0x75, 0x25, 0x00, 0x75,
+		0x34, 0x03, 0x75, 0x22, 0x00, 0x75, 0x23, 0x05,
+		0x75, 0x4f, 0x00, 0x75, 0x50, 0x00, 0x75, 0x30,
+		0x00, 0x79, 0xdc, 0x77, 0x03, 0xc2, 0x8e, 0x75,
+		0x17, 0xa8, 0x75, 0x16, 0xa8, 0x74, 0xaa, 0x79,
+		0x01, 0xf3, 0x79, 0xd7, 0x77, 0x74, 0x79, 0xd8,
+		0x77, 0xff, 0x79, 0xd9, 0x77, 0x07, 0x79, 0xda,
+		0x77, 0x00, 0x12, 0x25, 0x6f, 0x43, 0x08, 0x40,
+		0x71, 0x32, 0x79, 0x0e, 0xe3, 0x10, 0x51, 0x1c,
+		0x74, 0x06, 0x71, 0x9b, 0xe5, 0x11, 0x44, 0x80,
+		0x79, 0x05, 0xf3, 0xf5, 0x11, 0x74, 0x07, 0x71,
+		0x9b, 0xe5, 0x12, 0x44, 0x80, 0x79, 0x05, 0xf3,
+		0xf5, 0x12, 0x80, 0x18, 0x53, 0x27, 0xa0, 0x53,
+		0x28, 0x01, 0x75, 0x20, 0xf7, 0x12, 0x23, 0x4c,
+		0x75, 0x11, 0x80, 0x75, 0x12, 0x80, 0x12, 0x1f,
+		0xc0, 0x12, 0x21, 0xdc, 0x79, 0x06, 0xf3, 0x22,
+		0xd2, 0x02, 0x78, 0x11, 0xe2, 0x44, 0x11, 0xf5,
+		0x43, 0xc2, 0x0a, 0x12, 0x29, 0xa3, 0x02, 0x23,
+		0x93, 0x78, 0x11, 0xe2, 0x44, 0x11, 0xf5, 0x44,
+		0xc2, 0x0b, 0x12, 0x29, 0xa3, 0x02, 0x23, 0x93,
+		0x78, 0x00, 0xe2, 0x90, 0x25, 0x9f, 0x02, 0x23,
+		0x93, 0x78, 0x11, 0xe2, 0x75, 0x20, 0xf7, 0x75,
+		0x21, 0x3f, 0x75, 0x49, 0x11, 0x75, 0x4c, 0x11,
+		0x31, 0xa3, 0x02, 0x23, 0x93, 0x78, 0x11, 0xe2,
+		0x44, 0x11, 0x54, 0x0f, 0xf8, 0xc4, 0x48, 0xf8,
+		0xe5, 0x49, 0x45, 0x3f, 0x58, 0xf5, 0x49, 0xd2,
+		0x06, 0xc2, 0x0e, 0x31, 0xa3, 0x02, 0x23, 0x93,
+		0xc0, 0x01, 0x20, 0x2a, 0x04, 0x71, 0x32, 0xc2,
+		0x11, 0x11, 0x5e, 0xc2, 0x1f, 0xd0, 0x01, 0x02,
+		0x23, 0x9b, 0x12, 0x21, 0xdc, 0x78, 0x00, 0xf2,
+		0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0xda,
+		0xe7, 0x70, 0x2b, 0x20, 0x0a, 0x05, 0x85, 0x43,
+		0xe0, 0x80, 0x03, 0x75, 0xe0, 0x00, 0x30, 0xe1,
+		0x1d, 0x20, 0xe2, 0x1f, 0x74, 0xe0, 0xca, 0x74,
+		0x00, 0x71, 0x9b, 0xca, 0x79, 0x05, 0xf3, 0xf5,
+		0x09, 0xca, 0x74, 0x01, 0x71, 0x9b, 0xca, 0x79,
+		0x05, 0xf3, 0xf5, 0x0a, 0x80, 0x43, 0x12, 0x15,
+		0x3e, 0x80, 0x3e, 0xe5, 0x0b, 0xb4, 0x17, 0x02,
+		0x80, 0x0b, 0x50, 0x09, 0x74, 0x17, 0xc3, 0x95,
+		0x0b, 0x44, 0x60, 0x80, 0x02, 0x74, 0x60, 0xca,
+		0x74, 0x00, 0x71, 0x9b, 0xca, 0x79, 0x05, 0xf3,
+		0xf5, 0x09, 0xe5, 0x0c, 0xb4, 0x17, 0x02, 0x80,
+		0x0b, 0x50, 0x09, 0x74, 0x17, 0xc3, 0x95, 0x0c,
+		0x44, 0x60, 0x80, 0x02, 0x74, 0x60, 0xca, 0x74,
+		0x01, 0x71, 0x9b, 0xca, 0x79, 0x05, 0xf3, 0xf5,
+		0x0a, 0x22, 0xd2, 0x04, 0x78, 0x11, 0xe2, 0x44,
+		0x11, 0xf5, 0x46, 0xc2, 0x0c, 0x31, 0xa3, 0x02,
+		0x23, 0x93, 0xd2, 0x05, 0x78, 0x11, 0xe2, 0x44,
+		0x11, 0xf5, 0x48, 0xc2, 0x0d, 0x31, 0xa3, 0x02,
+		0x23, 0x93, 0xd2, 0x06, 0x78, 0x11, 0xe2, 0x44,
+		0x11, 0xf5, 0x49, 0xc2, 0x0e, 0x31, 0xa3, 0x02,
+		0x23, 0x93, 0x30, 0x1c, 0x21, 0x20, 0x4d, 0x1e,
+		0xe5, 0x29, 0x60, 0x1a, 0xc2, 0x1c, 0x12, 0x19,
+		0xec, 0x12, 0x13, 0xcf, 0xd2, 0x4d, 0x12, 0x17,
+		0x7f, 0x78, 0x00, 0xf2, 0x79, 0x06, 0xf3, 0x43,
+		0xa8, 0x04, 0x12, 0x24, 0x1b, 0x22, 0x12, 0x27,
+		0x24, 0x22, 0x78, 0x00, 0xe2, 0x90, 0x25, 0x9f,
+		0x02, 0x23, 0x93, 0x78, 0x00, 0xe2, 0xa2, 0xe7,
+		0x72, 0xe3, 0x92, 0xe7, 0x02, 0x1d, 0x85, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x79, 0x04, 0xe3, 0x54, 0x80, 0x70, 0xf9, 0x22,
+		0xe5, 0x29, 0x79, 0xde, 0xf7, 0x75, 0x29, 0x00,
+		0x70, 0x12, 0xe5, 0x15, 0x79, 0xdd, 0xf7, 0x12,
+		0x2d, 0xf0, 0x40, 0x08, 0x20, 0x1c, 0x07, 0x20,
+		0x1d, 0x04, 0x80, 0x02, 0x71, 0x32, 0x30, 0xb5,
+		0x0c, 0x79, 0x06, 0xf3, 0x20, 0x2a, 0x06, 0x79,
+		0xdd, 0xe7, 0x54, 0xfc, 0xf7, 0xd2, 0x2b, 0x12,
+		0x25, 0x6f, 0x22, 0x00, 0x00, 0x00, 0x00, 0xe5,
+		0x15, 0xa2, 0xe0, 0xb0, 0xe6, 0x40, 0x31, 0xa2,
+		0xe1, 0xb0, 0xe7, 0x40, 0x38, 0x10, 0x2b, 0x02,
+		0x80, 0x26, 0x79, 0xde, 0xe7, 0x70, 0x0b, 0x79,
+		0xdd, 0xe7, 0x20, 0xe0, 0x12, 0x20, 0xe1, 0x28,
+		0x80, 0x16, 0xf5, 0x29, 0x30, 0x4d, 0x11, 0x20,
+		0x4c, 0x0e, 0x12, 0x24, 0x1b, 0x80, 0x09, 0x43,
+		0x08, 0x40, 0x12, 0x13, 0xcf, 0x12, 0x17, 0x7f,
+		0xe5, 0x13, 0x20, 0xe4, 0x05, 0x12, 0x18, 0x1b,
+		0x80, 0x03, 0x12, 0x18, 0x77, 0xc2, 0x2b, 0x22,
+		0x12, 0x26, 0xd7, 0x12, 0x13, 0xb7, 0x22, 0x78,
+		0x04, 0x79, 0x00, 0xd9, 0xfe, 0xd8, 0xfa, 0x22,
+		0x00, 0x74, 0x09, 0x71, 0x9b, 0xe5, 0x15, 0x54,
+		0xfc, 0x79, 0x05, 0xf3, 0xf5, 0x15, 0x22, 0x78,
+		0x11, 0xe2, 0x44, 0x11, 0x54, 0x0f, 0xf8, 0xc4,
+		0x48, 0xf5, 0x46, 0xc2, 0x0c, 0xd2, 0x04, 0x31,
+		0xa3, 0x02, 0x23, 0x93, 0x12, 0x26, 0xd7, 0x12,
+		0x00, 0xb7, 0x22, 0x00, 0x79, 0x06, 0xf3, 0x74,
+		0x0a, 0x71, 0x9b, 0x79, 0xe0, 0xe7, 0x44, 0x02,
+		0xf7, 0x79, 0x05, 0xf3, 0x22, 0x74, 0x0a, 0x71,
+		0x9b, 0x79, 0xe0, 0xe7, 0x54, 0xfd, 0xf7, 0x79,
+		0x05, 0xf3, 0x22, 0x21, 0x59, 0x41, 0x23, 0x21,
+		0x59, 0x41, 0x33, 0x41, 0x43, 0x21, 0x59, 0x21,
+		0x59, 0x02, 0x25, 0x9f, 0x00, 0x74, 0x0d, 0x71,
+		0x9b, 0x74, 0x4d, 0x79, 0x05, 0xf3, 0xd2, 0x52,
+		0x22, 0x00, 0x53, 0x08, 0x40, 0x45, 0x08, 0x45,
+		0x1e, 0x79, 0x04, 0xf3, 0xf5, 0x08, 0x22, 0xd2,
+		0x01, 0x78, 0x11, 0xe2, 0x44, 0x11, 0xf5, 0x42,
+		0xc2, 0x09, 0x31, 0xa3, 0x02, 0x23, 0x93, 0x00,
+		0x00, 0x00, 0x00, 0x71, 0x6e, 0x74, 0x09, 0x12,
+		0x17, 0x75, 0xe5, 0x15, 0x44, 0x40, 0x79, 0x05,
+		0xf3, 0xf5, 0x15, 0x75, 0x3a, 0x00, 0x12, 0x1a,
+		0x77, 0x02, 0x18, 0x1b, 0xf5, 0x38, 0xe5, 0x37,
+		0x24, 0x01, 0xf5, 0x37, 0xe5, 0x38, 0x34, 0x00,
+		0xf5, 0x38, 0x40, 0x05, 0x75, 0x39, 0x00, 0x80,
+		0x03, 0x75, 0x39, 0x01, 0x12, 0x04, 0x04, 0xd2,
+		0x8e, 0x02, 0x03, 0x8d, 0x00, 0xb4, 0x0d, 0x03,
+		0x74, 0x14, 0x22, 0x04, 0x83, 0x22, 0x00, 0x02,
+		0xff, 0x01, 0x00, 0x05, 0xfe, 0xff, 0x00, 0x0a,
+		0xfc, 0xfe, 0x00, 0xc0, 0xf8, 0xfc, 0x00, 0x28,
+		0xf0, 0xf8, 0x00, 0x30, 0xe0, 0xd0, 0x01, 0x88,
+		0x04, 0x83, 0x22, 0x00, 0xff, 0xfe, 0xfd, 0xfc,
+		0xfc, 0xfb, 0xfa, 0xfe, 0xfd, 0xfb, 0xf9, 0xf7,
+		0xf7, 0xf5, 0xf3, 0xfc, 0xfa, 0xf6, 0xf2, 0xee,
+		0xee, 0xea, 0xe6, 0xf8, 0xf4, 0xec, 0xe4, 0xdc,
+		0xd4, 0xcc, 0xc4, 0x24, 0x21, 0x83, 0x22, 0x04,
+		0x83, 0x22, 0xff, 0x01, 0xff, 0x01, 0x00, 0x00,
+		0x00, 0x02, 0x22, 0x32, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
+		0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0xff,
+		0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x83,
+		0x22, 0x8a, 0x01, 0x20, 0x01, 0x0b, 0xea, 0xf3,
+		0xf9, 0x8b, 0x7e, 0x6b, 0xd5, 0x01, 0x00, 0x01,
+		0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x01, 0x3a, 0x01, 0x38, 0x01, 0x4b, 0x01,
+		0x49, 0x01, 0x5c, 0x01, 0x5a, 0x01, 0x08, 0x08,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x01, 0x15, 0x24, 0x48, 0x83, 0x22, 0x04,
+		0x83, 0x22, 0x00, 0x01, 0x02, 0x03, 0x04, 0x06,
+		0x07, 0x08, 0x00, 0x03, 0x05, 0x07, 0x09, 0x0d,
+		0x0f, 0x81, 0x00, 0x06, 0x0a, 0x0e, 0x82, 0x8a,
+		0x8e, 0x22, 0x00, 0x0c, 0x84, 0x8c, 0x24, 0x2c,
+		0xa4, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0xaa, 0x35, 0xab, 0x36,
+		0x02, 0x27, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
+		0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x25,
+		0x03, 0x03, 0x2b, 0x03, 0x00, 0x03, 0x00, 0x03,
+		0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
+		0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+		0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x83, 0x22,
+		0x00, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x02,
+		0x02, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x02,
+		0x2b, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x02,
+		0x02, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x02,
+		0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x02, 0x01,
+		0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+		0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+		0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+		0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x02,
+		0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x02,
+		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x02,
+		0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x00, 0x02,
+		0x21, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x00,
+		0x02, 0x02, 0x01, 0x02, 0x02, 0x02, 0x00, 0x02,
+		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x21,
+		0x01, 0x02, 0x21, 0x02, 0x02, 0x02, 0x00, 0x02,
+		0x02, 0x02, 0x02, 0x02, 0x02, 0x20, 0xb5, 0x05,
+		0x79, 0x0f, 0xf3, 0xc2, 0x11, 0x22, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe5,
+		0x15, 0xa2, 0xe0, 0xb0, 0xe6, 0x50, 0x01, 0x22,
+		0xa2, 0xe1, 0xb0, 0xe7, 0x22, 0x02, 0x00};
+		static unsigned char	Data0485_0C[] = {
+		0x02, 0x27, 0x69};
+		static unsigned char	Data0485_66[] = {
+		0x02, 0x25, 0x47, 0x02, 0x25, 0x60};
+		static unsigned char	Data0485_60[] = {
+		0x02, 0x22, 0x7e};
+		static unsigned char	Data0485_99[] = {
+		0xc2, 0x53, 0x02, 0x12, 0x86};
+		static unsigned char	Data0485_9E[] = {
+		0x70, 0xf9, 0x22};
+#ifdef OOKUBO_ORIGINAL
+		static unsigned char	Data0485_36[] = {
+		0x78, 0x00, 0xf2, 0xc2, 0x53, 0x74, 0x86, 0xc0,
+		0xe0, 0x74, 0x12, 0xc0,	0xe0, 0x32};
+#endif /* OOKUBO_ORIGINAL */
diff -urN linux/include/sound/sound_pc9800.h linux98/include/sound/sound_pc9800.h
--- linux/include/sound/sound_pc9800.h	Thu Jan  1 09:00:00 1970
+++ linux98/include/sound/sound_pc9800.h	Fri Aug 17 22:33:07 2001
@@ -0,0 +1,23 @@
+#ifndef _SOUND_PC9800_H_
+#define _SOUND_PC9800_H_
+
+#include <asm/io.h>
+
+#define PC9800_SOUND_IO_ID	0xa460
+
+/* Sound Functions ID. */
+#define PC9800_SOUND_ID()	((inb(PC9800_SOUND_IO_ID) >> 4) & 0x0f)
+
+#define PC9800_SOUND_ID_DO	0x0	/* PC-98DO+ Internal */
+#define PC9800_SOUND_ID_GS	0x1	/* PC-98GS Internal */
+#define PC9800_SOUND_ID_73	0x2	/* PC-9801-73 (base 0x18x) */
+#define PC9800_SOUND_ID_73A	0x3	/* PC-9801-73/76 (base 0x28x) */
+#define PC9800_SOUND_ID_86	0x4	/* PC-9801-86 and compatible (base 0x18x) */
+#define PC9800_SOUND_ID_86A	0x5	/* PC-9801-86 (base 0x28x) */
+#define PC9800_SOUND_ID_NF	0x6	/* PC-9821Nf/Np Internal */
+#define PC9800_SOUND_ID_XMATE	0x7	/* X-Mate Internal and compatible */
+#define PC9800_SOUND_ID_118	0x8	/* PC-9801-118 and compatible(CanBe Internal, etc.) */
+
+#define PC9800_SOUND_ID_UNKNOWN	0xf	/* Unknown (No Sound System or PC-9801-26) */
+
+#endif
