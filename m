Return-Path: <linux-kernel-owner+willy=40w.ods.org@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id <S313477AbSG2I2g>; Mon, 29 Jul 2002 04:28:36 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org
	id <S313508AbSG2I2g>; Mon, 29 Jul 2002 04:28:36 -0400
Received: from dell-paw-3.cambridge.redhat.com ([195.224.55.237]:4854 "EHLO
	executor.cambridge.redhat.com") by vger.kernel.org with ESMTP
	id <S313477AbSG2I2f>; Mon, 29 Jul 2002 04:28:35 -0400
To: Roman Zippel <zippel@linux-m68k.org>
Cc: David Howells <dhowells@redhat.com>, Christoph Hellwig <hch@infradead.org>,
       "Adam J. Richter" <adam@yggdrasil.com>, linux-kernel@vger.kernel.org
Subject: Re: Patch: linux-2.5.29 __downgrade_write() for CONFIG_RWSEM_GENERIC_SPINLOCK 
In-Reply-To: Message from Roman Zippel <zippel@linux-m68k.org> 
   of "Mon, 29 Jul 2002 10:01:26 +0200." <Pine.LNX.4.44.0207290958010.28515-100000@serv> 
User-Agent: EMH/1.14.1 SEMI/1.14.3 (Ushinoya) FLIM/1.14.3
 (=?ISO-8859-4?Q?Unebigory=F2mae?=) APEL/10.3 Emacs/21.2
 (i386-redhat-linux-gnu) MULE/5.0 (SAKAKI)
MIME-Version: 1.0 (generated by SEMI 1.14.3 - "Ushinoya")
Content-Type: text/plain; charset=US-ASCII
Date: Mon, 29 Jul 2002 09:31:55 +0100
Message-ID: <20869.1027931515@warthog.cambridge.redhat.com>
From: David Howells <dhowells@redhat.com>
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org


Roman Zippel <zippel@linux-m68k.org> wrote:
> Did you look at the code? gcc should be able to optimize that itself.

Maybe... gcc should also optimise my version to the same extent, I think (the
result of one of the additional tests is known at compile time, and the other
one is the same as the next test down). What I'm unsure about is how gcc will
handle the variable being stored in memory not marked volatile and then
retrieved again; whether it'll actually issue a read, or just assume it's got
it cached.

However, I've changed it to your suggestion, and I'm compiling it to have a
look. I've attached the changed C file for your perusal.

David


static inline struct rw_semaphore *__rwsem_do_wake(struct rw_semaphore *sem)
{
	struct rwsem_waiter *waiter;
	int woken;

	rwsemtrace(sem,"Entering __rwsem_do_wake");

	waiter = list_entry(sem->wait_list.next,struct rwsem_waiter,list);

	/* if we are allowed to wake writers try to grant a single write lock if there's a
	 * writer at the front of the queue
	 * - we leave the 'waiting count' incremented to signify potential contention
	 */
	if (waiter->flags & RWSEM_WAITING_FOR_WRITE) {
		if (!sem->activity) {
			sem->activity = -1;
			list_del(&waiter->list);
			waiter->flags = 0;
			wake_up_process(waiter->task);
		}
		goto out;
	}

	/* grant an infinite number of read locks to the readers at the front of the queue */
	woken = 0;
	while (waiter->flags&RWSEM_WAITING_FOR_READ) {
		struct list_head *next = waiter->list.next;

		list_del(&waiter->list);
		waiter->flags = 0;
		wake_up_process(waiter->task);
		woken++;
		if (list_empty(&sem->wait_list))
			break;
		waiter = list_entry(next,struct rwsem_waiter,list);
	}

	sem->activity += woken;

 out:
	rwsemtrace(sem,"Leaving __rwsem_do_wake");
	return sem;
}
