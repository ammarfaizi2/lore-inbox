Return-Path: <linux-kernel-owner+willy=40w.ods.org-S267700AbUIMPax@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S267700AbUIMPax (ORCPT <rfc822;willy@w.ods.org>);
	Mon, 13 Sep 2004 11:30:53 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S267928AbUIMPab
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Mon, 13 Sep 2004 11:30:31 -0400
Received: from rproxy.gmail.com ([64.233.170.205]:56430 "EHLO mproxy.gmail.com")
	by vger.kernel.org with ESMTP id S267700AbUIMP0F (ORCPT
	<rfc822;linux-kernel@vger.kernel.org>);
	Mon, 13 Sep 2004 11:26:05 -0400
Message-ID: <3e3b490d040913082648bcaf3@mail.gmail.com>
Date: Mon, 13 Sep 2004 11:26:04 -0400
From: Alfred Rossi <alfredr@gmail.com>
Reply-To: Alfred Rossi <alfredr@gmail.com>
To: linux-kernel@vger.kernel.org
Subject: "SMP" scheduler_tick confusion
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

Since scheduler_tick handles time-slice maintenance in the kernel, I
was under the impression that with HZ (asm/param.h) frequency each cpu
in an SMP scenario should run scheduler_tick shortly after the timer
interrupt fires. I believe this should be the case since each cpu
could simultaneously be executing a separate task, each task would
need to have it's time slices adjusted. This does not appear to be
what actually happens. I looked around the source for a bit, and
couldn't find anything to convince me that each cpu runs
scheduler_tick independently, so I decided to perform a little
experiment. It's ugly, I know, but I placed a printk in scheduler tick
with the cpu's id. sampled the output from scheduler_tick for 1
second, and then analyzed the remaining file. With a HZ of 1000 and 2
Cpu's I expected to at least have very close to 2000 characters, with
a near equal number of 1's and 0's. Since the timer interrupt was
generated by the same timer for both cpu's I also expected to see a
regular pattern with an even distribution of 1's and 0's. Instead what
I found is that I had 996 characters (close enough to HZ, wish my
timing was better), and a random pattern of 1's and 0's, each
composing roughly half of the overall file. Which gives me the
impression that the first available cpu is handling the interrupt.
Wouldn't that throw off the intended functioning of scheduler_tick?
The machine this was tested on, I must note, was not a true SMP but a
P4 with HT enabled. Could someone shed some light on this? What am I
missing?

Kind Regards,
Alfred Rossi
