Return-Path: <linux-kernel-owner+willy=40w.ods.org-S1030876AbWKOS63@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1030876AbWKOS63 (ORCPT <rfc822;willy@w.ods.org>);
	Wed, 15 Nov 2006 13:58:29 -0500
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S1030877AbWKOS63
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Wed, 15 Nov 2006 13:58:29 -0500
Received: from cantor2.suse.de ([195.135.220.15]:4575 "EHLO mx2.suse.de")
	by vger.kernel.org with ESMTP id S1030876AbWKOS62 (ORCPT
	<rfc822;linux-kernel@vger.kernel.org>);
	Wed, 15 Nov 2006 13:58:28 -0500
Date: Wed, 15 Nov 2006 19:58:13 +0100
Message-ID: <s5hslgktu4a.wl%tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: Jeff Garzik <jeff@garzik.org>
Cc: David Miller <davem@davemloft.net>, torvalds@osdl.org,
       linux-kernel@vger.kernel.org
Subject: Re: [PATCH] ALSA: hda-intel - Disable MSI support by default
In-Reply-To: <455B5D22.10408@garzik.org>
References: <Pine.LNX.4.64.0611141846190.3349@woody.osdl.org>
	<20061114.190036.30187059.davem@davemloft.net>
	<Pine.LNX.4.64.0611141909370.3349@woody.osdl.org>
	<20061114.192117.112621278.davem@davemloft.net>
	<s5hbqn99f2v.wl%tiwai@suse.de>
	<455B5D22.10408@garzik.org>
User-Agent: Wanderlust/2.12.0 (Your Wildest Dreams) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.7 (=?ISO-8859-4?Q?Sanj=F2?=) APEL/10.6 MULE XEmacs/21.5 (beta27)
 (fiddleheads) (+CVS-20060704) (i386-suse-linux)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

At Wed, 15 Nov 2006 13:32:02 -0500,
Jeff Garzik wrote:
> 
> Takashi Iwai wrote:
> > The snd-hda-intel driver has a test of MSI, but it seems not working
> > on every machine.  It caused non-cared interrupts and the kernel
> > disabled that irq.
> 
> Possibly the test was broken.  Did you have IRQF_DISABLED and 
> IRQF_SHARED flags set?

I think IRQF_* is irrelevant there.
It looks like that the hardware issues INTX regardless whether MSI is
enabled or not.  Thus it ends up with unexpected irqs which are never
caught by the driver (the driver expects a different irq from MSI),
and eventually the kernel kills this irq.

Possibly calling pci_intx() as you suggested might help to avoid this
situation.  Can anyone test the patch below?


Takashi

---
diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c
index e35cfd3..bdb92b3 100644
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@ -544,6 +544,7 @@ static unsigned int azx_rirb_get_respons
 		free_irq(chip->irq, chip);
 		chip->irq = -1;
 		pci_disable_msi(chip->pci);
+		pci_intx(chip->pci, 1);
 		chip->msi = 0;
 		if (azx_acquire_irq(chip, 1) < 0)
 			return -1;
@@ -830,14 +831,15 @@ static irqreturn_t azx_interrupt(int irq
 {
 	struct azx *chip = dev_id;
 	struct azx_dev *azx_dev;
+	unsigned long flags;
 	u32 status;
 	int i;
 
-	spin_lock(&chip->reg_lock);
+	spin_lock_irqsave(&chip->reg_lock, flags);
 
 	status = azx_readl(chip, INTSTS);
 	if (status == 0) {
-		spin_unlock(&chip->reg_lock);
+		spin_unlock_irqrestore(&chip->reg_lock, flags);
 		return IRQ_NONE;
 	}
 	
@@ -867,7 +869,7 @@ static irqreturn_t azx_interrupt(int irq
 	if (azx_readb(chip, STATESTS) & 0x04)
 		azx_writeb(chip, STATESTS, 0x04);
 #endif
-	spin_unlock(&chip->reg_lock);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
 	
 	return IRQ_HANDLED;
 }
@@ -1380,7 +1382,8 @@ static int __devinit azx_init_stream(str
 
 static int azx_acquire_irq(struct azx *chip, int do_disconnect)
 {
-	if (request_irq(chip->pci->irq, azx_interrupt, IRQF_DISABLED|IRQF_SHARED,
+	if (request_irq(chip->pci->irq, azx_interrupt,
+			chip->msi ? 0 : IRQF_SHARED,
 			"HDA Intel", chip)) {
 		printk(KERN_ERR "hda-intel: unable to grab IRQ %d, "
 		       "disabling device\n", chip->pci->irq);
@@ -1435,9 +1438,12 @@ static int azx_resume(struct pci_dev *pc
 		return -EIO;
 	}
 	pci_set_master(pci);
-	if (chip->msi)
+	if (chip->msi) {
 		if (pci_enable_msi(pci) < 0)
 			chip->msi = 0;
+		else
+			pci_intx(pci, 0);
+	}
 	if (azx_acquire_irq(chip, 1) < 0)
 		return -EIO;
 	azx_init_chip(chip);
@@ -1561,9 +1567,12 @@ static int __devinit azx_create(struct s
 		goto errout;
 	}
 
-	if (chip->msi)
+	if (chip->msi) {
 		if (pci_enable_msi(pci) < 0)
 			chip->msi = 0;
+		else
+			pci_intx(pci, 0);
+	}
 
 	if (azx_acquire_irq(chip, 0) < 0) {
 		err = -EBUSY;
