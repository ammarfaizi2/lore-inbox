Return-Path: <linux-kernel-owner+willy=40w.ods.org@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261821AbTEBGGI (ORCPT <rfc822;willy@w.ods.org>);
	Fri, 2 May 2003 02:06:08 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261839AbTEBGGI
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Fri, 2 May 2003 02:06:08 -0400
Received: from i235066.ppp.asahi-net.or.jp ([61.125.235.66]:38895 "EHLO
	mitou.ysato.zive.net") by vger.kernel.org with ESMTP
	id S261821AbTEBGFg (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
	Fri, 2 May 2003 02:05:36 -0400
Date: Fri, 02 May 2003 15:17:58 +0900
Message-ID: <m24r4drhwp.wl@ysato.zive.net>
From: Yoshinori Sato <ysato@users.sourceforge.jp>
To: Linus Torvalds <torvalds@transmeta.com>
Cc: linux-kernel Mailinglist <linux-kernel@vger.kernel.org>
Subject: [PATCH] H8/300 support update (1/4)
User-Agent: Wanderlust/2.10.0 (Venus) SEMI/1.14.4 (Hosorogi) FLIM/1.14.4
 (=?ISO-8859-4?Q?Kashiharajing=FE-mae?=) APEL/10.4 Emacs/21.2
 (i386-pc-linux-gnu) MULE/5.0 (SAKAKI)
MIME-Version: 1.0 (generated by SEMI 1.14.4 - "Hosorogi")
Content-Type: multipart/mixed;
 boundary="Multipart_Fri_May__2_15:17:58_2003-1"
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

--Multipart_Fri_May__2_15:17:58_2003-1
Content-Type: text/plain; charset=US-ASCII

include

o fixed exception stack handling.
o fixed signal handling.
o fixed context switch problem.
o fixed configure scripts.

-- 
Yoshinori Sato
<ysato@users.sourceforge.jp>


--Multipart_Fri_May__2_15:17:58_2003-1
Content-Type: application/octet-stream; type=patch
Content-Disposition: attachment; filename="linux-2.5.68-h8300.diff"
Content-Transfer-Encoding: 7bit

Index: MAINTAINERS
===================================================================
RCS file: /var/lib/cvs/linux-2.5/MAINTAINERS,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 MAINTAINERS
--- MAINTAINERS	21 Apr 2003 02:22:42 -0000	1.1.1.1
+++ MAINTAINERS	2 May 2003 04:46:58 -0000
@@ -2088,6 +2088,12 @@
 W:	http://www.ee.nec.de/uclinux/
 S:	Supported
 
+UCLINUX FOR RENESAS H8/300
+P:	Yoshinori Sato
+M:	ysato@users.sourceforge.jp
+W:	http://uclinux-h8.sourceforge.jp/
+S:	Supported
+
 USB DIAMOND RIO500 DRIVER
 P:	Cesar Miquel
 M:	miquel@df.uba.ar
Index: arch/h8300/Kconfig
===================================================================
RCS file: /var/lib/cvs/linux-2.5/arch/h8300/Kconfig,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -r1.1.1.1 -r1.2
--- arch/h8300/Kconfig	21 Apr 2003 02:22:44 -0000	1.1.1.1
+++ arch/h8300/Kconfig	1 May 2003 13:14:09 -0000	1.2
@@ -121,12 +121,13 @@
 endchoice
 
 config DEFAULT_CMDLINE
-	bool
+	bool "Use buildin commandline"
 	help
 	  buildin kernel commandline enabled.
 
 config KERNEL_COMMAND
-	string
+	string "Buildin commmand string"
+	depends on DEFAULT_CMDLINE
 	help
 	  buildin kernel commandline strings.
 
@@ -148,8 +149,9 @@
 
 endmenu
 
-source "drivers/block/Kconfig"
+source "drivers/mtd/Kconfig"
 
+source "drivers/block/Kconfig"
 
 menu "ATA/IDE/MFM/RLL support"
 
Index: arch/h8300/kernel/asm-offsets.c
===================================================================
RCS file: /var/lib/cvs/linux-2.5/arch/h8300/kernel/asm-offsets.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 asm-offsets.c
--- arch/h8300/kernel/asm-offsets.c	21 Apr 2003 02:22:44 -0000	1.1.1.1
+++ arch/h8300/kernel/asm-offsets.c	1 May 2003 12:16:14 -0000
@@ -40,7 +40,6 @@
 	DEFINE(THREAD_KSP, offsetof(struct thread_struct, ksp));
 	DEFINE(THREAD_USP, offsetof(struct thread_struct, usp));
 	DEFINE(THREAD_CCR, offsetof(struct thread_struct, ccr));
-	DEFINE(THREAD_VFORK, offsetof(struct thread_struct, vfork_ret));
 
 	DEFINE(PT_PTRACED, PT_PTRACED);
 	DEFINE(PT_DTRACE, PT_DTRACE);
Index: arch/h8300/kernel/process.c
===================================================================
RCS file: /var/lib/cvs/linux-2.5/arch/h8300/kernel/process.c,v
retrieving revision 1.1.1.1
retrieving revision 1.4
diff -u -r1.1.1.1 -r1.4
--- arch/h8300/kernel/process.c	21 Apr 2003 02:22:44 -0000	1.1.1.1
+++ arch/h8300/kernel/process.c	1 May 2003 13:39:10 -0000	1.4
@@ -44,7 +44,7 @@
 #include <asm/setup.h>
 #include <asm/pgtable.h>
 
-asmlinkage void ret_from_exception(void);
+asmlinkage void ret_from_fork(void);
 
 /*
  * The idle loop on an H8/300..
@@ -110,10 +110,13 @@
 	       regs->pc, regs->ccr);
 	printk("ORIG_ER0: %08lx ER0: %08lx ER1: %08lx\n",
 	       regs->orig_er0, regs->er0, regs->er1);
-	printk("ER2: %08lx ER3: %08lx\n",
-	       regs->er2, regs->er3);
-	if (!(regs->ccr & 0x10))
+	printk("ER2: %08lx ER3: %08lx ER4: %08lx ER5: %08lx\n",
+	       regs->er2, regs->er3, regs->er4, regs->er5);
+	printk("ER6' %08lx ",regs->er6);
+	if (user_mode(regs))
 		printk("USP: %08lx\n", rdusp());
+	else
+		printk("\n");
 }
 
 /*
@@ -198,25 +201,14 @@
 		 struct task_struct * p, struct pt_regs * regs)
 {
 	struct pt_regs * childregs;
-	struct switch_stack * childstack, *stack;
-	unsigned long stack_offset, *retp;
 
-	stack_offset = KTHREAD_SIZE - sizeof(struct pt_regs);
 	childregs = ((struct pt_regs *) (THREAD_SIZE + (unsigned long) p->thread_info)) - 1;
 
 	*childregs = *regs;
-
-	retp = (unsigned long *) regs-2;
-	stack = ((struct switch_stack *) retp) - 1;
-
-	childstack = ((struct switch_stack *) childregs) - 1;
-	*childstack = *stack;
-	childregs->er0 = 0;
-	childstack->retpc = (unsigned long) ret_from_exception;
+	childregs->retpc = (unsigned long) ret_from_fork;
 
 	p->thread.usp = usp;
-	p->thread.ksp = (unsigned long)childstack;
-	p->thread.vfork_ret = 0;
+	p->thread.ksp = (unsigned long)childregs;
 
 	return 0;
 }
@@ -226,8 +218,6 @@
  */
 void dump_thread(struct pt_regs * regs, struct user * dump)
 {
-	struct switch_stack *sw;
-
 /* changed the size calculations - should hopefully work better. lbt */
 	dump->magic = CMAGIC;
 	dump->start_code = 0;
@@ -239,14 +229,13 @@
 	dump->u_ssize = 0;
 
 	dump->u_ar0 = (struct user_regs_struct *)(((int)(&dump->regs)) -((int)(dump)));
-	sw = ((struct switch_stack *)regs) - 1;
 	dump->regs.er0 = regs->er0;
 	dump->regs.er1 = regs->er1;
 	dump->regs.er2 = regs->er2;
 	dump->regs.er3 = regs->er3;
-	dump->regs.er4 = sw->er4;
-	dump->regs.er5 = sw->er5;
-	dump->regs.er6 = sw->er6;
+	dump->regs.er4 = regs->er4;
+	dump->regs.er5 = regs->er5;
+	dump->regs.er6 = regs->er6;
 	dump->regs.orig_er0 = regs->orig_er0;
 	dump->regs.ccr = regs->ccr;
 	dump->regs.pc  = regs->pc;
@@ -259,7 +248,7 @@
 {
 	int error;
 	char * filename;
-	struct pt_regs *regs = (struct pt_regs *) ((unsigned char *)&dummy+4);
+	struct pt_regs *regs = (struct pt_regs *) ((unsigned char *)&dummy-4);
 
 	lock_kernel();
 	filename = getname(name);
@@ -283,14 +272,7 @@
 
 unsigned long thread_saved_pc(struct task_struct *tsk)
 {
-	struct switch_stack *sw = (struct switch_stack *)(tsk->thread.ksp);
-
-	/* Check whether the thread is blocked in resume() */
-	if (sw->retpc > (unsigned long)scheduling_functions_start_here &&
-	    sw->retpc < (unsigned long)scheduling_functions_end_here)
-		return ((unsigned long *)sw->er6)[1];
-	else
-		return sw->retpc;
+	return ((struct pt_regs *)tsk->thread.esp0)->pc;
 }
 
 unsigned long get_wchan(struct task_struct *p)
@@ -302,7 +284,7 @@
 		return 0;
 
 	stack_page = (unsigned long)p;
-	fp = ((struct switch_stack *)p->thread.ksp)->er6;
+	fp = ((struct pt_regs *)p->thread.ksp)->er6;
 	do {
 		if (fp < stack_page+sizeof(struct task_struct) ||
 		    fp >= 8184+stack_page)
Index: arch/h8300/kernel/ptrace.c
===================================================================
RCS file: /var/lib/cvs/linux-2.5/arch/h8300/kernel/ptrace.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -r1.1.1.1 -r1.2
--- arch/h8300/kernel/ptrace.c	21 Apr 2003 02:22:44 -0000	1.1.1.1
+++ arch/h8300/kernel/ptrace.c	25 Apr 2003 17:35:16 -0000	1.2
@@ -46,14 +46,12 @@
 
 /* Find the stack offset for a register, relative to thread.esp0. */
 #define PT_REG(reg)	((long)&((struct pt_regs *)0)->reg)
-#define SW_REG(reg)	((long)&((struct switch_stack *)0)->reg \
-			 - sizeof(struct switch_stack))
 /* Mapping from PT_xxx to the stack offset at which the register is
    saved.  Notice that usp has no stack-slot and needs to be treated
    specially (see get_reg/put_reg below). */
 static const int regoff[] = {
-	PT_REG(er1), PT_REG(er2), PT_REG(er3), SW_REG(er4),
-	SW_REG(er5), SW_REG(er6), PT_REG(er0), PT_REG(orig_er0),
+	PT_REG(er1), PT_REG(er2), PT_REG(er3), PT_REG(er4),
+	PT_REG(er5), PT_REG(er6), PT_REG(er0), PT_REG(orig_er0),
 	PT_REG(ccr), PT_REG(pc)
 };
 
Index: arch/h8300/kernel/setup.c
===================================================================
RCS file: /var/lib/cvs/linux-2.5/arch/h8300/kernel/setup.c,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -r1.1.1.1 -r1.3
--- arch/h8300/kernel/setup.c	21 Apr 2003 02:22:44 -0000	1.1.1.1
+++ arch/h8300/kernel/setup.c	1 May 2003 13:36:32 -0000	1.3
@@ -91,7 +91,14 @@
 {
 	int bootmap_size;
 
-	memory_start = PAGE_ALIGN((unsigned long)(&_ramstart));
+	memory_start = (unsigned long) &_ramstart;
+
+	/* allow for ROMFS on the end */
+	if (memcmp(memory_start, "-rom1fs-", 8) == 0) {
+		memory_start += be32_to_cpu(((unsigned long *) memory_start)[2]);
+	}
+
+	memory_start = PAGE_ALIGN(memory_start);
 	memory_end = &_ramend; /* by now the stack is part of the init task */
 
 	init_mm.start_code = (unsigned long) &_stext;
@@ -103,10 +110,10 @@
 	register_console(&gdb_console);
 #endif
 
-	printk("\x0F\r\n\nuClinux " CPU "\n");
+	printk("\r\n\nuClinux " CPU "\n");
 	printk("Target Hardware: %s\n",_target_name);
 	printk("Flat model support (C) 1998,1999 Kenneth Albanowski, D. Jeff Dionne\n");
-	printk("H8/300H support by Yoshinori Sato <ysato@users.sourceforge.jp>\n");
+	printk("H8/300 series support by Yoshinori Sato <ysato@users.sourceforge.jp>\n");
 
 #ifdef DEBUG
 	printk("KERNEL -> TEXT=0x%06x-0x%06x DATA=0x%06x-0x%06x "
Index: arch/h8300/kernel/signal.c
===================================================================
RCS file: /var/lib/cvs/linux-2.5/arch/h8300/kernel/signal.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -r1.1.1.1 -r1.2
--- arch/h8300/kernel/signal.c	21 Apr 2003 02:22:44 -0000	1.1.1.1
+++ arch/h8300/kernel/signal.c	25 Apr 2003 17:35:16 -0000	1.2
@@ -9,7 +9,8 @@
  */
 
 /*
- * uClinux H8/300 support by Yoshinori Sato
+ * uClinux H8/300 support by Yoshinori Sato <ysato@users.sourceforge.jp>
+ *                and David McCullough <davidm@snapgear.com>
  *
  * Based on
  * Linux/m68k by Hamish Macdonald
@@ -151,26 +152,29 @@
 
 struct sigframe
 {
+	long dummy_er0;
+	long dummy_vector;
+#if defined(CONFIG_CPU_H8S)
+	short dummy_exr;
+#endif
 	char *pretcode;
-	int sig;
-	int code;
-	struct sigcontext *psc;
-	char retcode[6];
+	unsigned char retcode[8];
 	unsigned long extramask[_NSIG_WORDS-1];
 	struct sigcontext sc;
-};
+} __attribute__((aligned(2),packed));
 
 struct rt_sigframe
 {
+	long dummy_er0;
+	long dummy_vector;
+#if defined(CONFIG_CPU_H8S)
+	short dummy_exr;
+#endif
 	char *pretcode;
-	int sig;
-	struct siginfo *pinfo;
-	void *puc;
-	char retcode[6];
+	unsigned char retcode[8];
 	struct siginfo info;
 	struct ucontext uc;
-};
-
+} __attribute__((aligned(2),packed));
 
 static inline int
 restore_sigcontext(struct pt_regs *regs, struct sigcontext *usc, void *fp,
@@ -200,8 +204,7 @@
 }
 
 static inline int
-rt_restore_ucontext(struct pt_regs *regs, struct switch_stack *sw,
-		    struct ucontext *uc, int *pd0)
+rt_restore_ucontext(struct pt_regs *regs, struct ucontext *uc, int *pd0)
 {
 	int temp;
 	greg_t *gregs = uc->uc_mcontext.gregs;
@@ -216,9 +219,9 @@
 	err |= __get_user(regs->er1, &gregs[1]);
 	err |= __get_user(regs->er2, &gregs[2]);
 	err |= __get_user(regs->er3, &gregs[3]);
-	err |= __get_user(sw->er4, &gregs[4]);
-	err |= __get_user(sw->er5, &gregs[5]);
-	err |= __get_user(sw->er6, &gregs[6]);
+	err |= __get_user(regs->er4, &gregs[4]);
+	err |= __get_user(regs->er5, &gregs[5]);
+	err |= __get_user(regs->er6, &gregs[6]);
 	err |= __get_user(usp, &gregs[7]);
 	wrusp(usp);
 	err |= __get_user(regs->pc, &gregs[8]);
@@ -238,8 +241,7 @@
 
 asmlinkage int do_sigreturn(unsigned long __unused,...)
 {
-	struct switch_stack *sw = (struct switch_stack *) &__unused;
-	struct pt_regs *regs = (struct pt_regs *) (sw + 1);
+	struct pt_regs *regs = (struct pt_regs *) &__unused;
 	unsigned long usp = rdusp();
 	struct sigframe *frame = (struct sigframe *)(usp - 4);
 	sigset_t set;
@@ -270,8 +272,7 @@
 
 asmlinkage int do_rt_sigreturn(unsigned long __unused,...)
 {
-	struct switch_stack *sw = (struct switch_stack *) &__unused;
-	struct pt_regs *regs = (struct pt_regs *) (sw + 1);
+	struct pt_regs *regs = (struct pt_regs *) &__unused;
 	unsigned long usp = rdusp();
 	struct rt_sigframe *frame = (struct rt_sigframe *)(usp - 4);
 	sigset_t set;
@@ -288,7 +289,7 @@
 	recalc_sigpending();
 	spin_lock_irq(&current->sighand->siglock);
 	
-	if (rt_restore_ucontext(regs, sw, &frame->uc, &er0))
+	if (rt_restore_ucontext(regs, &frame->uc, &er0))
 		goto badframe;
 	return er0;
 
@@ -312,7 +313,6 @@
 
 static inline int rt_setup_ucontext(struct ucontext *uc, struct pt_regs *regs)
 {
-	struct switch_stack *sw = (struct switch_stack *)regs - 1;
 	greg_t *gregs = uc->uc_mcontext.gregs;
 	int err = 0;
 
@@ -321,9 +321,9 @@
 	err |= __put_user(regs->er1, &gregs[1]);
 	err |= __put_user(regs->er2, &gregs[2]);
 	err |= __put_user(regs->er3, &gregs[3]);
-	err |= __put_user(sw->er4, &gregs[4]);
-	err |= __put_user(sw->er5, &gregs[5]);
-	err |= __put_user(sw->er6, &gregs[6]);
+	err |= __put_user(regs->er4, &gregs[4]);
+	err |= __put_user(regs->er5, &gregs[5]);
+	err |= __put_user(regs->er6, &gregs[6]);
 	err |= __put_user(rdusp(), &gregs[7]);
 	err |= __put_user(regs->pc, &gregs[8]);
 	err |= __put_user(regs->ccr, &gregs[9]);
@@ -355,15 +355,6 @@
 
 	frame = get_sigframe(ka, regs, sizeof(*frame));
 
-	err |= __put_user((current_thread_info()->exec_domain
-			   && current_thread_info()->exec_domain->signal_invmap
-			   && sig < 32
-			   ? current_thread_info()->exec_domain->signal_invmap[sig]
-			   : sig),
-			  &frame->sig);
-
-	err |= __put_user(&frame->sc, &frame->psc);
-
 	if (_NSIG_WORDS > 1)
 		err |= copy_to_user(frame->extramask, &set->sig[1],
 				    sizeof(frame->extramask));
@@ -376,8 +367,8 @@
 
 	/* sub.l er0,er0; mov.b #__NR_sigreturn,r0l; trapa #0 */
 	err != __put_user(0x1a80f800 + (__NR_sigreturn & 0xff),
-			(long *)(frame->retcode + 0));
-	err |= __put_user(0x5700, (short *)(frame->retcode + 4));
+			(unsigned long *)(frame->retcode + 0));
+	err |= __put_user(0x5700, (unsigned short *)(frame->retcode + 4));
 
 
 	if (err)
@@ -386,6 +377,12 @@
 	/* Set up registers for signal handler */
 	wrusp ((unsigned long) frame);
 	regs->pc = (unsigned long) ka->sa.sa_handler;
+	regs->er0 = (current_thread_info()->exec_domain
+			   && current_thread_info()->exec_domain->signal_invmap
+			   && sig < 32
+			   ? current_thread_info()->exec_domain->signal_invmap[sig]
+		          : sig);
+	regs->er1 = (unsigned long)&(frame->sc);
 
 	return;
 
@@ -403,14 +400,6 @@
 
 	frame = get_sigframe(ka, regs, sizeof(*frame));
 
-	err |= __put_user((current_thread_info()->exec_domain
-			   && current_thread_info()->exec_domain->signal_invmap
-			   && sig < 32
-			   ? current_thread_info()->exec_domain->signal_invmap[sig]
-			   : sig),
-			  &frame->sig);
-	err |= __put_user(&frame->info, &frame->pinfo);
-	err |= __put_user(&frame->uc, &frame->puc);
 	err |= copy_siginfo_to_user(&frame->info, info);
 
 	/* Create the ucontext.  */
@@ -438,7 +427,14 @@
 
 	/* Set up registers for signal handler */
 	wrusp ((unsigned long) frame);
-	regs->pc = (unsigned long) ka->sa.sa_handler;
+	regs->pc  = (unsigned long) ka->sa.sa_handler;
+	regs->er0 = (current_thread_info()->exec_domain
+		     && current_thread_info()->exec_domain->signal_invmap
+		     && sig < 32
+		     ? current_thread_info()->exec_domain->signal_invmap[sig]
+		     : sig);
+	regs->er1 = (unsigned long)&(frame->info);
+	regs->er2 = (unsigned long)&frame->uc;
 
 	return;
 
Index: arch/h8300/kernel/sys_h8300.c
===================================================================
RCS file: /var/lib/cvs/linux-2.5/arch/h8300/kernel/sys_h8300.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -r1.1.1.1 -r1.2
--- arch/h8300/kernel/sys_h8300.c	21 Apr 2003 02:22:44 -0000	1.1.1.1
+++ arch/h8300/kernel/sys_h8300.c	1 May 2003 13:39:10 -0000	1.2
@@ -281,7 +281,7 @@
 #if defined(CONFIG_SYSCALL_PRINT)
 asmlinkage void syscall_print(void *dummy,...)
 {
-	struct pt_regs *regs = (struct pt_regs *) ((unsigned char *)&dummy);
+	struct pt_regs *regs = (struct pt_regs *) ((unsigned char *)&dummy-4);
 	unsigned long *usp=rdusp()+8;
 	printk("call %06x:%d 1:%08x,2:%08x,3:%08x,ret:%08x\n",
                ((*usp) & 0xffffff)-2,regs->orig_er0,regs->er1,regs->er2,regs->er3,regs->er0);
Index: arch/h8300/kernel/syscalls.S
===================================================================
RCS file: /var/lib/cvs/linux-2.5/arch/h8300/kernel/syscalls.S,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -r1.1.1.1 -r1.2
--- arch/h8300/kernel/syscalls.S	21 Apr 2003 02:22:44 -0000	1.1.1.1
+++ arch/h8300/kernel/syscalls.S	25 Apr 2003 17:35:16 -0000	1.2
@@ -312,3 +312,7 @@
 	mov.l	#SYMBOL_NAME(h8300_fork),er0
 	jmp	@SYMBOL_NAME(syscall_trampoline)
 
+SYMBOL_NAME_LABEL(sys_vfork)
+	mov.l	#SYMBOL_NAME(h8300_vfork),er0
+	jmp	@SYMBOL_NAME(syscall_trampoline)
+
Index: arch/h8300/platform/h8300h/entry.S
===================================================================
RCS file: /var/lib/cvs/linux-2.5/arch/h8300/platform/h8300h/entry.S,v
retrieving revision 1.1.1.1
retrieving revision 1.4
diff -u -r1.1.1.1 -r1.4
--- arch/h8300/platform/h8300h/entry.S	21 Apr 2003 02:22:44 -0000	1.1.1.1
+++ arch/h8300/platform/h8300h/entry.S	1 May 2003 13:39:10 -0000	1.4
@@ -3,6 +3,7 @@
  *  linux/arch/h8300/platform/h8300h/entry.S
  *
  *  Yoshinori Sato <ysato@users.sourceforge.jp>
+ *  David McCullough <davidm@snapgear.com>
  *
  */
 
@@ -29,14 +30,17 @@
 		
 /* the following macro is used when enabling interrupts */
 
-LER3	=	0
-LER2	=	4
-LER1	=	8
-LORIG	=	12
-LCCR	=	16
-LER0	=	18
-LVEC	=	22
-LRET	=	24
+LER4	=	0
+LER5	=	4
+LER6	=	8
+LER3	=	12
+LER2	=	16
+LER1	=	20
+LORIG	=	24
+LCCR	=	28
+LER0	=	30
+LVEC	=	34
+LRET	=	38
 
 	.h8300h
 
@@ -44,83 +48,93 @@
 	
 	.macro	SAVE_ALL
 	mov.l	er0,@-sp
-	stc	ccr,r0l
+
+	stc	ccr,r0l				/* check kernel mode */
 	orc	#0x10,ccr
 	btst	#4,r0l
-	bne	1f
-	mov.l	sp,@SYMBOL_NAME(sw_usp)
+	bne	5f
+
+	mov.l	sp,@SYMBOL_NAME(sw_usp)		/* user mode */
 	mov.l	@sp,er0
 	mov.l	@SYMBOL_NAME(sw_ksp),sp
+	sub.l	#(LRET-LORIG),sp		/* allocate LORIG - LRET */ 
 	mov.l	er0,@-sp
-	stc	ccr,r0l
-	and	#0xef,r0l
-	mov.w	r0,@-sp
-	mov.l	@(2:16,sp),er0
-	bra	2f
-1:
-	mov.l	@sp,er0
-	stc	ccr,@-sp
-2:	
+	mov.l	er1,@-sp
+	mov.l   @SYMBOL_NAME(sw_usp),er0
+	mov.l   @(8:16,er0),er1                 /* copy the RET addr */
+	mov.l   er1,@(LRET-LER1:16,sp)
+
+	mov.w	e1,r1				/* e1 highbyte = ccr */
+	and	#0xef,r1h			/* mask mode? flag */
+	sub.w	r0,r0
+	mov.b	r1h,r0l
+	mov.w	r0,@(LCCR-LER1:16,sp)		/* copy ccr */
+	mov.l	@(LORIG-LER1:16,sp),er0
+	mov.l	er0,@(LER0-LER1:16,sp)		/* copy ER0 */
+	bra	6f
+5:
+	mov.l	@sp,er0				/* kernel mode */
+	subs	#2,sp				/* dummy ccr */
 	mov.l	er0,@-sp
 	mov.l	er1,@-sp
+	mov.w	@(LRET-LER1:16,sp),r1		/* copy old ccr */
+	mov.b	r1h,r1l
+	mov.b	#0,r1h
+	mov.w	r1,@(LCCR-LER1:16,sp)		/* set ccr */
+6:
 	mov.l	er2,@-sp
 	mov.l	er3,@-sp
+	mov.l	er6,@-sp			/* syscall arg #6 */
+	mov.l	er5,@-sp			/* syscall arg #5 */
+	mov.l	er4,@-sp			/* syscall arg #4 */
 	.endm
 
-	.macro RESTORE_REGS
-	mov.w	@(LCCR:16,sp),r0
+	.macro	RESTORE_ALL
+	mov.l	@sp+,er4
+	mov.l	@sp+,er5
+	mov.l	@sp+,er6
+	mov.l	@sp+,er3
+	mov.l	@sp+,er2
+	mov.w	@(LCCR-LER1:16,sp),r0		/* check kernel mode */
 	btst	#4,r0l
-	bne	1f
+	bne	7f
+
 	mov.l	@SYMBOL_NAME(sw_usp),er0
-	mov.l	@(LER0:16,sp),er1
+	mov.l	@(LER0-LER1:16,sp),er1		/* restore ER0 */
 	mov.l	er1,@er0
-	mov.l	@sp+,er3
-	mov.l	@sp+,er2
+	mov.w	@(LCCR-LER1:16,sp),r1		/* restore the RET addr */
+	mov.b	r1l,r1h
+	mov.b	@(LRET+1-LER1:16,sp),r1l
+	mov.w	r1,e1
+	mov.w	@(LRET+2-LER1:16,sp),r1
+	mov.l	er1,@(8:16,er0)
+
 	mov.l	@sp+,er1
-	add.l	#10,sp
+	add.l	#(LRET-LORIG),sp		/* remove LORIG - LRET */ 
 	mov.l	sp,@SYMBOL_NAME(sw_ksp)
 	mov.l	er0,sp
-	bra	2f
-1:
-	mov.l	@sp+,er3
-	mov.l	@sp+,er2
+	bra	8f
+7:
 	mov.l	@sp+,er1
 	adds	#4,sp
 	adds	#2,sp
-2:
+8:
 	mov.l	@sp+,er0
-	adds	#4,sp
-	.endm
-	
-	.macro	RESTORE_ALL
-	RESTORE_REGS
+	adds	#4,sp				/* remove the sw created LVEC */
 	rte
 	.endm
-
-#define SWITCH_STACK_SIZE (3*4+12)	/* includes return address */
-
-	.macro	SAVE_SWITCH_STACK
-	mov.l	er4,@-sp
-	mov.l	er5,@-sp
-	mov.l	er6,@-sp
-	.endm
-
-	.macro	RESTORE_SWITCH_STACK
-	mov.l	@sp+,er6
-	mov.l	@sp+,er5
-	mov.l	@sp+,er4
-	.endm
-
+	
 .globl SYMBOL_NAME(system_call)
 .globl SYMBOL_NAME(ret_from_exception)
+.globl SYMBOL_NAME(ret_from_fork)
 .globl SYMBOL_NAME(ret_from_signal)
 .globl SYMBOL_NAME(ret_from_interrupt), SYMBOL_NAME(bad_interrupt)
 .globl SYMBOL_NAME(interrupt_redirect_table)
 .globl SYMBOL_NAME(sw_ksp),SYMBOL_NAME(sw_usp)
 .globl SYMBOL_NAME(resume)
-.globl SYMBOL_NAME(sys_vfork)
 .globl SYMBOL_NAME(syscall_trampoline)
 	
+INTERRUPTS = 64		
 	.section .int_redirect,"ax"
 SYMBOL_NAME_LABEL(interrupt_redirect_table)
 	.rept	7
@@ -131,7 +145,7 @@
 	.long	0
 	.long	0
 	jmp	@SYMBOL_NAME(trace_break)	/* TRAPA #3 (breakpoint) */
-	.rept	64-12
+	.rept	INTERRUPTS - 12
 	jsr	@interrupt_entry
 	.endr
 
@@ -161,8 +175,11 @@
 	jmp	@SYMBOL_NAME(ret_from_exception)
 
 SYMBOL_NAME_LABEL(system_call)
-	subs	#4,sp
+	subs	#4,sp				/* dummy LVEC */
 	SAVE_ALL
+	mov.w	@(LCCR:16,sp),r1
+	bset	#4,r1l
+	ldc	r1l,ccr
 	mov.l	er0,er3
 	mov.l	#-ENOSYS,er0
 	mov.l	er0,@(LER0:16,sp)
@@ -181,81 +198,53 @@
 	mov.l	@er0,er0
 	mov.l	er0,er3
 	beq	SYMBOL_NAME(ret_from_exception):16	
-	mov.l	@SYMBOL_NAME(_current_task),er2
+	mov.l	sp,er2
+	and.w	#0xe000,r2
 	mov.b	@((TASK_FLAGS+3-(TIF_SYSCALL_TRACE >> 3)):16,er2),r2l
 	btst	#(TIF_SYSCALL_TRACE & 7),r2l
 	bne	1f
 	mov.l	@(LER1:16,sp),er0
 	mov.l	@(LER2:16,sp),er1
 	mov.l	@(LER3:16,sp),er2
-	mov.l	er5,@-sp
-	mov.l	er4,@-sp
 	jsr	@er3
-	adds	#4,sp
-	adds	#4,sp
-	mov.l	er0,@(LER0,sp)		/* save the return value */
+	mov.l	er0,@(LER0,sp)			/* save the return value */
 #if defined(CONFIG_SYSCALL_PRINT)
 	jsr	@SYMBOL_NAME(syscall_print)
 #endif
 	jmp	@SYMBOL_NAME(ret_from_exception)
 1:
-	SAVE_SWITCH_STACK
-	mov.l	er3,er5			/* save syscall entry */
+	mov.l	er3,er5				/* save syscall entry */
 	jsr	SYMBOL_NAME(syscall_trace)
 	mov.l	er5,er3
-	RESTORE_SWITCH_STACK
-	mov.l	@(LER1:16,sp),er0
-	mov.l	@(LER2:16,sp),er1
-	mov.l	@(LER3:16,sp),er2
-	mov.l	er5,@-sp
-	mov.l	er4,@-sp
 	jsr	@er3
-	adds	#4,sp
-	adds	#4,sp
 	mov.l	er0,@(LER0:16,sp)		/* save the return value */
-	SAVE_SWITCH_STACK
 	jsr	SYMBOL_NAME(syscall_trace)
 
 SYMBOL_NAME_LABEL(ret_from_signal)
-	RESTORE_SWITCH_STACK
 
 SYMBOL_NAME_LABEL(ret_from_exception)
 	mov.b	@(LCCR+1:16,sp),r0l
 	btst	#4,r0l			/* check if returning to kernel */
 	bne	3f			/* if so, skip resched, signals */
 	andc	#0x7f,ccr
-	mov.l	@SYMBOL_NAME(_current_task),er0
+	mov.l	sp,er2
+	and.w	#0xe000,r2
 	mov.l	@(TI_FLAGS:16,er2),er1
 	and.l	#_TIF_WORK_MASK,er1
 	bne	1f
-	mov.l	@((TASK_THREAD+THREAD_VFORK):16,er0),er1 
-	bne	Lvfork_return
 3:	 
 	RESTORE_ALL			/* Does RTE */
 1:
 	mov.l	@(TI_FLAGS:16,er2),er1
 	btst	#TIF_NEED_RESCHED,r1l
 	bne	@SYMBOL_NAME(reschedule):16
-
-Lsignal_return:
-	SAVE_SWITCH_STACK
 	mov.l	sp,er1
-	add	#12,er1
 	mov.l	er2,er0
 	jsr	@SYMBOL_NAME(do_signal)
-	RESTORE_SWITCH_STACK
-	mov.l	@SYMBOL_NAME(_current_task),er0
-	mov.l	@((TASK_THREAD+THREAD_VFORK):16,er0),er1 
-	bne	Lvfork_return
+	mov.l	sp,er0
+	and.w	#0xe000,r0
 	RESTORE_ALL
 
-Lvfork_return:
-	sub.l	er2,er2
-	mov.l	er2,@((TASK_THREAD+THREAD_VFORK):16,er0)
-	mov.l	@SYMBOL_NAME(sw_usp),er0
-	mov.l	er1,@(8:16,er0)
-	RESTORE_ALL
-	
 SYMBOL_NAME_LABEL(reschedule)
 	/* save top of frame */
 	mov.l	sp,er0
@@ -265,6 +254,11 @@
 	mov.l	er0,@-sp
 	jmp	@SYMBOL_NAME(schedule)
 
+SYMBOL_NAME_LABEL(ret_from_fork)
+	mov.l	er2,er0
+	jsr	@SYMBOL_NAME(schedule_tail)
+	jmp	@SYMBOL_NAME_LABEL(ret_from_exception)	
+
 SYMBOL_NAME_LABEL(resume)
 	/*
 	 * Beware - when entering resume, offset of tss is in d1,
@@ -277,17 +271,13 @@
 	/* save sr */
 	sub.w	r3,r3
 	stc	ccr,r3l
-	mov.w	r3,@(THREAD_CCR:16,er0)
-	SAVE_SWITCH_STACK
+	mov.w	r3,@(THREAD_CCR+2:16,er0)
 
 	/* disable interrupts */
 	orc	#0x80,ccr
 	mov.l	@SYMBOL_NAME(sw_usp),er3
 	mov.l	er3,@(THREAD_USP:16,er0)
 	mov.l	sp,@(THREAD_KSP:16,er0)
-	
-	/* get pointer to tss struct (a1 contains new task) */
-	mov.l	er1,@SYMBOL_NAME(_current_task)
 
 	/* Skip address space switching if they are the same. */
 	/* FIXME: what did we hack out of here, this does nothing! */
@@ -295,10 +285,9 @@
 	mov.l	@(THREAD_USP:16,er1),er0
 	mov.l	er0,@SYMBOL_NAME(sw_usp)
 	mov.l	@(THREAD_KSP:16,er1),sp
-	RESTORE_SWITCH_STACK
 			
 	/* restore status register */
-	mov.w	@(THREAD_CCR:16,er1),r3
+	mov.w	@(THREAD_CCR+2:16,er1),r3
 
 	ldc	r3l,ccr
 
@@ -329,26 +318,10 @@
 	jsr	@SYMBOL_NAME(trace_trap)
 	jmp	@SYMBOL_NAME(ret_from_exception)	
 
-SYMBOL_NAME_LABEL(sys_vfork)
-	SAVE_SWITCH_STACK
-	mov.l	@SYMBOL_NAME(sw_usp),er6
-	mov.l	@(8:16,er6),er6
-	mov.l	sp,er0
-	add.l	#SWITCH_STACK_SIZE,er0
-	jsr	@SYMBOL_NAME(h8300_vfork)
-	mov.l	@SYMBOL_NAME(_current_task),er5
-	mov.l	er6,@((TASK_THREAD+THREAD_VFORK):16,er5)
-	RESTORE_SWITCH_STACK
-	rts
-
 SYMBOL_NAME_LABEL(syscall_trampoline)
-	SAVE_SWITCH_STACK
 	mov.l	er0,er6
 	mov.l	sp,er0
-	add.l	#SWITCH_STACK_SIZE,er0
-	jsr	@er6
-	RESTORE_SWITCH_STACK
-	rts
+	jmp	@er6
 
 	.section	.bss
 SYMBOL_NAME_LABEL(sw_ksp)
Index: arch/h8300/platform/h8300h/generic/crt0_rom.S
===================================================================
RCS file: /var/lib/cvs/linux-2.5/arch/h8300/platform/h8300h/generic/crt0_rom.S,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -r1.1.1.1 -r1.2
--- arch/h8300/platform/h8300h/generic/crt0_rom.S	21 Apr 2003 02:22:44 -0000	1.1.1.1
+++ arch/h8300/platform/h8300h/generic/crt0_rom.S	1 May 2003 13:38:10 -0000	1.2
@@ -35,6 +35,7 @@
 	inc.l	#1,er6
 	mov.l	#__ebss,er4
 	sub.l	er5,er4
+	dec.l	#1,er4
 	sub.w	r0,r0
 	mov.b	r0l,@er5
 1:	

--Multipart_Fri_May__2_15:17:58_2003-1--
