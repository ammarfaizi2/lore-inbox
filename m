Return-Path: <linux-kernel-owner+willy=40w.ods.org-S1161157AbWHAGZM@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1161157AbWHAGZM (ORCPT <rfc822;willy@w.ods.org>);
	Tue, 1 Aug 2006 02:25:12 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S1161172AbWHAGZM
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Tue, 1 Aug 2006 02:25:12 -0400
Received: from relay.2ka.mipt.ru ([194.85.82.65]:47302 "EHLO 2ka.mipt.ru")
	by vger.kernel.org with ESMTP id S1161167AbWHAGZK (ORCPT
	<rfc822;linux-kernel@vger.kernel.org>);
	Tue, 1 Aug 2006 02:25:10 -0400
Date: Tue, 1 Aug 2006 10:24:27 +0400
From: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
To: David Miller <davem@davemloft.net>
Cc: drepper@redhat.com, zach.brown@oracle.com, linux-kernel@vger.kernel.org,
       netdev@vger.kernel.org
Subject: Re: [RFC 1/4] kevent: core files.
Message-ID: <20060801062426.GA4869@2ka.mipt.ru>
References: <44CB8A67.3060801@redhat.com> <20060731103322.GA1898@2ka.mipt.ru> <20060731194143.GA12569@2ka.mipt.ru> <20060731.150028.26276495.davem@davemloft.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=koi8-r
Content-Disposition: inline
In-Reply-To: <20060731.150028.26276495.davem@davemloft.net>
User-Agent: Mutt/1.5.9i
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-1.7.5 (2ka.mipt.ru [0.0.0.0]); Tue, 01 Aug 2006 10:24:32 +0400 (MSD)
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

On Mon, Jul 31, 2006 at 03:00:28PM -0700, David Miller (davem@davemloft.net) wrote:
> From: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
> Date: Mon, 31 Jul 2006 23:41:43 +0400
> 
> > Since kevents are never generated by kernel, but only marked as ready,
> > length of the main queue performs as flow control, so we can create a
> > mapped buffer which will have space equal to the main queue length
> > multiplied by size of the copied to userspace structure plus 16 bits for
> > the start index of the kernel writing side, i.e. it will store offset
> > where the oldest event was placed.
> >
> > Since queue length is a limited factor and thus no new events can be added
> > when queue is full, that means that buffer is full too and userspace
> > must read events. When syscall is called to add new kevent and provided 
> > there offset differs from what kernel stored, that means that all events 
> > from kernel to provided index have been read and new events can be added.
> > Thus we can even allow read-only mapping. Kernel's index is incremented
> > modulo queue length. If kevent was removed after it was marked as
> > ready, it's copy stays in the mapped buffer, but special flag can be
> > assigned to show that kevent is no longer valid.
> 
> This sounds reasonable.
> 
> However we must be mindful that the thread of control trying to
> add a new event might not be in a position to drain the queue
> of pending events when the queue is full.  Usually he will be
> trying to add an event in response to handling another event.
> 
> So we'd have cases like this, assume we start with a full event
> queue:
> 
> 	thread A		thread B
> 
> 	dequeue event
> 	aha, new connection
> 	accept()
> 				register new kevent
> 				queue is now full again
> 	add kevent on new
> 	connection
> 
> At this point thread A doesn't have very many options when the kevent
> add fails.  You cannot force this thread to read more events, since he
> may not be in a state where he is easily able to do so.

By default all kevents are not removed from the queue, so accept events
will be in the queue and thread B will fail to register new kevent.
To remove kevent from the queue user should either set one-shot flag or
do it by special command.
So if we are in position when queue is full and all events are not
one-shot, control thread must think about what does it do, and remove
some of them (and next time add them with one-shot flag).

-- 
	Evgeniy Polyakov
