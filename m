Return-Path: <linux-kernel-owner+willy=40w.ods.org@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id <S261907AbSKTTyv>; Wed, 20 Nov 2002 14:54:51 -0500
Received: (majordomo@vger.kernel.org) by vger.kernel.org
	id <S261874AbSKTTyv>; Wed, 20 Nov 2002 14:54:51 -0500
Received: from packet.digeo.com ([12.110.80.53]:6559 "EHLO packet.digeo.com")
	by vger.kernel.org with ESMTP id <S261600AbSKTTyo>;
	Wed, 20 Nov 2002 14:54:44 -0500
Message-ID: <3DDBEA20.C8E1DC2C@digeo.com>
Date: Wed, 20 Nov 2002 12:01:36 -0800
From: Andrew Morton <akpm@digeo.com>
X-Mailer: Mozilla 4.79 [en] (X11; U; Linux 2.5.46 i686)
X-Accept-Language: en
MIME-Version: 1.0
To: Cort Dougan <cort@fsmlabs.com>
CC: Andre Hedrick <andre@linux-ide.org>, Alan Cox <alan@lxorguk.ukuu.org.uk>,
       Xavier Bestel <xavier.bestel@free.fr>,
       Mark Mielke <mark@mark.mielke.cc>, Rik van Riel <riel@conectiva.com.br>,
       David McIlwraith <quack@bigpond.net.au>,
       Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: Re: spinlocks, the GPL, and binary-only modules
References: <20021120123145.B17249@duath.fsmlabs.com> <Pine.LNX.4.10.10211201137110.3892-100000@master.linux-ide.org> <20021120124405.C17249@duath.fsmlabs.com>
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
X-OriginalArrivalTime: 20 Nov 2002 20:01:36.0360 (UTC) FILETIME=[A1993E80:01C290CF]
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

Cort Dougan wrote:
> 
>  A single config option that adds -fno-inline wouldn't be
> fork-worthy.

It takes a 400k patch to make the kernel build with -fno-inline.

The patch is generated by a script which weeds out all the
`extern inline's.  And then you need another little patch which
provides stub implementations of __this_fixmap_does_not_exist() and
__br_lock_usage_bug().

The extern-inline-weeder script is from Jim Houston.


#!/usr/bin/perl
#
# This script changes "extern inline" to "static inline" in header
# files.  I did this so that I could use -finstrument-functions to
# trace Linux kernel code.  The script is pretty stupid if it finds
# extern and inline togther its likely to make a change.  It removes
# the inline from forward references and changes extern to static
# for definitions.

open(FIND, "find . -name \*.[ch] |") || die "couldn't run find on *.[ch]\n";
while ($f = <FIND>) {
	chop $f;
	if (!open(FILE, $f)) {
		print STDERR "Can't open $f\n";
		next;
	}
#	print STDERR "scanning $f\n";
	undef $file_content;
	$file_content = "";
	$modified = 0;
OUT:
	while ($line = <FILE>) {
		# check for comment, ignore lines that start with 
		# a comment.  Ignore block comments
		if ($line =~ /^\s*\/\*.*\*\//) {
			$file_content .= $line;
			next;
		}
		if ($line =~ /^\s*\/\*/) {
			$file_content .= $line;
			while ($line = <FILE>) {
				$file_content .= $line;
				if ($line =~ /\*\//) { 
					next OUT;
				}
			}
			print STDERR "??? $f: end of file in comment?";
			
		}
		if ($line  =~ /extern\s+(.*)(inline|__inline|__inline__)\s/) {
			$extra = 0;
			if ($line =~ /^#define/) {
				# Alpha & ARM have defines
				# for extern inline which I'm
				#ignoring for now.
				$file_content .= $line;
				next;
			}
			while (!($line =~ /;|{/)) {
				if (!($nl = <FILE>)) {
					die "hit EOF... file=$f\n";
				}
				if (++$extra > 8) {
					print STDERR "??? $f: $line";
					last;
				}
				$line .= $nl;
			}
			if ($line =~ /{/) {
				$line =~ s/extern/static/;
				$modified = 1;
			} elsif ($line =~ /;/) {
				$line =~ s/[ 	]*__inline__[ 	]*/ /;
				$line =~ s/[ 	]*__inline[ 	]*/ /;
				$line =~ s/[ 	]*inline[ 	]*/ /;
				$modified = 1;
			}
		}
		$file_content .= $line;
	}
	close(FILE);
	$name = $f . ".orig";
	if ($modified && -e $name) {
		print STDERR "$name already exists - no changes made\n";
		next;
	}
	if ($modified) {
#		if (link($f, $name)) {
#			unlink($f);
#		} else {
#			print STDERR "Can't move $f to $name\n";
#			next;
#		}
		if (!open(FILE, ">$f")) {
			prinf STDERR "Can't open $f for output\n";
			next;
		}
		print FILE $file_content;
		close(FILE);
	}
}
