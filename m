Return-Path: <linux-kernel-owner+willy=40w.ods.org-S1750806AbVHXLCU@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1750806AbVHXLCU (ORCPT <rfc822;willy@w.ods.org>);
	Wed, 24 Aug 2005 07:02:20 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S1750808AbVHXLCU
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Wed, 24 Aug 2005 07:02:20 -0400
Received: from cantor2.suse.de ([195.135.220.15]:45972 "EHLO mx2.suse.de")
	by vger.kernel.org with ESMTP id S1750806AbVHXLCU (ORCPT
	<rfc822;linux-kernel@vger.kernel.org>);
	Wed, 24 Aug 2005 07:02:20 -0400
Date: Wed, 24 Aug 2005 13:02:18 +0200
Message-ID: <s5hacj74myt.wl%tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: Wei.Ni@uli.com.tw
Cc: pshou@realtek.com.tw, linux-kernel@vger.kernel.org, Emily.Jiang@uli.com.tw,
       Peer.Chen@uli.com.tw
Subject: Re: [patch] alsa-driver-1.0.9b/alsa-kernel/pci/hda/: HDA driver for ULI M5461
In-Reply-To: <OFFD189321.7C1C9711-ON48257067.0027DDAB@uli.com.tw>
References: <OFFD189321.7C1C9711-ON48257067.0027DDAB@uli.com.tw>
User-Agent: Wanderlust/2.12.0 (Your Wildest Dreams) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.7 (=?ISO-8859-4?Q?Sanj=F2?=) APEL/10.6 MULE XEmacs/21.5 (beta18)
 (chestnut) (+CVS-20041021) (i386-suse-linux)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

Hi,

At Wed, 24 Aug 2005 15:47:35 +0800,
Wei.Ni@uli.com.tw wrote:
> 
> Hi,Takashi Iwai & PeiSen Hou:
> We add some codes in hda_intel.c which is in
> alsa-driver-1.0.9b/alsa-kernel/pci/hda/ folder to support our HDA
> controller ULi M5461.
> Because that our controller has little different with Intel:
> 1.The M5461 have 11 streams(5 input streams and 6 output streams), and the
> Intel's controller is only support 8 streams.
> 2.The M5461 CORB/RIRB size's default value is 2 entries, and it need to set
> to 256 entries.
> Could you please update the hda driver to support our controller M5461?

Thanks for the patch.

We released a newer version of ALSA in the last week, ver 1.0.10rc1,
and the code was slightly changed since 1.0.9b.
The below is the patch to the latset CVS but should be applicable to
1.0.10rc1, too.  Could you check whether it works for you?

Also, since M5451 supports more streams, we'll need to fix the code
for better handling of stream assignment in future...


Takashi


Index: alsa-kernel/pci/hda/hda_intel.c
===================================================================
RCS file: /home/iwai/cvs/alsa/alsa-kernel/pci/hda/hda_intel.c,v
retrieving revision 1.17
diff -u -r1.17 hda_intel.c
--- alsa-kernel/pci/hda/hda_intel.c	16 Aug 2005 13:29:57 -0000	1.17
+++ alsa-kernel/pci/hda/hda_intel.c	24 Aug 2005 10:58:28 -0000
@@ -72,7 +72,8 @@
 			 "{ATI, SB450},"
 			 "{VIA, VT8251},"
 			 "{VIA, VT8237A},"
-			 "{SiS, SIS966}}");
+			 "{SiS, SIS966},"
+			 "{ULI, M5451}}");
 MODULE_DESCRIPTION("Intel HDA driver");
 
 #define SFX	"hda-intel: "
@@ -201,7 +202,6 @@
 };
 
 /* Defines for ATI HD Audio support in SB450 south bridge */
-#define ATI_SB450_HDAUDIO_PCI_DEVICE_ID     0x437b
 #define ATI_SB450_HDAUDIO_MISC_CNTR2_ADDR   0x42
 #define ATI_SB450_HDAUDIO_ENABLE_SNOOP      0x02
 
@@ -258,6 +258,7 @@
 struct snd_azx {
 	snd_card_t *card;
 	struct pci_dev *pci;
+	int driver_type;
 
 	/* pci resources */
 	unsigned long addr;
@@ -293,6 +294,15 @@
 	unsigned int initialized: 1;
 };
 
+/* driver types */
+enum {
+	AZX_DRIVER_ICH,
+	AZX_DRIVER_ATI,
+	AZX_DRIVER_VIA,
+	AZX_DRIVER_SIS,
+	AZX_DRIVER_ULI,
+};
+
 /*
  * macros for easy use
  */
@@ -361,6 +371,8 @@
 	azx_writel(chip, CORBLBASE, (u32)chip->corb.addr);
 	azx_writel(chip, CORBUBASE, upper_32bit(chip->corb.addr));
 
+	/* set the corb size to 256 entries (ULI requires explicitly) */
+	azx_writeb(chip, CORBSIZE, 0x02);
 	/* set the corb write pointer to 0 */
 	azx_writew(chip, CORBWP, 0);
 	/* reset the corb hw read pointer */
@@ -374,6 +386,8 @@
 	azx_writel(chip, RIRBLBASE, (u32)chip->rirb.addr);
 	azx_writel(chip, RIRBUBASE, upper_32bit(chip->rirb.addr));
 
+	/* set the rirb size to 256 entries (ULI requires explicitly) */
+	azx_writeb(chip, RIRBSIZE, 0x02);
 	/* reset the rirb hw write pointer */
 	azx_writew(chip, RIRBWP, ICH6_RBRWP_CLR);
 	/* set N=1, get RIRB response interrupt for new entry */
@@ -687,8 +701,7 @@
 	}
 
 	/* For ATI SB450 azalia HD audio, we need to enable snoop */
-	if (chip->pci->vendor == PCI_VENDOR_ID_ATI && 
-	    chip->pci->device == ATI_SB450_HDAUDIO_PCI_DEVICE_ID) {
+	if (chip->driver_type == AZX_DRIVER_ATI) {
 		pci_read_config_byte(chip->pci, ATI_SB450_HDAUDIO_MISC_CNTR2_ADDR, 
 				     &ati_misc_cntl2);
 		pci_write_config_byte(chip->pci, ATI_SB450_HDAUDIO_MISC_CNTR2_ADDR, 
@@ -1185,7 +1198,7 @@
  */
 static int __devinit azx_init_stream(azx_t *chip)
 {
-	int i;
+	int i, idx;
 
 	/* initialize each stream (aka device)
 	 * assign the starting bdl address to each stream (device) and initialize
@@ -1197,13 +1210,21 @@
 		azx_dev->bdl_addr = chip->bdl.addr + off;
 		if (chip->position_fix == POS_FIX_POSBUF)
 			azx_dev->posbuf = (volatile u32 *)(chip->posbuf.area + i * 8);
+
+		idx = i;
+		if (chip->driver_type == AZX_DRIVER_ULI) {
+			/* fix up the stream index for the last 4 streams */
+			if (i >= 4)
+				idx++;
+		}
+
 		/* offset: SDI0=0x80, SDI1=0xa0, ... SDO3=0x160 */
-		azx_dev->sd_addr = chip->remap_addr + (0x20 * i + 0x80);
+		azx_dev->sd_addr = chip->remap_addr + (0x20 * idx + 0x80);
 		/* int mask: SDI0=0x01, SDI1=0x02, ... SDO3=0x80 */
-		azx_dev->sd_int_sta_mask = 1 << i;
+		azx_dev->sd_int_sta_mask = 1 << idx;
 		/* stream tag: must be non-zero and unique */
-		azx_dev->index = i;
-		azx_dev->stream_tag = i + 1;
+		azx_dev->index = idx;
+		azx_dev->stream_tag = i + idx;
 	}
 
 	return 0;
@@ -1323,6 +1344,16 @@
 
 	chip->position_fix = posfix;
 
+#if BITS_PER_LONG != 64
+	/* Fix up base address on ULI M5461 */
+	if (chip->driver_type == AZX_DRIVER_ULI) {
+		u16 tmp3;
+		pci_read_config_word(pci, 0x40, &tmp3);
+		pci_write_config_word(pci, 0x40, tmp3 | 0x10);
+		pci_write_config_dword(pci, PCI_BASE_ADDRESS_1, 0);
+	}
+#endif
+
 	if ((err = pci_request_regions(pci, "ICH HD audio")) < 0) {
 		kfree(chip);
 		pci_disable_device(pci);
@@ -1463,13 +1494,13 @@
 
 /* PCI IDs */
 static struct pci_device_id azx_ids[] = {
-	{ 0x8086, 0x2668, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, /* ICH6 */
-	{ 0x8086, 0x27d8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, /* ICH7 */
-	{ 0x8086, 0x269a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, /* ESB2 */
-	{ 0x1002, 0x437b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, /* ATI SB450 */
-	{ 0x1106, 0x3288, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, /* VIA VT8251/VT8237A */
-	{ 0x1039, 0x7502, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, /* SIS966 */
-	{ 0x10b9, 0x5461, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, /* ALI 5461? */
+	{ 0x8086, 0x2668, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_ICH }, /* ICH6 */
+	{ 0x8086, 0x27d8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_ICH }, /* ICH7 */
+	{ 0x8086, 0x269a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_ICH }, /* ESB2 */
+	{ 0x1002, 0x437b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_ATI }, /* ATI SB450 */
+	{ 0x1106, 0x3288, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_VIA }, /* VIA VT8251/VT8237A */
+	{ 0x1039, 0x7502, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_SIS }, /* SIS966 */
+	{ 0x10b9, 0x5461, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_ULI }, /* ULI M5461 */
 	{ 0, }
 };
 MODULE_DEVICE_TABLE(pci, azx_ids);
