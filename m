Return-Path: <linux-kernel-owner@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id <S129574AbRCBWcz>; Fri, 2 Mar 2001 17:32:55 -0500
Received: (majordomo@vger.kernel.org) by vger.kernel.org
	id <S129581AbRCBWcp>; Fri, 2 Mar 2001 17:32:45 -0500
Received: from mailout05.sul.t-online.com ([194.25.134.82]:41220 "EHLO
	mailout05.sul.t-online.com") by vger.kernel.org with ESMTP
	id <S129574AbRCBWcd>; Fri, 2 Mar 2001 17:32:33 -0500
Message-Id: <200103022232.XAA20644@fire.malware.de>
Date: Fri, 02 Mar 2001 23:32:17 +0100
From: malware@t-online.de (Michael Mueller)
X-Mailer: Mozilla 4.61 [en] (X11; U; Linux 2.4.0-ac1 i586)
X-Accept-Language: de, en
MIME-Version: 1.0
Newsgroups: comp.os.linux.development.system
CC: linux-kernel@vger.kernel.org
Subject: Re: Strange 2.4.2 boot error
In-Reply-To: <3A9A9A75.6B6B5311@idcomm.com> <97ensv$u1k$1@fire.malware.de> <3A9B3CFD.CEBF80B6@idcomm.com> <97hf1j$cd1$1@fire.malware.de> <3A9C80BC.E5984683@idcomm.com>
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
To: unlisted-recipients:; (no To-header on input)@pop.zip.com.au
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

Hi folks and D. Stimits,

Summary of discussion taken place so far (for linux-kernel people):

D. Stimits noticed he can not boot his kernel from a 1.44MB floppy
created with "make bzdisk". This would lead into a register dump. The
dump does show the boot code tries to read track 80 of the disk.

However mkbootdisk as delivered with a pre-release of the RedHat 7.1
distribution can be used to create a working boot disk using the bzImage
generated by above.

My last question to D. Stimits was:
> > How large is the file ./arch/i386/boot/bzImage?

And he answered
> 1040155 Feb 24 23:28 bzImage
>
> Definitely within 1.44 Mb floppy size.

I see following problem with the bootsector code for bzImage:

Within bootsector the size of the kernel is stored as number of 16 byte
blocks. This gives a number of 0xfdf2 in this case.

Now while loading the kernel the bootsector code calls a helper routine
(in setup[.S]) which does copy 64kByte if available and does nothing
else. This routine does the return the number of 16 byte blocks read.
This number then is a multiple of 1000h. 

So no when a kernel of above size is completely loaded the count of the
16 byte blocks returned by the helper routine wents from f000h into
0000h due to the 16 bit size of the register ax used. The bootsector
code does then compare 0000h to fdf2h and it is less, so it does
continue loading until it does reach the end of the disk and fails with
a read error.


Malware
