Return-Path: <linux-kernel-owner+willy=40w.ods.org-S1750927AbWBXGNV@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1750927AbWBXGNV (ORCPT <rfc822;willy@w.ods.org>);
	Fri, 24 Feb 2006 01:13:21 -0500
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S1750932AbWBXGNV
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Fri, 24 Feb 2006 01:13:21 -0500
Received: from fgwmail7.fujitsu.co.jp ([192.51.44.37]:53956 "EHLO
	fgwmail7.fujitsu.co.jp") by vger.kernel.org with ESMTP
	id S1750925AbWBXGNU (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
	Fri, 24 Feb 2006 01:13:20 -0500
Date: Fri, 24 Feb 2006 15:12:29 +0900
Message-ID: <87acchz3n6.wl%muneda.takahiro@jp.fujitsu.com>
From: MUNEDA Takahiro <muneda.takahiro@jp.fujitsu.com>
To: Kristen Accardi <kristen.c.accardi@intel.com>
Cc: linux-kernel@vger.kernel.org, linux-acpi@vger.kernel.org,
       pcihpd-discuss@lists.sourceforge.net, greg@kroah.com,
       len.brown@intel.com, muneda.takahiro@jp.fujitsu.com, pavel@ucw.cz
Subject: Re: [patch 2/3] acpiphp: add dock event handling
In-Reply-To: <1140724577.11750.17.camel@whizzy>
References: <20060223195022.747891000@intel.com>
	<1140724577.11750.17.camel@whizzy>
User-Agent: Wanderlust/2.14.1 (Bad Medicine-pre) SEMI/1.14.6 (Maruoka) LIMIT/1.14.9 (Domyoji) APEL/10.6 Emacs/22.0.50 (i686-pc-linux-gnu) MULE/5.0 (SAKAKI)
X-Pollen: =?ISO-2022-JP?B?Mi8yNRskQiROQEUyLDgpRWxJdCROP3kyVko0JE8+LyRKGyhC?=
 =?ISO-2022-JP?B?GyRCJCQkRyQ5GyhC?=
X-Weather: =?ISO-2022-JP?B?GyRCTEBGfCROQEUyLDgpJE9GXjt+ITkxKyRHJDkbKEI=?=
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

At Thu, 23 Feb 2006 11:56:17 -0800,
Kristen Accardi <kristen.c.accardi@intel.com> wrote:
> 
> @@ -828,11 +862,21 @@ static int acpiphp_bus_add(struct acpiph
>  		dbg("no parent device, assuming NULL\n");
>  		pdevice = NULL;
>  	}
> +	if (!acpi_bus_get_device(func->handle, &device)) {
> +		dbg("bus exists... trim\n");
> +		/* this shouldn't be in here, so remove
> +		 * the bus then re-add it...
> +		 */
> +		ret_val = acpi_bus_trim(device, 1);
> +		dbg("acpi_bus_trim return %x\n", ret_val);
> +	}
>  	ret_val = acpi_bus_add(&device, pdevice, func->handle,
> -			ACPI_BUS_TYPE_DEVICE);
> -	if (ret_val)
> -		dbg("cannot add bridge to acpi list\n");
> -
> +		ACPI_BUS_TYPE_DEVICE);
> +	if (ret_val) {
> +		dbg("error adding bus, %x\n",
> +			-ret_val);
> +		goto acpiphp_bus_add_out;
> +	}
>  	/*
>  	 * try to start anyway.  We could have failed to add
>  	 * simply because this bus had previously been added

Hi Kristen,

Why don't you call acpi_bus_trim() when the device is
removed. This time, eject_dock() or disable_device()?
So you don't need to call acpi_bus_trim() as error case.

Thanks,
MUNE

