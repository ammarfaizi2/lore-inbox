Return-Path: <linux-kernel-owner+willy=40w.ods.org-S1030583AbWKOP0m@vger.kernel.org>
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1030583AbWKOP0m (ORCPT <rfc822;willy@w.ods.org>);
	Wed, 15 Nov 2006 10:26:42 -0500
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S1030582AbWKOP0m
	(ORCPT <rfc822;linux-kernel-outgoing>);
	Wed, 15 Nov 2006 10:26:42 -0500
Received: from omx1-ext.sgi.com ([192.48.179.11]:28342 "EHLO
	omx1.americas.sgi.com") by vger.kernel.org with ESMTP
	id S1030581AbWKOP0k (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
	Wed, 15 Nov 2006 10:26:40 -0500
From: John Keller <jpk@sgi.com>
To: pcihpd-discuss@lists.sourceforge.net
Cc: akpm@osdl.org, len.brown@intel.com, tony.luck@intel.com,
       linux-ia64@vger.kernel.org, gregkh@suse.de,
       linux-kernel@vger.kernel.org, linux-acpi@vger.kernel.org,
       ayoung@sgi.com, jes@sgi.com, John Keller <jpk@sgi.com>
Date: Wed, 15 Nov 2006 09:26:31 -0600
Message-Id: <20061115152631.6131.63679.sendpatchset@attica.americas.sgi.com>
Subject: [PATCH 2/3] - Altix: Add ACPI SSDT PCI device support (hotplug)
Sender: linux-kernel-owner@vger.kernel.org
X-Mailing-List: linux-kernel@vger.kernel.org

 Support for dynamic loading and unloading of ACPI
 SSDT tables upon slot hotplugs and unplugs.

 On SN platforms, we now represent every
 populated root bus slot with a single ACPI
 SSDT table containing info for every
 device and PPB attached to the slot. These SSDTs
 are generated by the prom at initial boot
 and hotplug time. The info in these SSDT tables is
 used by the SN kernel IO "fixup" code (which is called
 at boot and hotplug time).

 On hotplugs (i.e. enable_slot()), if running with
 an ACPI capable prom, attempt to obtain a new ACPI SSDT
 table for the slot being hotplugged. If successful, add
 the table to the ACPI namespace (acpi_load_table()) and
 then walk the new devices and add them to the ACPI
 infrastructure (acpi_bus_add()).

 On hot unplugs (i.e. disable_slot()), if running with
 an ACPI capable prom, attempt to remove the SSDT table
 associated with the slot from the ACPI namespace
 (acpi_unload_table_id()) and infastructure (acpi_bus_trim()).

Signed-off-by:  Aaron Young <ayoung@sgi.com>

---

 Note: This patch is dependent on a previous set of SN ACPI
       patches.

        altix-add-initial-acpi-io-support.patch
        altix-sn-acpi-hotplug-support.patch
        altix-initial-acpi-support-rom-shadowing.patch


drivers/pci/hotplug/sgi_hotplug.c |  145 ++++++++++++++++++++++++++--
 1 file changed, 138 insertions(+), 7 deletions(-)


Index: linux-2.6/drivers/pci/hotplug/sgi_hotplug.c
===================================================================
--- linux-2.6.orig/drivers/pci/hotplug/sgi_hotplug.c	2006-10-23 08:56:53.772616307 -0500
+++ linux-2.6/drivers/pci/hotplug/sgi_hotplug.c	2006-10-23 09:16:51.289186573 -0500
@@ -28,6 +28,9 @@
 #include <asm/sn/sn_feature_sets.h>
 #include <asm/sn/sn_sal.h>
 #include <asm/sn/types.h>
+#include <linux/acpi.h>
+#include <acpi/acnamesp.h>
+#include <asm/sn/acpi.h>
 
 #include "../pci.h"
 
@@ -35,14 +38,17 @@ MODULE_LICENSE("GPL");
 MODULE_AUTHOR("SGI (prarit@sgi.com, dickie@sgi.com, habeck@sgi.com)");
 MODULE_DESCRIPTION("SGI Altix Hot Plug PCI Controller Driver");
 
-#define PCIIO_ASIC_TYPE_TIOCA		4
+
+/* SAL call error codes. Keep in sync with prom header io/include/pcibr.h */
 #define PCI_SLOT_ALREADY_UP		2	/* slot already up */
 #define PCI_SLOT_ALREADY_DOWN		3	/* slot already down */
 #define PCI_L1_ERR			7	/* L1 console command error */
 #define PCI_EMPTY_33MHZ			15	/* empty 33 MHz bus */
+
+
+#define PCIIO_ASIC_TYPE_TIOCA		4
 #define PCI_L1_QSIZE			128	/* our L1 message buffer size */
 #define SN_MAX_HP_SLOTS			32	/* max hotplug slots */
-#define SGI_HOTPLUG_PROM_REV		0x0430	/* Min. required PROM version */
 #define SN_SLOT_NAME_SIZE		33	/* size of name string */
 
 /* internal list head */
@@ -227,7 +233,7 @@ static void sn_bus_free_data(struct pci_
 }
 
 static int sn_slot_enable(struct hotplug_slot *bss_hotplug_slot,
-			  int device_num)
+			  int device_num, char **ssdt)
 {
 	struct slot *slot = bss_hotplug_slot->private;
 	struct pcibus_info *pcibus_info;
@@ -240,7 +246,8 @@ static int sn_slot_enable(struct hotplug
 	 * Power-on and initialize the slot in the SN
 	 * PCI infrastructure.
 	 */
-	rc = sal_pcibr_slot_enable(pcibus_info, device_num, &resp);
+	rc = sal_pcibr_slot_enable(pcibus_info, device_num, &resp, ssdt);
+
 
 	if (rc == PCI_SLOT_ALREADY_UP) {
 		dev_dbg(slot->pci_bus->self, "is already active\n");
@@ -335,6 +342,7 @@ static int enable_slot(struct hotplug_sl
 	int func, num_funcs;
 	int new_ppb = 0;
 	int rc;
+	char *ssdt = NULL;
 	void pcibios_fixup_device_resources(struct pci_dev *);
 
 	/* Serialize the Linux PCI infrastructure */
@@ -342,14 +350,29 @@ static int enable_slot(struct hotplug_sl
 
 	/*
 	 * Power-on and initialize the slot in the SN
-	 * PCI infrastructure.
+	 * PCI infrastructure. Also, retrieve the ACPI SSDT
+	 * table for the slot (if ACPI capable PROM).
 	 */
-	rc = sn_slot_enable(bss_hotplug_slot, slot->device_num);
+	rc = sn_slot_enable(bss_hotplug_slot, slot->device_num, &ssdt);
 	if (rc) {
 		mutex_unlock(&sn_hotplug_mutex);
 		return rc;
 	}
 
+	if (ssdt)
+		ssdt = __va(ssdt);
+	/* Add the new SSDT for the slot to the ACPI namespace */
+	if (SN_ACPI_BASE_SUPPORT() && ssdt) {
+		acpi_status ret;
+
+		ret = acpi_load_table((struct acpi_table_header *)ssdt);
+		if (ACPI_FAILURE(ret)) {
+			printk(KERN_ERR "%s: acpi_load_table failed (0x%x)\n",
+			       __FUNCTION__, ret);
+			/* try to continue on */
+		}
+	}
+
 	num_funcs = pci_scan_slot(slot->pci_bus,
 				  PCI_DEVFN(slot->device_num + 1, 0));
 	if (!num_funcs) {
@@ -374,7 +397,10 @@ static int enable_slot(struct hotplug_sl
 			 * pdi_host_pcidev_info).
 			 */
 			pcibios_fixup_device_resources(dev);
-			sn_pci_fixup_slot(dev);
+			if (SN_ACPI_BASE_SUPPORT())
+				sn_acpi_slot_fixup(dev);
+			else
+				sn_io_slot_fixup(dev);
 			if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
 				unsigned char sec_bus;
 				pci_read_config_byte(dev, PCI_SECONDARY_BUS,
@@ -388,6 +414,59 @@ static int enable_slot(struct hotplug_sl
 		}
 	}
 
+	/*
+	 * Add the slot's devices to the ACPI infrastructure */
+	if (SN_ACPI_BASE_SUPPORT() && ssdt) {
+		unsigned long adr;
+		struct acpi_namespace_node *cnode = NULL;
+		struct acpi_namespace_node *rootbus_node;
+		struct acpi_device *device;
+		struct acpi_device *pdevice;
+		acpi_handle handle;
+		acpi_handle phandle;
+		acpi_status ret;
+
+		phandle = PCI_CONTROLLER(slot->pci_bus)->acpi_handle;
+
+		if (acpi_bus_get_device(phandle, &pdevice)) {
+			dev_dbg(slot->pci_bus->self,
+				"no parent device, assuming NULL\n");
+			pdevice = NULL;
+		}
+
+		/* Get the rootbus node pointer */
+		rootbus_node = acpi_ns_map_handle_to_node(phandle);
+
+		/*
+		 * Walk the rootbus node's immediate children looking for
+		 * the slot's device node(s). There can be more than
+		 * one for multifunction devices.
+		 */
+		while ((cnode = acpi_ns_get_next_node(ACPI_TYPE_DEVICE,
+						      rootbus_node,
+						      cnode))) {
+
+			handle = acpi_ns_convert_entry_to_handle(cnode);
+
+			ret = acpi_evaluate_integer(handle, METHOD_NAME__ADR,
+						    NULL, &adr);
+
+			if (ACPI_SUCCESS(ret) &&
+			    (adr>>16) == (slot->device_num + 1)) {
+				ret = acpi_bus_add(&device, pdevice, handle,
+						   ACPI_BUS_TYPE_DEVICE);
+				if (ACPI_FAILURE(ret)) {
+					printk(KERN_ERR "%s: acpi_bus_add "
+					       "failed (0x%x) for slot %d "
+					       "func %d\n", __FUNCTION__,
+					       ret, (int)(adr>>16),
+					       (int)(adr&0xffff));
+					/* try to continue on */
+				}
+			}
+		}
+	}
+
 	/* Call the driver for the new device */
 	pci_bus_add_devices(slot->pci_bus);
 	/* Call the drivers for the new devices subordinate to PPB */
@@ -422,6 +501,58 @@ static int disable_slot(struct hotplug_s
 	if (rc)
 		goto leaving;
 
+	/* Remove the SSDT for the slot from the ACPI namespace */
+	if (SN_ACPI_BASE_SUPPORT() &&
+            PCI_CONTROLLER(slot->pci_bus)->acpi_handle) {
+		unsigned long adr;
+		struct acpi_device *device;
+		struct acpi_namespace_node *cnode = NULL;
+		struct acpi_namespace_node *rootbus_node;
+		acpi_handle child_handle;
+		acpi_handle phandle;
+		acpi_status ret;
+		acpi_owner_id ssdt_id = 0;
+
+		/* Get the rootbus node pointer */
+		phandle = PCI_CONTROLLER(slot->pci_bus)->acpi_handle;
+		rootbus_node = acpi_ns_map_handle_to_node(phandle);
+
+		/*
+		 * Walk the rootbus node's immediate children looking for
+		 * the slot's device node(s). There can be more than
+		 * one for multifunction devices.
+		 */
+		while ((cnode = acpi_ns_get_next_node(ACPI_TYPE_DEVICE,
+						      rootbus_node,
+						      cnode))) {
+
+			child_handle = acpi_ns_convert_entry_to_handle(cnode);
+			ret = acpi_evaluate_integer(child_handle,
+						    METHOD_NAME__ADR,
+						    NULL, &adr);
+			if (ACPI_SUCCESS(ret) &&
+			    (adr>>16) == (slot->device_num + 1)) {
+				/* retain the owner id */
+				ssdt_id = cnode->owner_id;
+
+				ret = acpi_bus_get_device(child_handle,
+							  &device);
+				if (ACPI_SUCCESS(ret))
+					acpi_bus_trim(device, 1);
+			}
+		}
+
+		if (ssdt_id) {
+			ret = acpi_unload_table_id(ACPI_TABLE_ID_SSDT, ssdt_id);
+			if (ACPI_FAILURE(ret)) {
+				printk(KERN_ERR "%s: acpi_unload_table_id "
+				       "failed (0x%x) for id %d\n",
+				       __FUNCTION__, ret, ssdt_id);
+				/* try to continue on */
+			}
+		}
+	}
+
 	/* Free the SN resources assigned to the Linux device.*/
 	for (func = 0; func < 8;  func++) {
 		dev = pci_get_slot(slot->pci_bus,
